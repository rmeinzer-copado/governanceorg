{
    "recordTypeMap": {},
    "RecordSetBundles": [
        {
            "Records": [
                {
                    "attributes": {
                        "type": "copado__Function__c",
                        "url": "/services/data/v52.0/sobjects/copado__Function__c/a0k09000000FKgfAAG"
                    },
                    "copado__API_Name__c": "Devhub_Package_Info",
                    "copado__Description__c": "Extracts package and package versions info from a DevHub",
                    "copado__Image_Name__c": "copado-multicloud-dx:v3",
                    "copado__Options__c": "[ ]",
                    "copado__Parameters__c": "[ {\n  \"required\" : true,\n  \"name\" : \"packageNameOrId\",\n  \"defaultValue\" : \"{$Context.JobExecution__r.DataJson.packageNameOrId}\"\n}, {\n  \"required\" : true,\n  \"name\" : \"session\",\n  \"defaultValue\" : \"{$Source.Credential.SessionId}\"\n}, {\n  \"required\" : true,\n  \"name\" : \"baseUrl\",\n  \"defaultValue\" : \"{$Source.Credential.Endpoint}\"\n} ]",
                    "copado__Script__c": "#!/usr/bin/env node\nconst { execSync } = require('child_process'),\n    { session, baseUrl, packageNameOrId } = process.env,\n    url = baseUrl.substring(0, baseUrl.indexOf('/', baseUrl.indexOf('/') + 2)),\n    { writeFileSync} = require('fs'),\n    checkLog = 'Please check the logs for details',\n    PACKAGE_DETAILS_FILE_NAME = 'PackageAndVersions.json';\n\n// EXECUTION\n\nexecute();\n\nfunction execute() {\n    try {\n        setInstanceURL();\n        createSFDXProject();\n\n        const pkg = getPackageDetails();\n\n        if (pkg) {\n            const versions = getPackageVersions(pkg.Id);\n\n            writeFileSync(PACKAGE_DETAILS_FILE_NAME, JSON.stringify({ pkg, versions }))\n            uploadFile(PACKAGE_DETAILS_FILE_NAME);\n        } else {\n            throw `Couldn't find details of package ${packageNameOrId} in devHub.`;\n        }\n    } catch (err) {\n        //Error status = 3, is when we have Custom Error Message, where error is already populated on result and hence we do not need to call it again.\n        if (err?.status === 3) {\n            process.exit(1);\n        }\n        execSync(showError(err.toString()));\n    }\n}\n\n// SCRIPT FUNCTIONS\n\nfunction showError(error) {\n    const refinedErrorMsg = maskSensitiveInformation(error);\n    return `copado -p 'Error' -e ${escapeSpecialCharacters(JSON.stringify(refinedErrorMsg)).replace(/\\\\n/g, '\\n').replace(/\\\\t/g, '\\t')} && exit 3`;\n}\n\nfunction setInstanceURL() {\n    execSync(`\n    copado -p 'Setting instance url'\n    sfdx force:config:set instanceUrl=${url} --global || (${showError(`Error setting instance URL, ${checkLog}`)})\n\t`);\n}\n\nfunction createSFDXProject() {\n    execSync(`\n    sfdx force:project:create -n temp || (${showError(`Error creating SFDX project, ${checkLog}`)})\n  `);\n}\n\nfunction getPackageList() {\n    return JSON.parse(\n        execSync(`\n      copado -p 'Getting Package Info'\n      cd temp\n      sfdx force:package:list -v ${session} --json\n\t`).toString()\n    );\n}\n\nfunction getPackageDetails() {\n    const packages = getPackageList();\n    if (packages.status) {\n        throw `${packages.name}: ${packages.message}`;\n    } else {\n        return packages.result.find((element) => element.Name == packageNameOrId || element.Id == packageNameOrId);\n    }\n}\n\n\n\nfunction getPackageVersions(packageId) {\n    const versions = JSON.parse(\n        execSync(`\n    cd temp\n    sfdx force:package:version:list -v ${session} -p ${packageId} --json\n  `).toString()\n    );\n\n    if (versions.status) {\n        throw `${versions.name}: ${versions.message}`;\n    } else {\n        return versions.result;\n    }\n}\n\nfunction escapeSpecialCharacters(text) {\n    let result = text.replace(/`/g, '\\\\`').replace(/\\$/g, '\\\\$');\n\n    return result;\n}\n\nfunction maskSensitiveInformation(data) {\n    const sensitiveInfo = ['--targetdevhubusername', '-u', '-v'],\n        maskingSequence = '*****';\n\n    const arrayOfData = data.split(' ');\n    sensitiveInfo.forEach((subString) => {\n        const keyIndex = arrayOfData.indexOf(subString);\n        if (keyIndex > -1) {\n            arrayOfData[keyIndex + 1] = maskingSequence;\n            data = arrayOfData.join(' ');\n        }\n    });\n    return data;\n}\n\nfunction uploadFile(fileName) {\n    execSync(`copado --uploadfile ${fileName} || (${showError(`Error uploading ${fileName}, ${checkLog}`)})`, {stdio: 'inherit'});\n}",
                    "copado__Type__c": "Standard",
                    "copado__Version__c": "1.0",
                    "copado__Worker_Size__c": "S",
                    "CreatedDate": "2021-09-16T15:20:01.000+0000",
                    "Id": "a0k09000000FKgfAAG",
                    "IsDeleted": false,
                    "LastModifiedDate": "2021-09-28T13:50:51.000+0000",
                    "LastReferencedDate": "2021-09-29T14:36:54.000+0000",
                    "LastViewedDate": "2021-09-29T14:36:54.000+0000",
                    "Name": "Devhub Package Info",
                    "SystemModstamp": "2021-09-28T13:50:51.000+0000"
                },
                {
                    "attributes": {
                        "type": "copado__Function__c",
                        "url": "/services/data/v57.0/sobjects/copado__Function__c/a0l7Q000000iAiJQAU"
                    },
                    "copado__API_Name__c": "sfdx_install_package",
                    "copado__Callback_Type__c": "Flow",
                    "copado__FlowHandler__c": "cmcSf.Installed_Package_Callback",
                    "copado__Image_Name__c": "copado-multicloud-dx:v3",
                    "copado__Options__c": "[ ]",
                    "copado__Parameters__c": "[ {\n  \"required\" : true,\n  \"name\" : \"packages\",\n  \"defaultValue\" : \"{$Context.apex.cmcSf.GetInstallationKeys}\"\n}, {\n  \"required\" : true,\n  \"name\" : \"destinationBaseUrl\",\n  \"defaultValue\" : \"{$Destination.Credential.Endpoint}\"\n}, {\n  \"required\" : true,\n  \"name\" : \"destinationSession\",\n  \"defaultValue\" : \"{$Destination.Credential.SessionId}\"\n}, {\n  \"required\" : false,\n  \"name\" : \"retrialTimes\",\n  \"defaultValue\" : \"{$Property.sfdx_package_install_retrial_time}\"\n}, {\n  \"name\" : \"apiVersion\",\n  \"defaultValue\" : \"{$Context.JobExecution__r.DataJson.apiVersion}\"\n}, {\n  \"name\" : \"devhubSession\",\n  \"defaultValue\" : \"{$Source.Credential.SessionId}\"\n}, {\n  \"name\" : \"devhubBaseUrl\",\n  \"defaultValue\" : \"{$Source.Credential.Endpoint}\"\n}, {\n  \"name\" : \"installationSecurityType\",\n  \"defaultValue\" : \"{$Context.JobExecution__r.DataJson.installSecurityType}\"\n}, {\n  \"name\" : \"pollInterval\",\n  \"defaultValue\" : \"{$Property.sfdx_package_install_poll_time_in_seconds}\"\n} ]",
                    "copado__Script__c": "#!/usr/bin/env node\n\nconst { execSync, exec } = require('child_process'),\n    {\n        packages,\n        destinationBaseUrl,\n        destinationSession,\n        apiVersion,\n        devhubSession,\n        devhubBaseUrl,\n        installationSecurityType,\n        pollInterval,\n        retrialTimes\n    } = process.env,\n    destinationUrl = getUrl(destinationBaseUrl),\n    devhubUrl = getUrl(devhubBaseUrl),\n    fetchReportRetrialTimes = retrialTimes ? parseInt(retrialTimes) : 3,\n    installPollIntervalInSec = pollInterval ? parseInt(pollInterval) : 30;\n\n// EXECUTION\n\nexecute();\n\nasync function execute() {\n    try {\n        const listOfPackages = JSON.parse(packages),\n            response = getVersionsWithStatus(listOfPackages),\n            mainPackageId = listOfPackages.length && listOfPackages[listOfPackages.length - 1]?.id;\n\n        const filteredPackages = filterPackagesToInstall(response, listOfPackages);\n        if (filteredPackages?.length) {\n            setInstanceURL(destinationUrl, 'destination org');\n            await installPackages(filteredPackages, mainPackageId);\n        }\n\n        execSync(`copado -p 'Updating Results' -r ${JSON.stringify(JSON.stringify(response))}`);\n    } catch (error) {\n        //Error status = 3, is when we have Custom Error Message, where error is already populated on result and hence we do not need to call it again.\n        if (error?.status === 3) {\n            process.exit(1);\n        }\n        execSync(showErrorCmd(error.toString()));\n    }\n}\n\n// SCRIPT FUNCTIONS\n\nfunction setInstanceURL(url, destination) {\n    execSync(\n        `\n        copado -p 'Setting instance url(${destination})'\n        sfdx force:config:set instanceUrl=${url} --global || (${showErrorCmd(`Error setting instance URL`)})\n    `,\n        { stdio: 'inherit' }\n    );\n}\n\nasync function installPackages(listOfPackages, mainPackageId) {\n    for await (pkg of listOfPackages) {\n        if (pkg.id) {\n            const isMainPackage = mainPackageId === pkg.id;\n            await install(pkg, isMainPackage);\n        } else {\n            throw 'Could not find Subscriber Package Version Id';\n        }\n    }\n}\n\nfunction installPackage(pckg, isMainPackage) {\n    let params = `-u ${destinationSession} -p ${pckg.id} --noprompt`;\n    params += pckg.key ? ` -k '${pckg.key}'` : '';\n    params += apiVersion ? ` --apiversion ${apiVersion}` : '';\n    params += isMainPackage && installationSecurityType ? ` --securitytype ${installationSecurityType}` : '';\n\n    const installCmd = `sfdx force:package:install ${params} --json || true`;\n    \n    const logMessage = `Package Install Command ==> ${installCmd}`;\n    logger(pckg.key ? maskSensitiveInformation(logMessage, { '-k': pckg.key }) : logMessage);\n\n    const response = JSON.parse(\n        execSync(`\n            copado -p 'Installing package ${pckg.id}'\n            ${installCmd}\n        `).toString()\n    );\n\n    logger(`Package Install Response ==> ${JSON.stringify(response)}`);\n    if (response?.status) {\n        throw `Error installing packageID ${pckg.id} : ${response?.name}: ${response?.message}`;\n    }\n\n    return response;\n}\n\nasync function pollInstallStatus(jobId, packageId) {\n    let counter = 0;\n    return new Promise((resolve, reject) => {\n        const poll = setInterval(() => {\n            const response = getInstallRequestReport(jobId, destinationSession);\n\n            if (!response?.status && response?.result?.Status === 'SUCCESS') {\n                logger(`Package with Id ${packageId} successfully installed. ${JSON.stringify(response)}`);\n\n                clearInterval(poll);\n                resolve(response);\n            } else if (response?.status) {\n                logger(`Package with Id ${packageId} failed to install or fetch report. ${JSON.stringify(response)}`);\n\n                if ((response?.message?.includes('ETIMEDOUT') || response?.name === 'INVALID_FIELD') && ++counter <= fetchReportRetrialTimes) {\n                    logger(`Retrying attempt ${counter} to fetch installation status of jobId: ${jobId}`);\n                } else {\n                    clearInterval(poll);\n                    reject(response?.message);\n                }\n            }\n        }, installPollIntervalInSec * 1000);\n    });\n}\n\nasync function install(pkg, isMainPackage) {\n    try {\n        const installResponse = installPackage(pkg, isMainPackage);\n\n        const jobId = installResponse?.result?.Id;\n        if (jobId) {\n            await pollInstallStatus(jobId, pkg.id);\n        } else {\n            throw `Could not receieve package install request id for package: ${pkg.id}`;\n        }\n    } catch (error) {\n        execSync(showErrorCmd(error.toString()));\n    }\n}\n\nfunction showErrorCmd(error) {\n    let modifiedError = error + ' ,Please check the logs for details';\n    const refinedErrorMsg = maskSensitiveInformation(modifiedError, { '-u': destinationSession });\n    return `copado -p 'Error' -e ${escapeSpecialCharacters(JSON.stringify(refinedErrorMsg)).replace(/\\\\n/g, '\\n')} && exit 3`;\n}\n\nfunction logger(text) {\n    console.log(text);\n}\n\nfunction checkVersionFromDevhub(subscriberId, installationKey) {\n    setInstanceURL(devhubUrl, 'devhub');\n\n    const query = `SELECT MajorVersion, MinorVersion, PatchVersion, BuildNumber, SubscriberPackageId FROM SubscriberPackageVersion WHERE Id='${subscriberId}' ${\n        installationKey ? `AND InstallationKey='${installationKey}'` : ''\n    }`;\n    let result = execSync(`\n            copado -p 'Querying SubscriberPackageVersion Tooling API'\n\t\t\tsfdx force:data:soql:query -t -q \"${query}\" -u ${devhubSession} --json || true\n\t\t`).toString();\n    logger(`SubscriberPackageVersion Tooling API response => ${result}`);\n\n    result = JSON.parse(result);\n    if (result?.status) {\n        throw `${result?.name} - ${result?.message}`;\n    }\n    return result;\n}\n\nfunction getInstalledPackageVersion(SubscriberPackageId) {\n    setInstanceURL(destinationUrl, 'destination org');\n\n    const query = `SELECT Id, SubscriberPackageId, SubscriberPackage.NamespacePrefix, SubscriberPackage.Name, SubscriberPackageVersion.Id, SubscriberPackageVersion.Name, SubscriberPackageVersion.MajorVersion, SubscriberPackageVersion.MinorVersion, SubscriberPackageVersion.PatchVersion, SubscriberPackageVersion.BuildNumber FROM InstalledSubscriberPackage where SubscriberPackageId = '${SubscriberPackageId}'`;\n    let result = execSync(`\n            copado -p 'Querying InstalledSubscriberPackage Tooling API'\n\t\t\tsfdx force:data:soql:query -t -q \"${query}\" -u ${destinationSession} --json || true\n\t\t`).toString();\n    logger(`InstalledSubscriberPackage Tooling API response => ${result}`);\n\n    result = JSON.parse(result);\n    if (result?.status) {\n        throw `${result?.name} - ${result?.message}`;\n    }\n    return result;\n}\n\nfunction compareVersion(installed, installing) {\n    const value = installed.localeCompare(installing, undefined, { numeric: true, sensitivity: 'base' });\n    return value < 0;\n}\n\nfunction checkVersionCompatibility(pkg) {\n    let installPkg = true,\n        version = !pkg.subscriberPackageId && checkVersionFromDevhub(pkg.id, pkg.key);\n\n    if (version?.result?.records.length || pkg.subscriberPackageId) {\n        const installedVersion = getInstalledPackageVersion(version?.result?.records[0].SubscriberPackageId || pkg.subscriberPackageId);\n\n        if (installedVersion?.result?.totalSize) {\n            const installed = installedVersion.result.records[0].SubscriberPackageVersion,\n                installing = version?.result?.records[0];\n\n            installPkg = compareVersion(generateVersionName(installed), installing ? generateVersionName(installing) : pkg.versionNumber);\n        }\n    }\n    return installPkg ? 'success' : 'skipped';\n}\n\nfunction generateVersionName(version) {\n    return `${version.MajorVersion}.${version.MinorVersion}.${version.PatchVersion}.${version.BuildNumber}`;\n}\n\nfunction getVersionsWithStatus(packages) {\n    let subscriberIds = [];\n\n    for (pkg of packages) {\n        const status = checkVersionCompatibility(pkg);\n        subscriberIds.push({ versionId: pkg.id, status: status });\n    }\n\n    return subscriberIds;\n}\n\nfunction filterPackagesToInstall(response, listOfPackages) {\n    return response.reduce((filtered, option) => {\n        if (option.status === 'success') {\n            filtered.push({ id: option.versionId, key: listOfPackages.find((pkg) => pkg.id === option.versionId).key });\n        }\n        return filtered;\n    }, []);\n}\n\nfunction getUrl(baseUrl) {\n    return baseUrl.substring(0, baseUrl.indexOf('/', baseUrl.indexOf('/') + 2));\n}\n\nfunction escapeSpecialCharacters(text) {\n    let result = text.replace(/`/g, '\\\\`').replace(/\\$/g, '\\\\$');\n\n    return result;\n}\n\nfunction maskSensitiveInformation(data, sensitiveFlags) {\n    const maskingSequence = '*****';\n\n    const arrayOfData = data.split(' ');\n    Object.keys(sensitiveFlags).forEach((subStr) => {\n        const keyIndex = arrayOfData.indexOf(subStr);\n        if (keyIndex > -1) {\n            arrayOfData[keyIndex + 1] = maskingSequence;\n            arrayOfData.splice(keyIndex + 2, sensitiveFlags[subStr].split(' ').length - 1);\n        }\n    });\n    return arrayOfData.join(' ');\n}\n\nfunction getInstallRequestReport(jobId, session) {\n    return JSON.parse(\n        execSync(`\n        copado -p 'Fetch installation status for jobID: ${jobId}'\n        sfdx force:package:install:report --requestid ${jobId} -u ${session} --json || true\n    `).toString()\n    );\n}",
                    "copado__Timeout__c": 200,
                    "copado__Type__c": "Standard",
                    "copado__Version__c": "1.0",
                    "Id": "a0l7Q000000iAiJQAU",
                    "LastReferencedDate": "2023-04-13T06:43:00.000+0000",
                    "LastViewedDate": "2023-04-13T06:43:00.000+0000",
                    "Name": "Sfdx Install Package"
                },
                {
                    "attributes": {
                        "type": "copado__Function__c",
                        "url": "/services/data/v57.0/sobjects/copado__Function__c/a0l7Q000000MDYvQAO"
                    },
                    "copado__API_Name__c": "sfdx_deploy",
                    "copado__Callback_Type__c": "Flow",
                    "copado__Description__c": "Deploys promotion branch",
                    "copado__FlowHandler__c": "cmcSf.Deploy_Function_Callback",
                    "copado__Image_Name__c": "copado-multicloud-dx:v3",
                    "copado__Options__c": "[ ]",
                    "copado__Parameters__c": "[ {\n  \"required\" : true,\n  \"name\" : \"fileChangesId\",\n  \"defaultValue\" : \"{$Context.JobExecution__r.DataJson.fileWithSelectedChanges}\"\n}, {\n  \"required\" : true,\n  \"name\" : \"promotion\",\n  \"defaultValue\" : \"{$Context.JobExecution__r.DataJson.promotionBranchName}\"\n}, {\n  \"required\" : true,\n  \"name\" : \"targetBranch\",\n  \"defaultValue\" : \"{$Context.JobExecution__r.DataJson.destinationBranchName}\"\n}, {\n  \"required\" : true,\n  \"name\" : \"destinationInstanceUrl\",\n  \"defaultValue\" : \"{$Destination.Credential.Endpoint}\"\n}, {\n  \"required\" : true,\n  \"name\" : \"destinationSessionid\",\n  \"defaultValue\" : \"{$Destination.Credential.SessionId}\"\n}, {\n  \"required\" : true,\n  \"name\" : \"git_json\",\n  \"defaultValue\" : \"{$Context.Repository.Credential}\"\n}, {\n  \"required\" : true,\n  \"name\" : \"destinationEnv\",\n  \"defaultValue\" : \"{$Destination.apex.EnvironmentVariables}\"\n}, {\n  \"name\" : \"findAndReplaceRules\",\n  \"defaultValue\" : \"{$Context.apex.GlobalFindAndReplaceDestinationId}\"\n}, {\n  \"required\" : true,\n  \"name\" : \"isValidation\",\n  \"defaultValue\" : \"{$Context.JobExecution__r.DataJson.deploymentDryRun}\"\n}, {\n  \"name\" : \"gitName\",\n  \"defaultValue\" : \"{$User.Name}\"\n}, {\n  \"name\" : \"gitEmail\",\n  \"defaultValue\" : \"{$User.Email}\"\n}, {\n  \"name\" : \"testLevel\",\n  \"defaultValue\" : \"{$Job.ExecutionParent.Promotion__r.cmcSf__Apex_Test_Level__c}\"\n}, {\n  \"name\" : \"testOnlyClasses\",\n  \"defaultValue\" : \"{$Context.apex.cmcSf.GetTestOnlyClasses}\"\n}, {\n  \"name\" : \"debugMode\",\n  \"defaultValue\" : \"{$Job.ExecutionParent.Promotion__r.cmcSf__Debug_Mode__c}\"\n}, {\n  \"name\" : \"gitDepth\",\n  \"defaultValue\" : \"{$Pipeline.Property.gitDepth_deploy}\"\n}, {\n  \"name\" : \"validationId\",\n  \"defaultValue\" : \"{$Job.ExecutionParent.Promotion__r.cmcSf__Validate_Deploy_Request_Id__c}\"\n}, {\n  \"name\" : \"testClasses\",\n  \"defaultValue\" : \"{$Context.apex.cmcSf.GetTestClasses}\"\n}, {\n  \"name\" : \"maxBuffer\",\n  \"defaultValue\" : \"5242880\"\n}, {\n  \"name\" : \"waitTime\",\n  \"defaultValue\" : \"220\"\n}, {\n  \"name\" : \"sourceInstanceUrl\",\n  \"defaultValue\" : \"{$Source.Credential.Endpoint}\"\n}, {\n  \"name\" : \"sourceSessionid\",\n  \"defaultValue\" : \"{$Source.Credential.SessionId}\"\n}, {\n  \"name\" : \"mergeProfile\",\n  \"defaultValue\" : \"false\"\n}, {\n  \"name\" : \"overriddenApiVersion\",\n  \"defaultValue\" : \"\"\n}, {\n  \"required\" : true,\n  \"name\" : \"isProductionEnvironment\",\n  \"defaultValue\" : \"{$Context.apex.cmcSf.IdentifyProductionEnvironment}\"\n}, {\n  \"name\" : \"hasVlocityChanges\",\n  \"defaultValue\" : \"{$Context.apex.cmcSf.HasVlocityChanges}\"\n}, {\n  \"name\" : \"rollBackEnabled\",\n  \"defaultValue\" : \"{$Context.apex.cmcSf.IsRollBackEnabled}\"\n} ]",
                    "copado__Script__c": "#!/usr/bin/env node\n'use strict';\n/**\n * Performs deploy of selected user story metadata changes.\n * Returns (If ACTION success) destination branch with merged changes of the user story metadata\n * (If ACTION failed) Returns details with error status on the job execution\n * @param fileChangesId\n * @param promotion\n * @param targetBranch\n * @param destinationInstanceUrl\n * @param destinationSessionid\n * @param git_json\n * @param destinationEnv\n * @param findAndReplaceRules\n * @param isValidation\n * @param gitName\n * @param gitEmail\n * @param testLevel\n * @param testClasses\n * @param testOnlyClasses\n * @param maxBuffer\n * @param sourceSessionid\n * @param sourceInstanceUrl\n * @param waitTime\n * @param mergeProfile\n * @param hasVlocityChanges\n */\n\nconst child_process = require('child_process'),\n    fs = require('fs'),\n    { env } = require('process'),\n    {\n        destinationSessionid,\n        promotion,\n        targetBranch,\n        isValidation,\n        destinationInstanceUrl,\n        API_VERSION,\n        isTest,\n        sourceInstanceUrl,\n        gitDepth,\n        hasVlocityChanges,\n        maxBuffer,\n        destinationEnv\n    } = env,\n    TEMP_DIRECTORY = getPath('/tmp'),\n    APP_DIRECTORY = getPath('/app'),\n    TARGET_DIRECTORY = `${APP_DIRECTORY}/repository`,\n    ENCODED_CHANGES_FILE = 'encoded_changes.json',\n    ENCODED_CHANGES_WITH_SF_METADATA_VALIDITY = 'encoded_changes_with_sf_metadata_validity.json',\n    FILES_TO_INCLUDE = `${TEMP_DIRECTORY}/filesToInclude.json`,\n    ROLLBACK_JSON = `${TEMP_DIRECTORY}/CopadoRollbackChanges.json`,\n    MAXBUFFER = parseInt(maxBuffer),\n    ACTIONS = {\n        ADD: 'add',\n        RETRIEVE_ONLY: 'retrieveonly',\n        FULL: 'full',\n        DELETE: 'delete'\n    },\n    TYPES = {\n        PERMISSION_SET: 'permissionset',\n        PROFILE: 'profile'\n    },\n    STDIO = {\n        INHERIT: 'inherit',\n        PIPE: 'pipe',\n        IGNORE: 'ignore'\n    },\n    METADATA_FOR_MERGE_IN_PROFILE = [\n        'apexclass',\n        'customapplication',\n        'customobject',\n        'customfield',\n        'layout',\n        'apexpage',\n        'customtab',\n        'recordtype',\n        'systempermissions'\n    ],\n    TEST_LEVEL = {\n        RUN_SPECIFIED_TESTS: 'RunSpecifiedTests',\n        NO_TEST_RUN: 'NoTestRun'\n    },\n    CONSTANTS = {\n        COMPONENT_TYPE: 'componentType',\n        FULL_NAME: 'fullName',\n        PROBLEM: 'problem'\n    },\n    DEPLOYMENT_STATUS = {\n        CANCELED: 'Canceled'\n    },\n    ROLLBACK_ACTION = {\n        UNCHANGED: 'Unchanged',\n        DELETE: 'Delete',\n        CREATE: 'Create',\n        UPDATE: 'Update'\n    },\n    CATEGORY = { SFDX: 'sfdx' },\n    GIT_DEPTH = getGitDepth(gitDepth),\n    PACKAGE_XML = 'package.xml',\n    DESTRUCTIVE_CHANGES_XML = 'destructiveChanges.xml',\n    vlocityChangesPresent = hasVlocityChanges?.toLowerCase() === 'true';\n\nlet sourceApiVersion = isTest ? API_VERSION : '';\nlet isSfMetadataPresent;\n\n// EXECUTION\n\nasync function execute() {\n    const {\n        debugMode,\n        targetBranch,\n        validationId,\n        mergeProfile,\n        overriddenApiVersion,\n        gitEmail,\n        gitName,\n        findAndReplaceRules,\n        destinationEnv,\n        rollBackEnabled\n    } = env;\n    let debugBranch;\n    let doDeployment = true;\n    let deployResult;\n    let rollBackBranchName = getRollBackBranchName(promotion);\n    let isRollBack = isRollBackEnabled(isValidation, rollBackEnabled);\n    try {\n        this.checkChangesWrtCategory(`${APP_DIRECTORY}/${ENCODED_CHANGES_FILE}`);\n\n        sourceApiVersion = this.getApiVersion(overriddenApiVersion, API_VERSION);\n\n        this.analyzeMetadata(`${APP_DIRECTORY}/${ENCODED_CHANGES_FILE}`, `${APP_DIRECTORY}/${ENCODED_CHANGES_WITH_SF_METADATA_VALIDITY}`);\n        const changes = this.prepareChanges(`${APP_DIRECTORY}/${ENCODED_CHANGES_WITH_SF_METADATA_VALIDITY}`);\n        this.fetchPromotionBranch(promotion, GIT_DEPTH);\n        this.configureGit(gitEmail, gitName);\n        let retrieveResult = [];\n        if (isRollBack) {\n            retrieveResult = await this.executeRollBackLogic(changes, findAndReplaceRules, rollBackBranchName);\n        }\n        this.gitMergePromotionToTarget(promotion, targetBranch, GIT_DEPTH);\n        this.validateSFDXProjectJson(`${TARGET_DIRECTORY}/sfdx-project.json`);\n        this.updateSourceApiVersion(`${TARGET_DIRECTORY}/sfdx-project.json`, sourceApiVersion);\n        this.processFullProfiles(changes, mergeProfile);\n        if (debugMode === 'true') {\n            debugBranch = `copadoDebug/${promotion?.split('/')[1]}`;\n            this.createDebugPromotionBranch(debugBranch);\n        }\n        this.processMetadata(changes, `${APP_DIRECTORY}/${ENCODED_CHANGES_FILE}`);\n        if ((changes.add?.length || changes.profiles?.length)) {\n            this.varReplace(destinationEnv, null);\n        }\n        this.yamlFindAndReplace(changes, findAndReplaceRules, promotion);\n        if (debugMode === 'true') {\n            this.pushDebugPromotionBranch(debugBranch);\n        }\n\n        this.setInstanceUrl(destinationInstanceUrl);\n\n        if (isValidation === 'false' && validationId) {\n            doDeployment = !this.executeQuickDeploy(validationId, isValidation);\n        }\n        if (doDeployment) {\n            const manifest = this.createManifest(changes);\n            deployResult = this.deploy(manifest, isValidation);\n        }\n\n        //Vlocity Check --> so that push operation only happens when we do not have vlocity specific changes.\n        const pushToRemote = isValidation === 'true' || vlocityChangesPresent ? [] : [this.pushChangesToRemote(targetBranch)];\n        await Promise.all([...pushToRemote, this.cleanDeploymentFiles()]);\n\n        if (isRollBack) {\n            await Promise.all([\n                this.gitPush(rollBackBranchName),\n                this.createCopadoRollbackChangesFile(\n                    changes,\n                    deployResult,\n                    retrieveResult && retrieveResult[0]?.sfdxRetrieveResult ? retrieveResult[0].sfdxRetrieveResult : []\n                )\n            ]);\n        }\n    } catch (err) {\n        this.executeCommand(this.getErrorCmdString(err.toString()));\n        if (!isTest) {\n            process.exit(1);\n        }\n    }\n}\n\n/*\n* This function creates a RollBack branch from the target org before the actual deployment\n* We start this process by first checking out the rollback branch from target .\n* Retrieve metadata from destination org and store it in the target repo , apply Global find and replaces to the files retrieved and then commit changes to rollback branch.\n */\nasync function executeRollBackLogic(changes, findAndReplaceRules, rollBackBranchName) {\n    let filePaths = [];\n    const changesCloned = { ...changes };\n    let retrieveResult = [];\n    this.checkoutRollBackBranch(rollBackBranchName, targetBranch);\n    console.log('Changes List in Rollback :', JSON.stringify(changesCloned));\n    this.prepareMetadataChangesList(changesCloned);\n\n    if (changesCloned.hasSfdxMetadata()) {\n        retrieveResult = await Promise.all(this.retrieveOrgMetadata(changesCloned, rollBackBranchName));\n        filePaths = getFilePaths(retrieveResult);\n    }\n    if (filePaths?.length > 0 && !changesCloned.Sfdx?.hasOnlyDestructiveChanges()) {\n        fs.writeFileSync(FILES_TO_INCLUDE, JSON.stringify(filePaths));\n        if (fs.existsSync(FILES_TO_INCLUDE)) {\n            this.varReplace(destinationEnv, FILES_TO_INCLUDE);\n            this.yamlFindAndReplace(changesCloned, findAndReplaceRules, rollBackBranchName, FILES_TO_INCLUDE);\n        }\n    }\n\n    this.commitChangesInRollbackBranch(100, filePaths, rollBackBranchName);\n    return retrieveResult;\n}\n\nfunction getFilePaths(retrieveResult) {\n    let filePaths = [];\n    retrieveResult.forEach(element => {\n        if (element.sfdxRetrieveResult) {\n            element.sfdxRetrieveResult?.result?.inboundFiles\n                ?.filter(file => file.state !== 'Failed' && file.filePath !== undefined)\n                .forEach(file => {\n                    filePaths.push(file.filePath?.replace(`${TARGET_DIRECTORY}/`, ''));\n                });\n        } else if (element.sfPowerKitRetrieveResult) {\n            element.sfPowerKitRetrieveResult?.result?.filter(file => file?.path !== undefined).forEach(file => filePaths.push(file?.path));\n        }\n    });\n    return filePaths;\n}\n\nfunction createCopadoRollbackChangesFile(changeList, deploymentResult, retrieveResult) {\n    return new Promise((resolve, reject) => {\n        if (changeList && deploymentResult && deploymentResult.status === 0) {\n            const rollbackChanges = new Map();\n            changeList?.all?.forEach(element => {\n                if (!element.j || JSON.parse(element.j).isSfMetadata) {\n                    rollbackChanges.set(`${element.t?.toLowerCase()}${element.n?.toLowerCase()}`, {\n                        n: element.n,\n                        t: element.t,\n                        a: element.a?.toLowerCase() === 'retrieveonly' ? ROLLBACK_ACTION.UNCHANGED : element.a,\n                        c: element.c,\n                        r: element.a?.toLowerCase() === 'retrieveonly',\n                        s: true,\n                        f: element.a?.toLowerCase() === 'full'\n                    });\n                }\n            });\n            deploymentResult.result?.details?.componentSuccesses?.forEach(element => {\n                const metadataTypeAndName = `${element.componentType?.toLowerCase()}${element.fullName?.toLowerCase()}`;\n                const metadataInfo = rollbackChanges.get(metadataTypeAndName);\n                if (element.success && metadataInfo) {\n                    if (element.created) {\n                        metadataInfo.a = ROLLBACK_ACTION.DELETE;\n                    } else if (element.changed) {\n                        metadataInfo.a = ROLLBACK_ACTION.UPDATE;\n                    } else if (element.deleted) {\n                        metadataInfo.a = ROLLBACK_ACTION.CREATE;\n                        metadataInfo.f = metadataInfo.t?.toLowerCase() === 'profile';\n                    } else {\n                        metadataInfo.a = ROLLBACK_ACTION.UNCHANGED;\n                    }\n                }\n            });\n            retrieveResult?.result?.inboundFiles?.forEach(element => {\n                if (element.state === 'Failed' && element.error === `Entity of type '${element.type}' named '${element.fullName}' cannot be found`) {\n                    const metadataTypeAndName = `${element.type?.toLowerCase()}${element.fullName?.toLowerCase()}`;\n                    const metadataInfo = rollbackChanges.get(metadataTypeAndName);\n                    if (metadataInfo) {\n                        metadataInfo.a = ROLLBACK_ACTION.DELETE;\n                    }\n                }\n            });\n            if (rollbackChanges.size) {\n                fs.writeFileSync(ROLLBACK_JSON, JSON.stringify(Array.from(rollbackChanges.values())));\n                const command = `\n                    copado -p 'Uploading Rollback Changes File'\n                    copado --uploadfile \"${ROLLBACK_JSON}\" --name \"Copado Rollback changes\"\n                `;\n                child_process.exec(command, this.getOptions(), (error, stdout, stderr) => {\n                    if (error) {\n                        reject('Error uploading rollback changes file');\n                    } else {\n                        resolve();\n                    }\n                });\n            }\n        }\n    });\n}\n\nfunction getRollBackBranchName(promotion) {\n    return 'rollback/' + promotion.split('/')[1];\n}\n\nfunction isRollBackEnabled(isValidation, rollBackEnabled) {\n    return isValidation?.toLowerCase() !== 'true' && rollBackEnabled?.toLowerCase() === 'true';\n}\nfunction asyncCopadoLogMessage(msg) {\n    new Promise(resolve => {\n        child_process.exec(`copado -p \"${msg}\"`, { stdio: STDIO.INHERIT }, (err, response, stderr) => {\n            resolve();\n        });\n    });\n}\n\nfunction gitPush(rollBackBranchName) {\n    console.log(`Pushing all changes to ${rollBackBranchName}`);\n    const gitPush = `git push origin \"${rollBackBranchName}\"`;\n    return new Promise((resolve, reject) => {\n        child_process.exec(gitPush, this.getOptions(), (error, stdout, stderr) => {\n            this.handleResponse(error, stdout, stderr, reject);\n            resolve();\n        });\n    });\n}\nfunction commitChangesInRollbackBranch(gitDepth, filepathsList, rollBackBranchName) {\n    const resultData = {};\n    console.log('START Git Status porcelain');\n    const gitStatus = this.executeCommand(`git status --porcelain`);\n    if (!gitStatus) {\n        resultData.status = 'No Changes';\n    } else {\n        this.asyncCopadoLogMessage('Rollback branch pushed to remote');\n        this.gitCommit('Committing files to rollback branch', rollBackBranchName, filepathsList, true);\n    }\n}\n\nfunction checkoutRollBackBranch(rollBackBranch) {\n    this.asyncCopadoLogMessage('Creating rollback branch from target branch');\n    const checkoutRollbackBranch = `\n        git reset --hard || true\n        git fetch origin ${targetBranch}\n    \tgit branch -D ${rollBackBranch} || true\n        git checkout -b ${rollBackBranch} origin/${targetBranch} || ${this.getErrorCmdString(`Error checking out branch ${rollBackBranch}`)}`;\n    this.executeCommand(checkoutRollbackBranch);\n}\n\nfunction getSFChanges(committedMetadata) {\n    console.log('committedMetadata', committedMetadata);\n    return committedMetadata.filter(selection => !selection.c || selection.c?.toLowerCase() == CATEGORY.SFDX);\n}\n\nfunction uploadFile(filePath) {\n    child_process.exec(\n        `copado --uploadfile ${filePath} || ${this.getErrorCmdString('Error uploading file at filePath: ' + filePath)}`,\n        this.options(),\n        (error, stdout, stderr) => {\n            this.handleResponse(error, stdout, stderr);\n        }\n    );\n}\n\nfunction options() {\n    return {\n        shell: true,\n        maxBuffer: MAXBUFFER\n    };\n}\n\nfunction prepareMetadataChangesList(commitChanges) {\n    const sfdxChanges = this.getSFChanges(commitChanges.all);\n    commitChanges.Sfdx = {\n        otherSfdx: sfdxChanges?.filter(\n            selectedMetadata =>\n                selectedMetadata.t.toLowerCase() !== TYPES.PROFILE ||\n                (selectedMetadata.t.toLowerCase() === TYPES.PROFILE &&\n                    selectedMetadata.a.toLowerCase() !== ACTIONS.DELETE &&\n                    selectedMetadata.a.toLowerCase() !== ACTIONS.FULL)\n        ),\n        delete: sfdxChanges?.filter(selectedMetadata => selectedMetadata.a.toLowerCase() === ACTIONS.DELETE),\n        profiles: sfdxChanges?.filter(\n            selectedMetadata =>\n                selectedMetadata.t.toLowerCase() === TYPES.PROFILE &&\n                (selectedMetadata.a.toLowerCase() === ACTIONS.DELETE || selectedMetadata.a.toLowerCase() === ACTIONS.FULL)\n        ),\n        getMetadataList: operation => {\n            if (commitChanges.Sfdx[operation]) {\n                return commitChanges.Sfdx[operation].map(change => change.t + ':' + change.n).toString(',');\n            }\n        },\n        hasOnlyDestructiveChanges: () => {\n            return commitChanges?.Sfdx.delete?.length > 0 && commitChanges?.Sfdx.delete?.length === sfdxChanges.length;\n        }\n    };\n    commitChanges.hasSfdxMetadata = function () {\n        return sfdxChanges?.length > 0 ? true : false;\n    };\n}\n\nfunction retrieveOrgMetadata(commitChanges, rollBackBranchName) {\n    console.log('START Retrieving org metadata');\n    this.setup(rollBackBranchName);\n    this.asyncCopadoLogMessage('Retrieving destination org metadata');\n    const promises = [];\n\n    commitChanges?.Sfdx.otherSfdx?.length &&\n        promises.push(\n            new Promise((resolve, reject) => {\n                this.sfdxRetrieve(commitChanges, resolve, reject);\n            })\n        );\n\n    commitChanges?.Sfdx.profiles?.length &&\n        promises.push(\n            new Promise((resolve, reject) => {\n                this.retrieveFullProfile(commitChanges, resolve, reject);\n            })\n        );\n\n    return promises;\n}\n\nfunction sfdxRetrieve(commitChanges, resolve, reject) {\n    const retrieve = `\n        sfdx force:source:retrieve --json --targetusername \"${destinationSessionid}\" --metadata '${commitChanges.Sfdx.getMetadataList(\n        'otherSfdx'\n    )}' || true\n    `;\n\n    child_process.exec(retrieve, { stdio: STDIO.INHERIT, maxBuffer: MAXBUFFER }, (err, retrieveResult, stderr) => {\n        retrieveResult = JSON.parse(retrieveResult.toString());\n        if (retrieveResult.status && retrieveResult.message) {\n            console.log('Retrieve result when status 1 ', retrieveResult.status);\n        }\n        resolve({ sfdxRetrieveResult: retrieveResult });\n    });\n}\n\nfunction retrieveFullProfile(commitChanges, resolve, reject) {\n    const command = `\n        sfdx sfpowerkit:source:profile:retrieve -u \"${destinationSessionid}\" -n \"${commitChanges.Sfdx.profiles\n        .map(profile => profile.n)\n        .toString()}\" --json\n        `;\n    child_process.exec(command, { stdio: STDIO.INHERIT }, (err, response, stderr) => {\n        const profileResult = response && JSON.parse(response.toString());\n        if (err) {\n            if (profileResult && profileResult.status && profileResult.message) {\n                console.log('Error while retrieving Profile');\n            }\n        } else {\n            fs.rmSync('sfpowerkit-cache.db', {\n                force: true\n            });\n            resolve({ sfPowerKitRetrieveResult: profileResult });\n        }\n    });\n}\n\nfunction setup(rollBackBranchName) {\n    const { destinationInstanceUrl } = process.env;\n    this.checkSFDXProjectJson(rollBackBranchName, sourceApiVersion);\n    this.configureSFDXCLI(sourceApiVersion, destinationInstanceUrl);\n}\n\nfunction checkSFDXProjectJson(branchName, sourceApiVersion) {\n    console.log('step1 : checkSFDXProjectJson ');\n    const sfdxProjectJsonPath = `${TARGET_DIRECTORY}/sfdx-project.json`;\n    if (fs.existsSync(sfdxProjectJsonPath)) {\n        let fileContent = this.readFromPath(sfdxProjectJsonPath);\n        if (fileContent.sourceApiVersion !== sourceApiVersion) {\n            const commitMessage = `Updated sourceApiVersion from ${fileContent.sourceApiVersion} to ${sourceApiVersion} in sfdx-project.json to align the commit, promote and deploy operations with the latest supported api version of Copado`;\n            fileContent.sourceApiVersion = sourceApiVersion;\n            fs.writeFileSync(sfdxProjectJsonPath, JSON.stringify(fileContent, null, 2));\n            this.gitCommit(commitMessage, branchName, ['sfdx-project.json']);\n        }\n    } else {\n        throw `Invalid configuration in ${branchName}. sfdx-project.json is invalid or missing at project root. Copado Commit and Deploy operations are required to run from within a valid sfdx project.`;\n    }\n}\n\nfunction executeCommandinChunks(fileList, chunkSize, cmd) {\n    if (fileList.length > 0) {\n        let fileIndex = 0;\n        do {\n            let endIndex = fileIndex + parseInt(chunkSize) > fileList.length ? fileList.length : fileIndex + parseInt(chunkSize);\n            let fileChunk = fileList.slice(fileIndex, endIndex);\n            this.executeCommand(cmd.replace(/REPLACE_VALUE/g, fileChunk.map(file => `'${file}'`).join(' ')));\n            fileIndex = endIndex;\n        } while (fileIndex < fileList.length);\n    }\n}\n\nfunction gitCommit(commitMessage, branchName, filePaths, allowCommitWithNoChanges) {\n    console.log(`Committing ${commitMessage} in ${branchName}`);\n    this.executeCommand('rm -f .git/index.lock');\n    this.executeCommandinChunks(filePaths, 10, `git add -f REPLACE_VALUE ||  ${this.getErrorCmdString('There was some issue when staging changes')}`);\n    const gitCommit = `git commit -m \"${commitMessage}\" || ${\n        allowCommitWithNoChanges ? 'true' : this.getErrorCmdString('There was some issue when committing changes')\n    }`;\n    this.executeCommand(gitCommit, STDIO.INHERIT);\n}\n\nfunction configureSFDXCLI(sourceApiVersion, destinationInstanceUrl) {\n    const baseUrl = destinationInstanceUrl?.substring(0, destinationInstanceUrl?.indexOf('/', destinationInstanceUrl?.indexOf('/') + 2));\n    const configSet = `\n    sfdx config:set instanceUrl=${baseUrl} || ${this.getErrorCmdString('Error setting instanceUrl : ' + baseUrl)}\n    sfdx config:set apiVersion=${sourceApiVersion} || ${this.getErrorCmdString('Error setting apiVersion : ' + sourceApiVersion)}`;\n    this.executeCommand(configSet, STDIO.INHERIT);\n}\n\n// SCRIPT FUNCTIONS\n\nfunction checkChangesWrtCategory(sfdxFilePath) {\n    isSfMetadataPresent = fs.existsSync(sfdxFilePath);\n\n    if (isSfMetadataPresent) {\n        this.logger('Salesforce changes found.');\n    }\n    else {\n        this.logger('Salesforce changes not found.');\n        this.executeCommand(`copado -p 'No Salesforce Metadata'`);\n    }\n\n    if (vlocityChangesPresent) {\n        this.logger('Vlocity changes found.');\n    }\n    else {\n        this.logger('Vlocity changes not found.');\n    }\n\n    if (vlocityChangesPresent && !isSfMetadataPresent) {\n        process.exit(0);\n    }\n}\n\nfunction prepareChanges(filePath) {\n    let changes = {};\n    changes.all = this.readFromPath(filePath);\n    changes = {\n        ...changes,\n        add: changes.all.filter(\n            selectedMetadata =>\n                selectedMetadata.a.toLowerCase() == ACTIONS.ADD ||\n                (selectedMetadata.a.toLowerCase() == ACTIONS.FULL && selectedMetadata.t.toLowerCase() != TYPES.PROFILE)\n        ),\n        delete: changes.all.filter(selectedMetadata => selectedMetadata.a.toLowerCase() == ACTIONS.DELETE),\n        profiles: changes.all.filter(\n            selectedMetadata => selectedMetadata.a.toLowerCase() == ACTIONS.FULL && selectedMetadata.t.toLowerCase() == TYPES.PROFILE\n        ),\n        getSFMetadataList(type) {\n            return this[type].reduce((metadatas, metadata) => {\n                if (metadata.j) {\n                    const metadataInformation = JSON.parse(metadata.j);\n                    if (metadataInformation.isSfMetadata) {\n                        return getMetadataTypeAndName(metadatas, metadata);\n                    } else {\n                        return metadatas;\n                    }\n                } else {\n                    return getMetadataTypeAndName(metadatas, metadata);\n                }\n            }, '');\n        }\n    };\n    if (changes?.profiles?.length) {\n        changes.fullProfileList = changes?.profiles?.map(profile => profile.n).toString(',');\n    }\n    return changes;\n}\n\nfunction fetchPromotionBranch(promotion, gitDepth) {\n    console.log('START Fetching promotion branch');\n    fs.mkdirSync(TARGET_DIRECTORY, { recursive: true });\n    process.chdir(TARGET_DIRECTORY);\n\n    this.executeCommand(\n        `\n            copado --progress \"fetching ${promotion}\"\n            copado-git-get \"${promotion}\" --depth \"${gitDepth}\" || ${this.getErrorCmdString('Error fetching ' + promotion)}\n        `\n    );\n    console.log('END Fetching promotion branch');\n}\n\nfunction configureGit(gitEmail, gitName) {\n    const configureGit = `\n        git config --local user.email \"${gitEmail}\" || ${this.getErrorCmdString('Failure in configuring git user email')}\n        git config --local user.name \"${gitName}\" || ${this.getErrorCmdString('Failure in configuring git user name')}\n        git config --global diff.renames false || ${this.getErrorCmdString('Failure in disabling git rename detection from diff.renames')}\n        git config --global merge.renames false || ${this.getErrorCmdString('Failure in disabling git rename detection from merge.renames')}\n        git config --global status.renames false || ${this.getErrorCmdString('Failure in disabling git rename detection from status.renames')}\n        `;\n    this.executeCommand(`${configureGit}`);\n}\n\nfunction validateSFDXProjectJson(sfdxProjectJsonPath) {\n    if (!fs.existsSync(sfdxProjectJsonPath)) {\n        throw 'Invalid configuration. sfdx-project.json is invalid or missing at project root. Copado Commit and Deploy operations are required to run from within a valid sfdx project.';\n    }\n}\n\nfunction updateSourceApiVersion(sfdxProjectJsonPath, sourceApiVersion) {\n    let fileContent = this.readFromPath(sfdxProjectJsonPath);\n    if (fileContent.sourceApiVersion !== sourceApiVersion) {\n        const commitMessage = `Updated sourceApiVersion from ${fileContent.sourceApiVersion} to ${sourceApiVersion} in sfdx-project.json to align the commit, promote and deploy operations with the latest supported api version of Copado`;\n        fileContent.sourceApiVersion = sourceApiVersion;\n        fs.writeFileSync(sfdxProjectJsonPath, JSON.stringify(fileContent, null, 2));\n        this.commitGit(commitMessage);\n    }\n}\n\nfunction enrichChangeList(changeListPath) {\n    this.executeCommand(`\n    copado -p \"Processing metadata\"\n    enricher -p ${changeListPath} --repo ${TARGET_DIRECTORY}/ || ${this.getErrorCmdString('Error finding file paths for the changes')}`);\n}\n\nfunction processMetadata(changes, changeListPath) {\n    console.log('START Metadata processor');\n    this.executeCommand(\n        `\n    metadata-processor \"${changeListPath}\" \"${TARGET_DIRECTORY}\" -o TRIM --enrich || ${this.getErrorCmdString('Error processing metadata')}`\n    );\n\n    const parentMetadataFile = this.getParentMetadataFile(changeListPath);\n    if (fs.existsSync(parentMetadataFile)) {\n        this.addParentMetadataToOriginalChangeList(changes, this.readFromPath(parentMetadataFile));\n    }\n    console.log('END Metadata processor');\n}\n\nfunction addParentMetadataToOriginalChangeList(changes, parentMetadataList) {\n    if (parentMetadataList?.length) {\n        changes.add = changes.add.concat(parentMetadataList.filter(change => change.a.toLowerCase() == ACTIONS.ADD));\n    }\n}\n\nfunction getParentMetadataFile(filePath) {\n    const index = filePath.lastIndexOf('/');\n    const directory = filePath.substring(0, index + 1);\n\n    return directory + 'internal_' + filePath.substring(index + 1);\n}\n\nfunction varReplace(environmentVariables, filesToInclude) {\n    if (environmentVariables && JSON.parse(environmentVariables)?.length) {\n        console.log('START varReplace');\n        let command = `varreplace '${environmentVariables}' '${TARGET_DIRECTORY}' ${filesToInclude ? '--valuename=true --include='+`${filesToInclude}` : ''}`;\n        command += ` || ${this.getErrorCmdString('Error replacing environment variables')}`;\n        this.asyncCopadoLogMessage('Replacing environment variables');\n        this.executeCommand(command);\n        console.log('END varReplace');\n    }\n}\n\nfunction yamlFindAndReplace(changes, findAndReplaceRules, branch, filesToInclude) {\n    console.log('START Yaml Replace');\n    if ((changes.add?.length > 0 || changes.profiles?.length > 0) && findAndReplaceRules) {\n        this.executeCommand(\n            `\n            copado -p \"Applying global find and replace rules\"\n            copado --downloadfiles \"${findAndReplaceRules}\" --downloaddir ${TEMP_DIRECTORY}/ || ${this.getErrorCmdString(\n                'Error downloading Copado.yml file'\n            )}\n\n            # YAML Replace service called, Target Dir:  \"/tmp/Copado\", Path to YML: \"/app/repository/\"\n            yamlreplace \"${TEMP_DIRECTORY}/Copado\" \"${TARGET_DIRECTORY}\" -b \"${branch}\" ${filesToInclude ? ' --include=' + `${filesToInclude}` : ''} ||  ${this.getErrorCmdString(\n                'Error applying global find and replace rules'\n            )}\n        `\n        );\n    }\n    console.log('END Yaml Replace');\n}\n\nfunction executeSFDXDeployCmd(command) {\n    let result;\n    try {\n        result = JSON.parse(this.executeCommand(command, true));\n    } catch (error) {\n        throw `The response from the command ${command} is not a valid JSON`;\n    }\n    return result;\n}\n\n// Create SFDX Deploy command w.r.t. to flags\nfunction getSFDXDeployCmd(isDestructiveChangesPresent, isValidation) {\n    const { waitTime, testLevel, isProductionEnvironment } = env;\n    let sfdxDeployCommand = `sfdx force:source:deploy --json ${waitTime ? '--wait ' + waitTime : ''}`;\n\n    if (isValidation == 'true') {\n        sfdxDeployCommand += ' --checkonly';\n    }\n    sfdxDeployCommand += ` --targetusername ${destinationSessionid}`;\n\n    sfdxDeployCommand += this.getTestRunParam(testLevel, isProductionEnvironment);\n\n    sfdxDeployCommand +=\n        ` --manifest ${PACKAGE_XML}` + (isDestructiveChangesPresent ? ` --postdestructivechanges ${DESTRUCTIVE_CHANGES_XML} -g` : '');\n    console.log(`Deploy command: ${sfdxDeployCommand}`);\n    return `${sfdxDeployCommand} || true`;\n}\nfunction getTestRunParam(testLevel, isProductionEnvironment) {\n    let testRunParam = '';\n    if (testLevel) {\n        const testRun = testLevel?.split(' ')?.join('');\n        if (testRun && !(testRun === TEST_LEVEL.NO_TEST_RUN && isProductionEnvironment === 'true')) {\n            testRunParam += ` -l ${testRun}`;\n            if (testRun === TEST_LEVEL.RUN_SPECIFIED_TESTS) {\n                const { testOnlyClasses, testClasses } = env;\n                testRunParam += `${' -r ' + this.getDeploymentTestClasses(testOnlyClasses, testClasses)}`;\n            }\n        }\n    }\n    return testRunParam;\n}\n\nfunction getDeploymentTestClasses(testOnlyClasses, testClasses) {\n    let deploymentTestClasses = new Set();\n    if (testOnlyClasses) {\n        deploymentTestClasses = new Set([...deploymentTestClasses, ...testOnlyClasses?.split(',')]);\n    }\n    if (testClasses) {\n        deploymentTestClasses = new Set([...deploymentTestClasses, ...testClasses?.split(',')]);\n    }\n    if (!deploymentTestClasses.size) {\n        throw 'No Test Classes were selected by the User';\n    }\n    return [...deploymentTestClasses].join(',');\n}\n\nfunction uploadDeploymentResultOnJobStep(isValidation) {\n    const deployResultDir = this.getDeploymentResultFile(isValidation);\n    if (fs.existsSync(deployResultDir)) {\n        const uploadFile = `copado --uploadfile ${deployResultDir}`;\n        this.executeCommand(uploadFile);\n    } else {\n        console.log(`Could not find ${deployResultDir} `);\n    }\n}\n\nfunction createDeploymentResultFile(deployResult, isValidation) {\n    const deployResultDir = this.getDeploymentResultFile(isValidation);\n\n    fs.writeFileSync(deployResultDir, JSON.stringify(deployResult, null, 2));\n    this.uploadDeploymentResultOnJobStep(isValidation);\n}\n\nfunction getDeploymentResultFile(isValidation) {\n    return `${TEMP_DIRECTORY}/${isValidation === 'true' ? 'Validation' : 'Deployment'}Result.json`;\n}\n\nfunction handleDeployResult(deployResult, isValidation) {\n    this.createDeploymentResultFile(deployResult, isValidation);\n\n    let errorResponse = '';\n    const details = deployResult?.result?.details,\n        componentFailures = details?.componentFailures,\n        componentSuccesses = details?.componentSuccesses,\n        failures = details?.runTestResult?.failures,\n        codeCoverageWarnings = details?.runTestResult?.codeCoverageWarnings,\n        flowCoverageWarnings = details?.runTestResult?.flowCoverageWarnings;\n\n    // If any errors or warning, display to progress indicator and fail the job execution\n    if (deployResult?.status) {\n        if (deployResult?.message) {\n            errorResponse = `${deployResult?.message}`;\n        } else if (deployResult?.result?.errorMessage) {\n            errorResponse = `${deployResult?.result?.errorMessage}`;\n        } else if (deployResult?.result?.status == DEPLOYMENT_STATUS.CANCELED) {\n            errorResponse = `The ${isValidation === 'true' ? 'validation' : 'deployment'} was cancelled on the target org.`;\n        }\n    }\n    if (failures) {\n        errorResponse = this.populateErrorResponse(this.getFailedTestsErrorMessage(failures), errorResponse);\n    }\n    if (codeCoverageWarnings) {\n        errorResponse = this.populateErrorResponse(this.getFailedTestsErrorMessage(codeCoverageWarnings), errorResponse);\n    }\n    if (flowCoverageWarnings) {\n        errorResponse = this.populateErrorResponse(this.getFailedTestsErrorMessage(flowCoverageWarnings), errorResponse);\n    }\n    if (componentFailures) {\n        const errorMetadata = this.filterFailedMedataByProblemType(componentFailures, 'Error');\n        if (errorMetadata.length) {\n            errorResponse = this.populateErrorResponse(this.getFailedComponentsErrorMessage(errorMetadata), errorResponse);\n        }\n    }\n    if (componentSuccesses?.length) {\n        const warningMetadata = this.filterFailedMedataByProblemType(componentSuccesses, 'Warning');\n        if (warningMetadata?.length) {\n            const message = `WARNING deploying Metadata: ${this.getFailedComponentsErrorMessage(warningMetadata)}`;\n            this.executeCommand(`copado -p \"${message.substring(0, 254)}\"`);\n            console.log(message);\n        }\n    }\n    if (deployResult?.status) {\n        errorResponse = errorResponse ? errorResponse : 'There was some issue deploying the changes';\n        throw errorResponse.substring(0, 131072);\n    }\n\n    if (!deployResult.status && isValidation === 'true') {\n        this.populateValidationIdOnResultRecord(deployResult.result.id);\n    }\n}\n\nfunction filterFailedMedataByProblemType(failedComponents, problemType) {\n    let result = [];\n    if (Array.isArray(failedComponents)) {\n        result = failedComponents.filter(component => component.problemType == problemType);\n    } else if (failedComponents.problemType == problemType) {\n        result = [failedComponents];\n    }\n    return result;\n}\n\nfunction getFailedComponentsErrorMessage(failedComponents) {\n    let result = '';\n    if (Array.isArray(failedComponents)) {\n        result = failedComponents\n            .map(failure => failure[CONSTANTS.COMPONENT_TYPE].concat(':', failure[CONSTANTS.FULL_NAME], ':', failure[CONSTANTS.PROBLEM]))\n            .join('\\n');\n    } else {\n        result = failedComponents[CONSTANTS.COMPONENT_TYPE]\n            .concat(':', failedComponents[CONSTANTS.FULL_NAME], ':', failedComponents[CONSTANTS.PROBLEM])\n            .toString();\n    }\n    return result;\n}\n\nfunction getFailedTestsErrorMessage(failedTests) {\n    let result = '';\n    if (Array.isArray(failedTests)) {\n        let failedTestsError = failedTests.map(failedTest => {\n            let error = '';\n            error = failedTest.name ? (error ? error.concat('-', failedTest.name) : error.concat(failedTest.name)) : error;\n            error = failedTest.methodName ? (error ? error.concat('-', failedTest.methodName) : error.concat(failedTest.methodName)) : error;\n            error = error ? error.concat('-', failedTest.message) : error.concat(failedTest.message);\n            return error;\n        });\n        if (failedTestsError?.length) {\n            result = failedTestsError.join('\\n');\n        }\n    } else {\n        if (typeof failedTests.name != 'object') {\n            result = result.concat(`${failedTests.name}`);\n        }\n        result = failedTests.methodName ? (result ? result.concat('-', failedTests.methodName) : result.concat(failedTests.methodName)) : result;\n        result = result ? result.concat('-', failedTests.message) : result.concat(failedTests.message);\n    }\n    return result;\n}\n\nfunction populateErrorResponse(errorMessage, errorResponse) {\n    const delimeter = '\\n';\n    errorResponse = (errorResponse && errorResponse?.trim().concat(`${delimeter}`, errorMessage.trim())) || errorResponse.concat(errorMessage.trim());\n    return errorResponse;\n}\n\nfunction cleanDeploymentFiles() {\n    const cleanUp = `\n        git reset --hard\n        rm -rf ${PACKAGE_XML} ${DESTRUCTIVE_CHANGES_XML}\n    `;\n    return new Promise((resolve, reject) => {\n        child_process.exec(cleanUp, this.getOptions(), (error, stdout, stderr) => {\n            this.handleResponse(error, stdout, stderr, reject);\n            resolve();\n        });\n    });\n}\n\nfunction gitMergePromotionToTarget(promotion, targetBranch, gitDepth) {\n    console.log('START Merging promotion branch to target branch');\n    let checkoutTargetBranch = `\n        git reset --hard || exit 2\n        copado --progress \"checking out ${promotion} branch\"\n        ${this.fetchCheckoutBranch(targetBranch, gitDepth, false, `Error fetching branch ${targetBranch}`)}`;\n\n    this.executeCommand(checkoutTargetBranch);\n    // Add git rollBack logic here\n    try {\n        const merge = `git merge \"${promotion}\" --no-commit -Xignore-space-change`;\n        this.executeCommand(merge);\n    } catch (error) {\n        this.evaluateMergeStatus();\n        throw error;\n    }\n    this.commitGit(`Merging ${promotion} into ${targetBranch} after auto conflict resolution`);\n    console.log('END Merging promotion branch to target branch');\n}\n\nfunction commitGit(commitMessage) {\n    this.executeCommand(\n        `           \n        git add . ||  ${this.getErrorCmdString('There was some issue when staging changes')} # add all the resolved changes, if any \n        git commit -am \"${commitMessage}\" || true`\n    );\n}\n\nfunction evaluateMergeStatus() {\n    const gitStatus = this.executeCommand('git status --porcelain=v1 -uno'),\n        porcelainStatus = gitStatus.split('\\n').map(str => str.split(' ')?.[0]),\n        isConflict = porcelainStatus.length ? ['AA', 'UU', 'DD', 'UA', 'UD', 'DU', 'AU'].some(s => porcelainStatus.includes(s)) : false;\n    let infoMessage;\n\n    if (isConflict)\n        this.executeCommand(\n            this.getErrorCmdString(\n                `Changes detected in target branch '${targetBranch}' after promotion branch '${promotion}' was created, please recreate promotion branch out of the new target branch state.`\n            )\n        );\n    else if (!gitStatus) {\n        infoMessage = 'Already up to date';\n    } else {\n        infoMessage = `Changes detected in target branch '${targetBranch}' after promotion branch '${promotion}' was created.`;\n    }\n    infoMessage && this.executeCommand(`copado -p \"${infoMessage}\"`);\n    console.log(infoMessage);\n}\n\nfunction reconcileFullProfile(changes) {\n    if (changes?.profiles?.length) {\n        let reconciledProfileOutput = this.executeCommand(`\n                copado -p \"Reconciling full profile\"\n                sfdx sfpowerkit:source:profile:reconcile -u \"${destinationSessionid}\" -n \"${changes?.fullProfileList}\" --json || true\n        `);\n        if (!reconciledProfileOutput) {\n            throw 'Error reconciling full profile';\n        }\n        this.evaluateResponse(reconciledProfileOutput);\n    }\n}\n\nfunction pushChangesToRemote(remoteBranchName) {\n    const push = `git push origin \"${remoteBranchName}\" || ${this.getErrorCmdString('Could not push the changes to ' + remoteBranchName)}`;\n    return new Promise((resolve, reject) => {\n        child_process.exec(push, this.getOptions(), (error, stdout, stderr) => {\n            this.handleResponse(error, stdout, stderr, reject);\n            resolve();\n        });\n    });\n}\n\nfunction createDebugPromotionBranch(debugBranch) {\n    console.log('START Creating Debug Promotion Branch');\n    const deleteCheckoutDebugBranch = `\n    copado -p \"Creating Debug branch ${debugBranch}\"\n    git branch -D ${debugBranch} || true\n    git checkout -b ${debugBranch} || ${this.getErrorCmdString('Error checking out ' + debugBranch)}`;\n\n    this.executeCommand(deleteCheckoutDebugBranch);\n    console.log('END Creating Debug Promotion Branch');\n}\n\nfunction pushDebugPromotionBranch(debugBranch) {\n    console.log('START Pushing Debug Promotion Branch');\n    this.executeCommand(`copado -p \"Pushing changes to ${debugBranch}\"`);\n    this.commitGit(`Copado Debug Branch Commit for Promotion ${debugBranch}`);\n    this.executeCommand(`git push -f origin  \"${debugBranch}\" || ${this.getErrorCmdString('Could not push the changes to ' + debugBranch)}`);\n    console.log('END Pushing Debug Promotion Branch');\n}\n\nfunction setInstanceUrl(instanceUrl) {\n    const baseUrl = instanceUrl?.substring(0, instanceUrl?.indexOf('/', instanceUrl?.indexOf('/') + 2));\n    this.executeCommand(\n        `\n    # Set instance URL within sfdx-config.json\n    sfdx config:set instanceUrl=${baseUrl} || ${this.getErrorCmdString('Error setting instanceUrl : ' + baseUrl)}`\n    );\n}\n\nfunction getErrorCmdString(error) {\n    const suffix = 'Please check the logs for details.';\n    return `{ copado -p \"Error\" -e \"${error.trim()}; ${suffix}\"; exit 2; }`;\n}\n\nfunction populateValidationIdOnResultRecord(validationId) {\n    this.executeCommand(`copado -p \"Saving validation id\" -r '${JSON.stringify({ validationId })}' && exit 0`);\n}\n\nfunction executeQuickDeploy(validationId, isValidation) {\n    console.log('START Quick Deploy');\n    let isSuccess = false;\n    const quickDeployResult = this.executeSFDXDeployCmd(\n        `sfdx force:source:deploy --json --validateddeployrequestid ${validationId} --targetusername ${destinationSessionid} || true`,\n        true\n    );\n    this.createDeploymentResultFile(quickDeployResult, isValidation);\n    // Here we are checking whether quick deploy was successfull or not, status 0 means success and other status means failure\n    if (quickDeployResult.status) {\n        this.executeCommand(`copado -p \"${quickDeployResult.message?.substring(0, 254)}\"`);\n    } else {\n        this.executeCommand(`copado -p \"Quick Deploy done successfully\"`);\n        isSuccess = true;\n    }\n    console.log('END Quick Deploy');\n    return isSuccess;\n}\n\nfunction readFromPath(filePath) {\n    if (!fs.existsSync(filePath)) {\n        throw `Could not find file at path: ${filePath}`;\n    }\n    const data = fs.readFileSync(filePath, 'utf-8');\n    let result;\n    try {\n        result = JSON.parse(data);\n    } catch (err) {\n        throw `Content at ${filePath} is not a valid JSON`;\n    }\n    return result;\n}\n\nfunction executeCommand(cmd, disableLogs) {\n    const response = child_process.spawnSync(cmd, this.getOptions());\n    const { output, error } = this.log(response, disableLogs);\n    if (response?.status != 0) {\n        if (response?.status == 2) {\n            if (isTest) {\n                throw output;\n            }\n            process.exit(2);\n        }\n        throw error ? error : `Error executing the command ${cmd}`;\n    }\n    return output;\n}\n\nfunction processFullProfiles(changes, mergeProfile) {\n    console.log('START reconcile full profiles');\n    if (changes?.profiles?.length) {\n        this.setInstanceUrl(destinationInstanceUrl);\n        this.reconcileFullProfile(changes);\n        this.setInstanceUrl(sourceInstanceUrl);\n        if (mergeProfile === 'true') {\n            this.mergeFullProfile(changes);\n        }\n        fs.rmSync('sfpowerkit-cache.db', {\n            force: true\n        });\n        this.commitGit(`Cleaned full profile in promotion ${promotion}`);\n    }\n    console.log('END reconcile full profiles');\n}\n\nfunction mergeFullProfile(changes) {\n    const metadataList = this.findMergeableMetadataInScope(changes);\n    if (metadataList?.length) {\n        const { sourceSessionid } = env;\n        this.executeCommand(`copado -p \"Merging selected metadata permissions to the profile\"`);\n        const mergeProfile = `sfdx sfpowerkit:source:profile:merge -n \"${changes.fullProfileList}\" -u ${sourceSessionid} -m '${metadataList.join(\n            ','\n        )}' --json || true`;\n        const response = this.executeCommand(mergeProfile);\n        if (!response) {\n            throw 'Error merging permissions to full profile';\n        }\n        this.evaluateResponse(response);\n    }\n}\n\nfunction findMergeableMetadataInScope(changes) {\n    const metadataList = [];\n    changes?.add?.forEach(change => {\n        if (METADATA_FOR_MERGE_IN_PROFILE.includes(change?.t?.toLowerCase())) {\n            metadataList.push(`${change?.t}:${change?.n}`);\n        }\n    });\n    return metadataList;\n}\n\nfunction evaluateResponse(response) {\n    response = JSON.parse(response);\n    if (response?.status && response?.message) {\n        this.executeCommand(this.getErrorCmdString(`${response.commandName + ': ' + response.message}`));\n    }\n}\n\nfunction getApiVersion(overriddenApiVersion, apiVersion) {\n    const finalApiVersion = overriddenApiVersion || apiVersion;\n    const regExpApiVersion = /\\d\\d\\.0/;\n    if (!regExpApiVersion.test(finalApiVersion)) {\n        this.executeCommand(this.getErrorCmdString(`Invalid API Version: ${finalApiVersion}`));\n    }\n    return finalApiVersion;\n}\n\nfunction getPath(filePath) {\n    return isTest ? `${__dirname}/__tests__/__mockDir__${filePath}` : filePath;\n}\n\nfunction getMetadataTypeAndName(metadatas, metadata) {\n    return metadatas ? `${metadatas},${metadata.t}:${metadata.n}` : `${metadata.t}:${metadata.n}`;\n}\n\nfunction analyzeMetadata(changeListPath, outputFile) {\n    console.log('START metadata analyzer');\n    this.executeCommand(\n        `metadata-analyzer --changefile '${changeListPath}' --out '${outputFile}' || ${this.getErrorCmdString('Error analyzing metadata')}`\n    );\n    console.log('END metadata analyzer');\n}\n\nfunction createManifest(changes) {\n    const ADD_MANIFEST = changes.getSFMetadataList('add');\n    const PROFILE_MANIFEST = changes.getSFMetadataList('profiles');\n    const DELETE_MANIFEST = changes.getSFMetadataList('delete');\n    let result = { isSuccess: false, isDestructiveChangesPresent: false };\n\n    let manifest = '';\n\n    if (ADD_MANIFEST) {\n        manifest = ADD_MANIFEST;\n    }\n\n    if (PROFILE_MANIFEST) {\n        manifest = manifest ? `${manifest},${PROFILE_MANIFEST}` : PROFILE_MANIFEST;\n    }\n\n    this.buildManifest(manifest, false);\n    result.isSuccess = true;\n\n    if (DELETE_MANIFEST) {\n        this.buildManifest(DELETE_MANIFEST, true);\n        result.isSuccess = true;\n        result.isDestructiveChangesPresent = true;\n    }\n\n    return result;\n}\n\nfunction buildManifest(metadata, isDestructiveManifest) {\n    const manifestFileName = isDestructiveManifest ? `${TARGET_DIRECTORY}/${DESTRUCTIVE_CHANGES_XML}` : `${TARGET_DIRECTORY}/${PACKAGE_XML}`;\n    // Create Map\n    let metadataByType = new Map();\n    metadata.split(',').forEach(element => {\n        const metadataItem = element.split(':');\n        if (!metadataByType.has(metadataItem[0])) {\n            metadataByType.set(metadataItem[0], []);\n        }\n        metadataByType.get(metadataItem[0]).push(metadataItem[1]);\n    });\n\n    // Create manifest file\n    let manifest = [];\n    manifest.push('<?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"yes\" ?>\\n');\n    manifest.push('<Package xmlns=\"http://soap.sforce.com/2006/04/metadata\">\\n');\n    metadataByType.forEach((value, key) => {\n        if (value && key) {\n            manifest.push('\\t<types>\\n');\n            value.forEach(item => {\n                manifest.push(`\\t\\t<members>${item}</members>\\n`);\n            });\n\n            manifest.push(`\\t\\t<name>${key}</name>\\n`);\n            manifest.push('\\t</types>\\n');\n        }\n    });\n\n    manifest.push(`\\t<version>${sourceApiVersion}</version>\\n`);\n    manifest.push('</Package>\\n');\n\n    fs.writeFileSync(manifestFileName, manifest.join(''));\n}\n\nfunction deploy(manifest, isValidation) {\n    console.log('START Deploy');\n    let deployResult;\n    if (manifest.isSuccess) {\n        this.asyncCopadoLogMessage('Deploying promotion changes');\n        deployResult = this.executeSFDXDeployCmd(`${this.getSFDXDeployCmd(manifest.isDestructiveChangesPresent, isValidation)}`);\n        this.handleDeployResult(deployResult, isValidation);\n    }\n    console.log('END Deploy');\n    return deployResult;\n}\n\nfunction getGitDepth(gitDepth) {\n    gitDepth = parseInt(gitDepth);\n    return gitDepth >= 0 ? gitDepth : 100;\n}\n\nfunction fetchCheckoutBranch(branch, gitDepth, forceCreate, error) {\n    return (\n        `( git fetch origin ${branch} --depth ${gitDepth} && git checkout ${branch} )` +\n        (forceCreate ? ` || git checkout -b ${branch}` : '') +\n        ` || ${getErrorCmdString(error)}`\n    );\n}\n\nfunction handleResponse(error, stdout, stderr, reject) {\n    if (stdout) {\n        console.log(stdout);\n    }\n    if (stderr) {\n        console.log(stderr);\n    }\n    if (error) {\n        if (reject) {\n            reject(stderr?.toString());\n        }\n        if (error.code == 2) {\n            process.exit(2);\n        } else {\n            throw error;\n        }\n    }\n}\n\nfunction getOptions() {\n    const { maxBuffer } = env;\n    const options = {\n        shell: true,\n        maxBuffer: parseInt(maxBuffer)\n    };\n    return options;\n}\n\nfunction logger(text) {\n    console.log(text);\n}\n\nfunction log(response, disableLogs) {\n    const output = response?.stdout?.toString().trim();\n    const error = response?.stderr?.toString().trim();\n    if (!disableLogs) {\n        if (output) {\n            console.log(output);\n        }\n        if (error) {\n            console.log(error);\n        }\n    }\n    return { output, error };\n}\n\nmodule.exports.prepareChanges = prepareChanges;\nmodule.exports.fetchPromotionBranch = fetchPromotionBranch;\nmodule.exports.configureGit = configureGit;\nmodule.exports.updateSourceApiVersion = updateSourceApiVersion;\nmodule.exports.validateSFDXProjectJson = validateSFDXProjectJson;\nmodule.exports.enrichChangeList = enrichChangeList;\nmodule.exports.processMetadata = processMetadata;\nmodule.exports.getParentMetadataFile = getParentMetadataFile;\nmodule.exports.addParentMetadataToOriginalChangeList = addParentMetadataToOriginalChangeList;\nmodule.exports.varReplace = varReplace;\nmodule.exports.yamlFindAndReplace = yamlFindAndReplace;\nmodule.exports.executeSFDXDeployCmd = executeSFDXDeployCmd;\nmodule.exports.getSFDXDeployCmd = getSFDXDeployCmd;\nmodule.exports.getTestRunParam = getTestRunParam;\nmodule.exports.getDeploymentTestClasses = getDeploymentTestClasses;\nmodule.exports.uploadDeploymentResultOnJobStep = uploadDeploymentResultOnJobStep;\nmodule.exports.handleDeployResult = handleDeployResult;\nmodule.exports.filterFailedMedataByProblemType = filterFailedMedataByProblemType;\nmodule.exports.getFailedTestsErrorMessage = getFailedTestsErrorMessage;\nmodule.exports.getFailedComponentsErrorMessage = getFailedComponentsErrorMessage;\nmodule.exports.populateErrorResponse = populateErrorResponse;\nmodule.exports.cleanDeploymentFiles = cleanDeploymentFiles;\nmodule.exports.gitMergePromotionToTarget = gitMergePromotionToTarget;\nmodule.exports.commitGit = commitGit;\nmodule.exports.evaluateMergeStatus = evaluateMergeStatus;\nmodule.exports.reconcileFullProfile = reconcileFullProfile;\nmodule.exports.pushChangesToRemote = pushChangesToRemote;\nmodule.exports.createDebugPromotionBranch = createDebugPromotionBranch;\nmodule.exports.pushDebugPromotionBranch = pushDebugPromotionBranch;\nmodule.exports.setInstanceUrl = setInstanceUrl;\nmodule.exports.getErrorCmdString = getErrorCmdString;\nmodule.exports.populateValidationIdOnResultRecord = populateValidationIdOnResultRecord;\nmodule.exports.executeQuickDeploy = executeQuickDeploy;\nmodule.exports.readFromPath = readFromPath;\nmodule.exports.executeCommand = executeCommand;\nmodule.exports.processFullProfiles = processFullProfiles;\nmodule.exports.mergeFullProfile = mergeFullProfile;\nmodule.exports.findMergeableMetadataInScope = findMergeableMetadataInScope;\nmodule.exports.evaluateResponse = evaluateResponse;\nmodule.exports.getApiVersion = getApiVersion;\nmodule.exports.execute = execute;\nmodule.exports.analyzeMetadata = analyzeMetadata;\nmodule.exports.createManifest = createManifest;\nmodule.exports.buildManifest = buildManifest;\nmodule.exports.deploy = deploy;\nmodule.exports.fetchCheckoutBranch = fetchCheckoutBranch;\nmodule.exports.getGitDepth = getGitDepth;\nmodule.exports.handleResponse = handleResponse;\nmodule.exports.getOptions = getOptions;\nmodule.exports.createDeploymentResultFile = createDeploymentResultFile;\nmodule.exports.getDeploymentResultFile = getDeploymentResultFile;\nmodule.exports.handleResponse = handleResponse;\nmodule.exports.createDeploymentResultFile = createDeploymentResultFile;\nmodule.exports.getDeploymentResultFile = getDeploymentResultFile;\nmodule.exports.checkChangesWrtCategory = checkChangesWrtCategory;\nmodule.exports.log = log;\nmodule.exports.logger = logger;\nmodule.exports.sfdxRetrieve = sfdxRetrieve;\nmodule.exports.prepareMetadataChangesList = prepareMetadataChangesList;\nmodule.exports.checkoutRollBackBranch = checkoutRollBackBranch;\nmodule.exports.getSFChanges = getSFChanges;\nmodule.exports.retrieveOrgMetadata = retrieveOrgMetadata;\nmodule.exports.retrieveFullProfile = retrieveFullProfile;\nmodule.exports.executeRollBackLogic = executeRollBackLogic;\nmodule.exports.setup = setup;\nmodule.exports.checkSFDXProjectJson = checkSFDXProjectJson;\nmodule.exports.configureSFDXCLI = configureSFDXCLI;\nmodule.exports.gitCommit = gitCommit;\nmodule.exports.uploadFile = uploadFile;\nmodule.exports.options = options;\nmodule.exports.gitPush = gitPush;\nmodule.exports.commitChangesInRollbackBranch = commitChangesInRollbackBranch;\nmodule.exports.executeCommandinChunks = executeCommandinChunks;\nmodule.exports.readFromPath = readFromPath;\nmodule.exports.createCopadoRollbackChangesFile = createCopadoRollbackChangesFile;\nmodule.exports.asyncCopadoLogMessage = asyncCopadoLogMessage;\nmodule.exports.getRollBackBranchName = getRollBackBranchName;\nmodule.exports.isRollBackEnabled = isRollBackEnabled;\n!isTest && this.execute();",
                    "copado__Timeout__c": 120,
                    "copado__Type__c": "Standard",
                    "copado__Worker_Size__c": "M",
                    "Id": "a0l7Q000000MDYvQAO",
                    "LastReferencedDate": "2023-03-28T06:37:33.000+0000",
                    "LastViewedDate": "2023-03-28T06:37:33.000+0000",
                    "Name": "Deploy"
                },
                {
                    "attributes": {
                        "type": "copado__Function__c",
                      "url": "/services/data/v58.0/sobjects/copado__Function__c/a0l7Q000000iAiLQAU"
                    },
                    "copado__API_Name__c": "sfdx_commit",
                    "copado__Description__c": "Performs git commit on user stories",
                    "copado__Image_Name__c": "copado-multicloud-dx:v3",
                    "copado__Options__c": "[ ]",
                    "copado__Parameters__c": "[ {\n  \"required\" : true,\n  \"name\" : \"fileChangesId\",\n  \"defaultValue\" : \"{$Context.JobExecution__r.DataJson.fileWithSelectedChanges}\"\n}, {\n  \"required\" : true,\n  \"name\" : \"fileName\",\n  \"defaultValue\" : \"Copado Commit changes\"\n}, {\n  \"required\" : true,\n  \"name\" : \"sourceSessionId\",\n  \"defaultValue\" : \"{$Source.Credential.SessionId}\"\n}, {\n  \"required\" : true,\n  \"name\" : \"sourceEndPoint\",\n  \"defaultValue\" : \"{$Source.Credential.Endpoint}\"\n}, {\n  \"name\" : \"namespace\",\n  \"defaultValue\" : \"\"\n}, {\n  \"required\" : true,\n  \"name\" : \"git_json\",\n  \"defaultValue\" : \"{$Context.Repository.Credential}\"\n}, {\n  \"required\" : true,\n  \"name\" : \"baseBranch\",\n  \"defaultValue\" : \"{$Context.JobExecution__r.DataJson.baseBranch}\"\n}, {\n  \"required\" : true,\n  \"name\" : \"sourceEnv\",\n  \"defaultValue\" : \"{$Source.apex.EnvironmentVariables}\"\n}, {\n  \"required\" : false,\n  \"name\" : \"findAndReplaceFileId\",\n  \"defaultValue\" : \"{$Context.apex.GlobalFindAndReplaceSourceId}\"\n}, {\n  \"required\" : true,\n  \"name\" : \"featureBranch\",\n  \"defaultValue\" : \"{$Context.JobExecution__r.DataJson.featureBranchName}\"\n}, {\n  \"required\" : true,\n  \"name\" : \"recreateIfExists\",\n  \"defaultValue\" : \"{$Context.JobExecution__r.DataJson.recreateFeatureBranch}\"\n}, {\n  \"required\" : true,\n  \"name\" : \"commitMessage\",\n  \"defaultValue\" : \"{$Context.JobExecution__r.DataJson.message}\"\n}, {\n  \"required\" : true,\n  \"name\" : \"gitEmail\",\n  \"defaultValue\" : \"{$User.Email}\"\n}, {\n  \"required\" : true,\n  \"name\" : \"gitName\",\n  \"defaultValue\" : \"{$User.Name}\"\n}, {\n  \"required\" : true,\n  \"name\" : \"sourceEnvironmentBranch\",\n  \"defaultValue\" : \"{$Context.apex.SourceEnvironmentBranch}\"\n}, {\n  \"name\" : \"gitDepth\",\n  \"defaultValue\" : \"{$Pipeline.Property.gitDepth_commit}\"\n}, {\n  \"name\" : \"timeout\",\n  \"defaultValue\" : \"180000\"\n}, {\n  \"name\" : \"chunkSize\",\n  \"defaultValue\" : \"10\"\n}, {\n  \"name\" : \"maxBuffer\",\n  \"defaultValue\" : \"5242880\"\n}, {\n  \"name\" : \"overriddenApiVersion\",\n  \"defaultValue\" : \"\"\n}, {\n  \"name\" : \"commitId\",\n  \"defaultValue\" : \"{$Context.JobExecution__r.DataJson.commitId}\"\n}, {\n  \"name\" : \"vlocityFilesPath\",\n  \"defaultValue\" : \"/app/vlocity/\"\n}, {\n  \"name\" : \"disableEarlyCommitCompletion\",\n  \"defaultValue\" : \"{$Pipeline.Property.disableEarlyCommitCompletion}\"\n} ]",
                    "copado__Script__c": "#!/usr/bin/env node\n'use strict';\n\n/**\n * Performs commit of selected user story metadata changes.\n * Returns (If ACTION success) new feature branch in user repo with all the changes and returns the commit id in the result record\n * (If ACTION failed) Returns details with error status on user story commit record\n * @param fileChangesId\n * @param fileName\n * @param sourceSessionId\n * @param sourceEndPoint\n * @param git_json\n * @param baseBranch\n * @param sourceEnv\n * @param findAndReplaceFileId\n * @param featureBranch\n * @param recreateIfExists\n * @param commitMessage\n * @param gitEmail\n * @param gitName\n * @param sourceEnvironmentBranch\n * @param maxBuffer\n * @param gitDepth\n * @param timeout\n * @param chunkSize\n * @param overriddenApiVersion\n * @param commitId\n */\n\nconst child_process = require('child_process'),\n    fs = require('fs'),\n    https = require('https'),\n    { featureBranch, sourceSessionId, maxBuffer, isTest, gitDepth, findAndReplaceFileId, sourceEnv, API_VERSION, commitId, vlocityFilesPath, chunkSize, disableEarlyCommitCompletion } = process.env,\n    TEMP_DIRECTORY = getPath('/tmp'),\n    APP_DIRECTORY = getPath('/app'),\n    TARGET_DIRECTORY = `${APP_DIRECTORY}/repository`,\n    COMMIT_CHANGES_FILE_PATH = `${APP_DIRECTORY}/encoded_changes.json`,\n    RETRIEVE_RESULT_PATH = `${TEMP_DIRECTORY}/retrieveResult.json`,\n    FULL_PROFILE_RETRIEVE_RESULT_PATH = `${TEMP_DIRECTORY}/fullProfileResult.json`,\n    FILES_TO_INCLUDE = `${TEMP_DIRECTORY}/filesToInclude.json`,\n    ACTIONS = {\n        ADD: 'add',\n        RETRIEVE_ONLY: 'retrieveonly',\n        FULL: 'full',\n        DELETE: 'delete'\n    },\n    TYPES = {\n        PERMISSION_SET: 'permissionset',\n        PROFILE: 'profile',\n        CUSTOM_OBJECT: 'customobject'\n    },\n    STDIO = {\n        INHERIT: 'inherit',\n        PIPE: 'pipe',\n        IGNORE: 'ignore'\n    },\n    PARENT_NESTED_METADATA = ['customlabels', 'workflow', 'sharingrules', 'escalationrules', 'matchingrules', 'autoresponserules', 'assignmentrules'],\n    MAXBUFFER = parseInt(maxBuffer),\n    COPADO_YML = 'Copado',\n    COMMIT_OPERATION = 'Commit Operation',\n    GIT_DEPTH = getGitDepth(gitDepth),\n    PORCELAIN_STATUS = {\n        ADDED: 'A',\n        DELETED: 'D',\n        UNMERGED: 'U'\n    },\n    GIT_STATUS_FILE_PATH = `${TEMP_DIRECTORY}/git_status.txt`,\n    CATEGORY = {\n        VLOCITY: 'vlocity',\n        SFDX: 'sfdx'\n    };\n\nlet commitChanges = {},\n    sourceApiVersion = isTest ? API_VERSION : '',\n    filesInScope = [];\n\n// SCRIPT FUNCTIONS\n\nasync function execute(commitChanges) {\n    try {\n        console.time(COMMIT_OPERATION);\n        this.validateCommitId(commitId);\n        await Promise.all(this.initialSetup(commitChanges));\n\n        if (fs.existsSync(vlocityFilesPath)) {\n            this.copyFiles(vlocityFilesPath, TARGET_DIRECTORY);\n        }\n        if (commitChanges.hasSfdxMetadata() && !commitChanges.Sfdx?.hasOnlyDestructiveChanges()) {\n            await Promise.all(this.retrieveOrgMetadata(commitChanges));\n        }\n        this.enrichChangeList(COMMIT_CHANGES_FILE_PATH, RETRIEVE_RESULT_PATH, 'COMMIT');\n        this.uploadFile(COMMIT_CHANGES_FILE_PATH, 'EnrichedChanges.json');\n        filesInScope.push(...this.getFilesInScope());\n\n        if (filesInScope && !commitChanges.Sfdx?.hasOnlyDestructiveChanges()) {\n            this.varReplace(sourceEnv);\n            this.findAndReplace(findAndReplaceFileId, featureBranch);\n        }\n        if (commitChanges.hasSfdxMetadata()) {\n            this.processMetadata();\n            this.discardRetrieveOnlyFiles(commitChanges);\n        }\n        this.commitAndUpdateEnvironmentBranches(GIT_DEPTH, disableEarlyCommitCompletion);\n        console.timeEnd(COMMIT_OPERATION);\n\n    } catch (err) {\n        console.log(err);\n        this.executeCommand(this.getErrorCmdString(err.toString()));\n        if (!isTest) {\n            process.exit(1);\n        }\n    }\n}\n\n// SCRIPT FUNCTIONS\n\nfunction encodeFileNames(committedMetadata, filePath) {\n    this.validateCommittedChanges(committedMetadata);\n\n    for (let commitChange of committedMetadata) {\n        if (!commitChange.c) {\n            commitChange.c = CATEGORY.SFDX;\n        }\n        if (commitChange.c?.toLowerCase() == CATEGORY.SFDX) {\n            switch (commitChange.t) {\n                case 'DashboardFolder':\n                case 'ReportFolder':\n                case 'Document':\n                    commitChange.n = commitChange.n.replace(/%2F/gi, '/');\n                    break;\n\n                case 'EmailTemplate':\n                    commitChange.n = commitChange.n.replace(/%24/gi, '$').replace(/%2F/gi, '/');\n                    break;\n\n                case 'Layout':\n                    const regExp = '(?:([a-zA-Z_][a-zA-Z0-9_]{0,14}?(?!__c-))__)?([^-]+)-(?:([a-zA-Z_][a-zA-Z0-9_]{0,14}?_?(?!__c$))__)?(.+)\\n?';\n                    /*\n                        The above regExp divides the layout full name into 4 groups:\n                        1. customobject namespace\n                        2. customobject name\n                        3. layout namespace\n                        4. layout mame\n                        The match function returns these groups respectively in the indices 1,2,3,4\n                    */\n                    const layoutFullName = commitChange.n.match(regExp);\n                    let layoutName = layoutFullName[4].replace(/_{2}(?!c)/g, match => {\n                        return match.replace(/_/gi, '%5F');\n                    });\n                    layoutName = layoutName.replace(/\\./, '%2E');\n                    commitChange.n = `${layoutFullName[1] ? layoutFullName[1] + '__' : ''}${layoutFullName[2]}-${layoutFullName[3] ? layoutFullName[3] + '__' : ''\n                        }${layoutName}`;\n                    break;\n            }\n        } else if (commitChange.c?.toLowerCase() == CATEGORY.VLOCITY) {\n            const datapackKey = JSON.parse(commitChange.j)?.vk?.split('/');\n            commitChange.n = datapackKey[1]\n                ?.replace('\\\\', '-')\n                .replace(/[^A-Za-z0-9/_\\-]+/g, '-')\n                .replace(/[-]+/g, '-')\n                .replace(/[-_]+_/g, '_')\n                .replace(/[-]+\\/[-]+/g, '/')\n                .replace(/^[-_\\\\/]+/, '')\n                .replace(/[-_\\\\/]+$/, '');\n        }\n    }\n    fs.writeFileSync(filePath, JSON.stringify(committedMetadata, null, 2));\n}\n\nfunction getSFChanges(committedMetadata) {\n    return committedMetadata.filter(selection => (!selection.c || selection.c?.toLowerCase() == CATEGORY.SFDX));\n}\n\nfunction getCommitChanges(dir, fileName) {\n    let downloadedFileName;\n    if (fs.existsSync(`${dir}/${fileName}`)) {\n        downloadedFileName = fileName;\n    } else if (fs.existsSync(`${dir}/${fileName}.json`)) {\n        downloadedFileName = `${fileName}.json`;\n    } else {\n        throw 'Error fetching Commit Changes';\n    }\n    return this.readFromPath(`${dir}/${downloadedFileName}`);\n}\n\nfunction validateCommittedChanges(committedMetadata) {\n    const isValid =\n        Array.isArray(committedMetadata) &&\n        committedMetadata?.length &&\n        committedMetadata?.filter((change) => !change.n || !change.t || !change.a)?.length == 0;\n    if (!isValid) {\n        throw `The Commit Changes do not follow the Commit Action Contract`;\n    }\n}\n\nfunction prepareMetadataChangesList(filePath, commitChanges) {\n    const allChanges = this.readFromPath(filePath);\n    const sfdxChanges = this.getSFChanges(allChanges);\n    \n    commitChanges.Sfdx = {\n        addOrRetrieve: sfdxChanges.filter(\n            (selectedMetadata) =>\n                selectedMetadata.a.toLowerCase() == ACTIONS.RETRIEVE_ONLY ||\n                selectedMetadata.a.toLowerCase() == ACTIONS.ADD ||\n                (selectedMetadata.a.toLowerCase() == ACTIONS.FULL && selectedMetadata.t.toLowerCase() != TYPES.PROFILE)\n        ),\n        delete: sfdxChanges.filter((selectedMetadata) => selectedMetadata.a.toLowerCase() == ACTIONS.DELETE),\n        profiles: sfdxChanges.filter(\n            (selectedMetadata) => selectedMetadata.a.toLowerCase() == ACTIONS.FULL && selectedMetadata.t.toLowerCase() == TYPES.PROFILE\n        ),\n        retrieveOnly: sfdxChanges.filter((selectedMetadata) => selectedMetadata.a.toLowerCase() == ACTIONS.RETRIEVE_ONLY),\n        getMetadataList: (operation) => {\n            if (commitChanges.Sfdx[operation]) {\n                return commitChanges.Sfdx[operation].map((change) => change.t + ':' + change.n).toString(',');\n            }\n        },\n        hasOnlyDestructiveChanges: () => {\n            return commitChanges?.Sfdx.delete?.length > 0 && (commitChanges?.Sfdx.delete?.length === sfdxChanges.length);\n        }\n    };\n\n    commitChanges.hasSfdxMetadata = function () {\n        return sfdxChanges?.length > 0 ? true : false;\n    }\n}\n\nfunction checkNestedParentMetadataDeletion(commitChanges) {\n    const notToDeleteMetadataTypes = new Set();\n    if (commitChanges?.Sfdx?.delete?.length) {\n        commitChanges.Sfdx.delete.filter((change) => {\n            if (PARENT_NESTED_METADATA?.includes(change.t.toLowerCase())) {\n                notToDeleteMetadataTypes.add(change.t);\n            }\n        });\n        if (notToDeleteMetadataTypes.size) {\n            throw `${[...notToDeleteMetadataTypes].join(\n                ','\n            )} cannot be selected for a destructive commit. Try re-committing after removing these metadata`;\n        }\n    }\n}\nfunction setup() {\n    const { sourceEndPoint } = process.env;\n    this.checkSFDXProjectJson(featureBranch, sourceApiVersion);\n    this.configureSFDXCLI(sourceApiVersion, sourceEndPoint);\n}\n\nfunction checkSFDXProjectJson(branchName, sourceApiVersion) {\n    const sfdxProjectJsonPath = `${TARGET_DIRECTORY}/sfdx-project.json`;\n    if (fs.existsSync(sfdxProjectJsonPath)) {\n        let fileContent = this.readFromPath(sfdxProjectJsonPath);\n        if (fileContent.sourceApiVersion !== sourceApiVersion) {\n            const commitMessage = `Updated sourceApiVersion from ${fileContent.sourceApiVersion} to ${sourceApiVersion} in sfdx-project.json to align the commit, promote and deploy operations with the latest supported api version of Copado`;\n            fileContent.sourceApiVersion = sourceApiVersion;\n            fs.writeFileSync(sfdxProjectJsonPath, JSON.stringify(fileContent, null, 2));\n            this.gitCommit(commitMessage, branchName, ['sfdx-project.json']);\n        }\n    } else {\n        throw `Invalid configuration in ${branchName}. sfdx-project.json is invalid or missing at project root. Copado Commit and Deploy operations are required to run from within a valid sfdx project.`;\n    }\n}\n\nfunction configureSFDXCLI(sourceApiVersion, sourceEndPoint) {\n    const baseUrl = sourceEndPoint?.substring(0, sourceEndPoint?.indexOf('/', sourceEndPoint?.indexOf('/') + 2));\n\n    const configSet = `\n    sfdx config:set instanceUrl=${baseUrl} || ${this.getErrorCmdString('Error setting instanceUrl : ' + baseUrl)}\n    sfdx config:set apiVersion=${sourceApiVersion} || ${this.getErrorCmdString('Error setting apiVersion : ' + sourceApiVersion)}`;\n    this.executeCommand(configSet);\n}\n\nfunction sfdxRetrieve(commitChanges, resolve, reject) {\n    console.log('START Retrieving metadata');\n    const retrieve = `\n        sfdx force:source:retrieve --json -u \"${sourceSessionId}\" -m '${commitChanges.Sfdx.getMetadataList('addOrRetrieve')}' || true\n    `;\n\n    child_process.exec(retrieve, { stdio: STDIO.INHERIT, maxBuffer: MAXBUFFER }, (err, retrieveResult, stderr) => {\n        console.log('END Retrieving metadata')\n\n        retrieveResult = JSON.parse(retrieveResult.toString());\n\n        fs.writeFileSync(RETRIEVE_RESULT_PATH, JSON.stringify(retrieveResult));\n        this.uploadFile(RETRIEVE_RESULT_PATH);\n\n        if (retrieveResult.status && retrieveResult.message) {\n            reject(retrieveResult.message);\n            return;\n        }\n\n        const failedMetadataList = retrieveResult?.result?.inboundFiles?.filter((file) => file.state === 'Failed');\n\n        if (failedMetadataList?.length) {\n            const err = failedMetadataList.map((metadata) => metadata.error).toString();\n            reject(err);\n            return;\n        }\n        resolve(retrieveResult);\n    });\n}\n\nfunction retrieveFullProfile(commitChanges, resolve, reject) {\n    console.log('START Retrieving Full Profile');\n    const retrieveFullProfile = `\n        sfdx sfpowerkit:source:profile:retrieve -u \"${sourceSessionId}\" -n \"${commitChanges.Sfdx.profiles\n            .map((profile) => profile.n)\n            .toString()}\" --json\n        `;\n    child_process.exec(retrieveFullProfile, { stdio: STDIO.INHERIT }, (err, response, stderr) => {\n        console.log('END Retrieving Full Profile');\n        const profileResult = response && JSON.parse(response.toString());\n        if (err) {\n            if (profileResult && profileResult.status && profileResult.message) {\n                reject(profileResult.message);\n                return;\n            }\n            reject('Full Profile Retrieval Failed');\n        } else {\n            fs.writeFileSync(FULL_PROFILE_RETRIEVE_RESULT_PATH, JSON.stringify(profileResult));\n            console.log(profileResult);\n            this.updateCommitChangeFileWithProfilePaths(profileResult);\n            fs.rmSync('sfpowerkit-cache.db', {\n                force: true\n            });\n            resolve();\n        }\n    });\n}\n\nfunction updateCommitChangeFileWithProfilePaths(profileResult) {\n    let changes = this.readFromPath(COMMIT_CHANGES_FILE_PATH);\n    changes.forEach(change => {\n        if (change.a.toLowerCase() == ACTIONS.FULL && change.t?.toLowerCase() == TYPES.PROFILE) {\n            const matchedProfile = profileResult?.result.find(profile => profile.fullName == change.n && profile.state !== 'Skipped');\n            if (matchedProfile) {\n                change.j = JSON.stringify({\n                    filePath: [matchedProfile.path]\n                })\n                filesInScope.push(matchedProfile.path);\n            }\n        }\n    });\n    fs.writeFileSync(COMMIT_CHANGES_FILE_PATH, JSON.stringify(changes));\n}\nfunction retrieveOrgMetadata(commitChanges) {\n    this.setup();\n    this.asyncCopadoLogMessage('Retrieving the selected metadata');\n    const promises = [];\n    commitChanges?.Sfdx.profiles?.length &&\n        promises.push(\n            new Promise((resolve, reject) => {\n                this.retrieveFullProfile(commitChanges, resolve, reject);\n            })\n        );\n    commitChanges?.Sfdx.addOrRetrieve?.length &&\n        promises.push(\n            new Promise((resolve, reject) => {\n                this.sfdxRetrieve(commitChanges, resolve, reject);\n            })\n        );\n    return promises;\n}\n\nfunction varReplace(sourceEnv) {\n    console.log('START Var Replace');\n    if (fs.existsSync(FILES_TO_INCLUDE) && sourceEnv && JSON.parse(sourceEnv)?.length) {\n        this.asyncCopadoLogMessage('Replacing environment variables, if any');\n        const varreplace = `\n            varreplace '${sourceEnv}' '${TARGET_DIRECTORY}' --valuename=true --include=${FILES_TO_INCLUDE} || ${this.getErrorCmdString(\n            'Error replacing environment variables'\n        )}`;\n        this.executeCommand(varreplace);\n    }\n    console.log('END Var Replace');\n}\n\nfunction getFilesInScope() {\n    console.log('START Get files in scope');\n    if (fs.existsSync(RETRIEVE_RESULT_PATH)) {\n        const retrieveResult = this.readFromPath(RETRIEVE_RESULT_PATH);\n        filesInScope.push(...retrieveResult?.result?.inboundFiles?.map((file) => file.filePath.substring(TARGET_DIRECTORY.length + 1)));\n    }\n\n    filesInScope.push(...this.getFilePaths(COMMIT_CHANGES_FILE_PATH, [ACTIONS.ADD], [CATEGORY.VLOCITY]));\n\n    if (filesInScope?.length) {\n        fs.writeFileSync(FILES_TO_INCLUDE, JSON.stringify(filesInScope));\n    }\n\n    console.log('END Get files in scope');\n    return filesInScope;\n\n}\n\nfunction createTargetDirectoryAndFetchBaseBranch(baseBranch, gitDepth) {\n    console.log('START Creating target directory and fetching base branch');\n    if (!baseBranch) {\n        throw 'No base branch provided';\n    }\n    return `\n    mkdir -p ${TARGET_DIRECTORY}\n    cd ${TARGET_DIRECTORY}\n    copado-git-get --depth \"${gitDepth}\" \"${baseBranch}\" || ${this.getErrorCmdString('Error fetching ' + baseBranch)}`;\n}\n\nfunction options() {\n    return {\n        shell: true,\n        maxBuffer: MAXBUFFER\n    };\n}\n\nfunction initialSetup(commitChanges) {\n    console.log('START Initial setup');\n    const promises = [];\n    const { gitEmail, gitName, recreateIfExists, fileChangesId, overriddenApiVersion, API_VERSION, fileName, baseBranch } = process.env;\n    promises.push(\n        new Promise((resolve, reject) => {\n            child_process.exec(this.createTargetDirectoryAndFetchBaseBranch(baseBranch, GIT_DEPTH), this.options(), (error, stdout, stderr) => {\n                console.log('END Creating target directory and fetching base branch');\n                this.handleResponse(error, stdout, stderr, reject);\n                try {\n                    this.changeWorkingDirectory(TARGET_DIRECTORY);\n                    this.configureGit(gitEmail, gitName);\n                    this.fetchCreateFeatureBranch(recreateIfExists, featureBranch, GIT_DEPTH);\n                    resolve();\n                } catch (err) {\n                    reject(err);\n                }\n            });\n        })\n    );\n\n    promises.push(\n        new Promise((resolve, reject) => {\n            child_process.exec(this.downloadFile(fileChangesId, TEMP_DIRECTORY, 'Commit Changes'), this.options(), (error, stdout, stderr) => {\n                this.handleResponse(error, stdout, stderr, reject);\n                try {\n                    sourceApiVersion = this.getApiVersion(overriddenApiVersion, API_VERSION);\n                    const committedMetadata = this.getCommitChanges(TEMP_DIRECTORY, fileName);\n                    this.encodeFileNames(committedMetadata, COMMIT_CHANGES_FILE_PATH);\n                    this.prepareMetadataChangesList(COMMIT_CHANGES_FILE_PATH, commitChanges);\n                    this.checkNestedParentMetadataDeletion(commitChanges);\n                    resolve();\n                } catch (err) {\n                    reject(err);\n                }\n            });\n        })\n    );\n    console.log('END Initial setup');\n    return promises;\n}\n\nfunction handleResponse(error, stdout, stderr, reject) {\n    if (stdout) {\n        console.log(stdout);\n    }\n    if (stderr) {\n        console.log(stderr);\n    }\n    if (error) {\n        if (reject) {\n            reject(stderr?.toString());\n        }\n        if (error.code == 2) {\n            process.exit(2);\n        } else {\n            throw error;\n        }\n    }\n}\n\nfunction changeWorkingDirectory(dir) {\n    process.chdir(dir);\n}\n\nfunction fetchCreateFeatureBranch(recreateIfExists, featureBranch, gitDepth) {\n    console.log('START fetch Create Feature Branch');\n    if (featureBranch) {\n        if (recreateIfExists == 'true') {\n            this.asyncCopadoLogMessage(`Removing branch ${featureBranch}`);\n            const deleteLocalAndRemoteBranch = `\n            git branch -D \"${featureBranch}\" || true\n            git push origin --delete \"${featureBranch}\" || true`;\n            this.executeCommand(deleteLocalAndRemoteBranch);\n        }\n        this.asyncCopadoLogMessage(`Fetching/creating branch ${featureBranch}`);\n        this.executeCommand(this.fetchCheckoutBranch(featureBranch, gitDepth, true, `Error fetching/creating branch ${featureBranch}`));\n    } else {\n        throw 'No feature branch provided';\n    }\n    console.log('END fetch Create Feature Branch');\n}\n\nfunction findAndReplace(findAndReplaceFileId, featureBranch) {\n    console.log('START YAML replace');\n    const PATH_TO_YAML = `${TEMP_DIRECTORY}/${COPADO_YML}`;\n    if (findAndReplaceFileId && fs.existsSync(FILES_TO_INCLUDE)) {\n        this.asyncCopadoLogMessage('Applying global find and replace rules');\n        this.executeCommand(this.downloadFile(findAndReplaceFileId, `${TEMP_DIRECTORY}/`, COPADO_YML));\n        if (fs.existsSync(PATH_TO_YAML)) {\n            const findAndReplace = `yamlreplace \"${PATH_TO_YAML}\" \"${TARGET_DIRECTORY}\" -b \"${featureBranch}\" --include=${FILES_TO_INCLUDE} || ${this.getErrorCmdString(\n                'Error applying find and replace rules'\n            )}`;\n            this.executeCommand(findAndReplace);\n        } else {\n            throw 'Could not find the Copado.yml file';\n        }\n    }\n    console.log('END YAML replace');\n}\n\nfunction getEnrichServiceCommand(filePath, retrieveResultPath, operationType) {\n    return `enricher -p ${filePath} --repo ${TARGET_DIRECTORY}/ ${\n        retrieveResultPath && fs.existsSync(retrieveResultPath) ? `--cliresponse ${retrieveResultPath}` : '--quick true'\n    } ${operationType ? `--operation ${operationType}` : ''} || ${this.getErrorCmdString('Error finding file paths for the committed changes')}`;\n}\n\nfunction enrichChangeList(filePath, retrieveResultPath, operationType) {\n    console.log('START Enricher')\n    this.executeCommand(this.getEnrichServiceCommand(filePath, retrieveResultPath, operationType));\n    console.log('END Enricher')\n}\n\nfunction processMetadata() {\n    console.log('START Metadata Processor');\n    this.asyncCopadoLogMessage('Processing metadata');\n    const processsMetadata = `metadata-processor \"${COMMIT_CHANGES_FILE_PATH}\" \"${TARGET_DIRECTORY}\" -o COMMIT ||  ${this.getErrorCmdString('Error processing metadata')}`;\n    this.executeCommand(processsMetadata);\n    console.log('END Metadata Processor');\n}\n\nfunction gitCommit(commitMessage, branchName, filePaths, allowCommitWithNoChanges) {\n    let gitCommit = '';\n    this.asyncCopadoLogMessage(`Committing ${commitMessage} in ${branchName}`);\n    if (filePaths?.length) {\n        this.executeCommandinChunks(filePaths, chunkSize, `git add -f REPLACE_VALUE ||  ${this.getErrorCmdString(\"There was some issue when staging changes\")}`);\n    } else {\n        gitCommit = `git add . || ${this.getErrorCmdString(\"There was some issue when staging changes\")}`;\n    }\n    gitCommit = `\n    ${gitCommit}\n    git commit -m \"${commitMessage}\" || ${allowCommitWithNoChanges ? 'true' : this.getErrorCmdString(\"There was some issue when committing changes\")}`;\n    this.executeCommand(gitCommit);\n}\n\nfunction configureGit(gitEmail, gitName) {\n    const configureGit = `\n        git config feature.manyFiles true || ${this.getErrorCmdString('Failure in configuring feature.manyFiles true')}\n        git update-index --index-version 4 ||  ${this.getErrorCmdString('Failure in configuring update-index --index-version 4')}\n        git config --local user.email \"${gitEmail}\" || ${this.getErrorCmdString('Failure in configuring git user email')}\n        git config --local user.name \"${gitName}\" || ${this.getErrorCmdString('Failure in configuring git user name')}\n        git config --global diff.renames false || ${this.getErrorCmdString('Failure in disabling git rename detection from diff.renames')}\n        git config --global merge.renames false || ${this.getErrorCmdString('Failure in disabling git rename detection from merge.renames')}\n        git config --global status.renames false || ${this.getErrorCmdString('Failure in disabling git rename detection from status.renames')}\n        `;\n\n    this.executeCommand(`${configureGit}`);\n}\n\nasync function commitAndUpdateEnvironmentBranches(gitDepth, disableEarlyCommitCompletion) {\n    const resultData = {};\n    const { commitMessage, sourceEnvironmentBranch } = process.env,\n        gitStatus = this.executeCommand(`git status --porcelain`);\n\n    if (!gitStatus) {\n        resultData.status = 'No Changes';\n        this.executeCommand(`copado -p \"There are no changes to be committed\" -r '${JSON.stringify(resultData)}' && exit 0`);\n    } else {\n        console.log('START Commit and Push feature branch');\n        const filesToStage = this.getFilePaths(COMMIT_CHANGES_FILE_PATH);\n        this.gitCommit(commitMessage, featureBranch, filesToStage, false);\n        this.gitPush(featureBranch);\n        console.log('END Commit and Push feature branch');\n\n        resultData.commitId = this.getCommitId();\n        disableEarlyCommitCompletion?.toLowerCase() === 'true' ? this.updateResultWithCommitDetails(resultData) : await this.finishCommit(true, true, 'Commit Completed, Environment branches will be merged in the background', resultData);\n        this.executeAfterCommitOperations(sourceEnvironmentBranch, featureBranch, gitDepth, 0);\n    }\n}\n\nfunction finishCommit(isFinished, isSuccess, progressStatus, resultData) {\n    console.log('START Early Finish Commit');\n    return new Promise((resolve, reject) => {\n        const CF_SF_SESSIONID = process.env.CF_SF_SESSIONID;\n        const CF_SF_ENDPOINT = process.env.CF_SF_ENDPOINT.replace('https://', '');\n\n        const body = JSON.stringify(\n            {\n                result_id: process.env.CF_RESULTID,\n                is_finished: isFinished,\n                is_success: isSuccess,\n                status: progressStatus,\n                result_data: JSON.stringify(resultData)\n            }\n        );\n\n        const options = {\n            hostname: CF_SF_ENDPOINT,\n            path: '/services/apexrest/copado/FunctionWebEvent',\n            method: 'POST',\n            headers: {\n                'Content-Type': 'application/json',\n                'Accept': 'application/json',\n                'Content-Length': Buffer.byteLength(body),\n                'Authorization': `Bearer ${CF_SF_SESSIONID}`\n            },\n        };\n\n        const req = https.request(options, (res) => {\n            console.log(res.statusCode);\n            if (res.statusCode == 200) {\n                resolve();\n            } else {\n                this.updateResultWithCommitDetails(resultData);\n                resolve();\n            }\n        });\n\n        req.on('error', (error) => {\n            this.updateResultWithCommitDetails(resultData);\n            resolve();\n            console.error(error);\n        });\n\n        req.write(body);\n        req.end();\n        console.log('END Early Finish Commit');\n    })\n}\n\nfunction executeAfterCommitOperations(sourceEnvironmentBranch, featureBranch, gitDepth, numberOfRetries) {\n    console.log('START Merge feature branch in source environment branch');\n    try {\n        this.executeCommand(`\n        git reset --hard || true\n        git clean -fd || true`);\n        this.executeCommand(this.fetchCheckoutBranch(sourceEnvironmentBranch, gitDepth, false));\n        this.mergeFeatureBranchInSource(featureBranch, sourceEnvironmentBranch);\n        this.checkSFDXProjectJson(sourceEnvironmentBranch, sourceApiVersion);\n        this.gitPush(sourceEnvironmentBranch);\n    } catch (error) {\n        if (numberOfRetries < 1) {\n            this.executeAfterCommitOperations(sourceEnvironmentBranch, featureBranch, gitDepth, numberOfRetries + 1);\n        } else {\n            this.executeCommand(this.getErrorCmdString(error))\n        }\n    }\n\n    console.log('END Merge feature branch in source environment branch');\n}\n\n\nfunction mergeFeatureBranchInSource(featureBranch, sourceEnvironmentBranch) {\n    if (!sourceEnvironmentBranch) {\n        throw 'No source environment branch provided';\n    }\n    const mergeFeatureBranchInSource = `\n    git merge \"${featureBranch}\" -Xignore-space-change`;\n\n    try {\n        this.executeCommand(mergeFeatureBranchInSource);\n    } catch (error) {\n        const gitStatus = this.executeCommand(`git status --porcelain=v1`);\n        // Logging git status for debugging\n        console.log(gitStatus);\n        fs.writeFileSync(GIT_STATUS_FILE_PATH, gitStatus);\n        if (this.hasConflict()) {\n            fs.writeFileSync(`${TEMP_DIRECTORY}/output.json`, '');\n            this.asyncCopadoLogMessage('Resolving git conflicts');\n            this.executeCommand(`\n            copado-merge ${TARGET_DIRECTORY} ${COMMIT_CHANGES_FILE_PATH} -p ${GIT_STATUS_FILE_PATH} -t sfdx -c --out ${TEMP_DIRECTORY}/`\n            );\n        } else {\n            throw error;\n        }\n    }\n\n    this.gitCommit(`Merging ${featureBranch} into ${sourceEnvironmentBranch} after auto conflict resolution`, sourceEnvironmentBranch, undefined, true);\n}\n\nfunction hasConflict() {\n    let hasConflict = false;\n    const gitStatus = fs.readFileSync(GIT_STATUS_FILE_PATH, 'utf-8');\n    if (gitStatus) {\n        const porcelainStatus = gitStatus.split('\\n').map((str) => str.split(' ')?.[0]);\n        hasConflict = porcelainStatus.some((status) => {\n            if (\n                (status[0] && status[1] && status[0] === PORCELAIN_STATUS.ADDED && status[1] === PORCELAIN_STATUS.ADDED) ||\n                (status[0] === PORCELAIN_STATUS.DELETED && status[1] === PORCELAIN_STATUS.DELETED)\n            ) {\n                return true;\n            }\n            return status[0] === PORCELAIN_STATUS.UNMERGED || status[1] === PORCELAIN_STATUS.UNMERGED;\n        });\n    }\n    return hasConflict;\n}\n\nfunction getCommitId() {\n    return this.executeCommand(`git rev-parse HEAD || ${this.getErrorCmdString('There was some issue finding the commitid')}`);\n}\n\nfunction gitPush(branchName) {\n    this.asyncCopadoLogMessage(`Pushing all changes to ${branchName}`);\n    const gitPush = `git push origin \"${branchName}\"`;\n    this.executeCommand(gitPush);\n}\n\nfunction getErrorCmdString(error) {\n    // the -e param needs to be put in double quotes so that we don't terminate the command in case of single quotes in the error string\n    const suffix = 'Please check the logs for details.';\n    return `{ copado -p 'Error' -e \"${error}. ${suffix}\"; exit 2; }`;\n}\n\nfunction readFromPath(filePath) {\n    if (!fs.existsSync(filePath)) {\n        throw `Could not find file at path: ${filePath}`;\n    }\n    const data = fs.readFileSync(filePath, 'utf-8');\n    let result;\n    try {\n        result = JSON.parse(data);\n    } catch (err) {\n        throw `Content at ${filePath} is not a valid JSON`;\n    }\n    return result;\n}\n\nfunction getFilePaths(changeFilePath, actions, categories) {\n    let changeList = this.readFromPath(changeFilePath);\n    let filePaths = new Set();\n    if (actions?.length || categories?.length) {\n        changeList = changeList.filter((change) => {\n            let isValid = true;\n            if (actions?.length) {\n                isValid = isValid && actions.includes(change.a.toLowerCase());\n            }\n            if (categories?.length) {\n                isValid = isValid && categories?.includes(change.c.toLowerCase());\n            }\n            return isValid;\n        });\n    }\n    changeList.forEach((change) => {\n        if (change.j && change.j !== '') {\n            const jsonAdditionalInfo = JSON.parse(change.j);\n            let filesToBeAdded = jsonAdditionalInfo?.filePath?.filter((file) => fs.existsSync(file) && fs.statSync(file).isFile());\n            if (change.t.toLowerCase() == TYPES.CUSTOM_OBJECT && change.a.toLowerCase() == ACTIONS.FULL) {\n                const filePath = filesToBeAdded[0];\n                const dirPath = filePath.substring(0, filePath.lastIndexOf('/'));\n                filesToBeAdded = [dirPath];\n            }\n            if (change.a.toLowerCase() === ACTIONS.DELETE) {\n                filesToBeAdded = [...jsonAdditionalInfo?.deleteMapping.cascadeLocators, ...jsonAdditionalInfo.deleteMapping.nestedComponents.reduce((result, cmp) => {\n                    result.push(...cmp.cascadeLocators);\n                    return result;\n                }, [])];\n            }\n            if (filesToBeAdded) {\n                filePaths = new Set([...filePaths, ...filesToBeAdded]);\n            }\n        }\n    });\n    return [...filePaths];\n}\n\nfunction discardRetrieveOnlyFiles(commitChanges) {\n    console.log('START Discard retrieve only files');\n    if (commitChanges.Sfdx.retrieveOnly?.length) {\n        this.discardFilesInGit(this.getFilePaths(COMMIT_CHANGES_FILE_PATH, [ACTIONS.RETRIEVE_ONLY], [CATEGORY.SFDX]));\n    }\n    console.log('END Discard retrieve only files');\n}\n\nfunction getUntrackedFiles() {\n    const untrackedFiles = this.executeCommand(\n        `git ls-files --others --exclude-standard || ${this.getErrorCmdString('There was some issue finding the untracked files')}`\n    )\n        ?.split('\\n')\n        ?.map((file) => file?.trim())\n        ?.filter((file) => file != '');\n    return untrackedFiles;\n}\n\nfunction executeCommandinChunks(fileList, chunkSize, cmd) {\n\n    if (fileList.length > 0) {\n        let fileIndex = 0;\n        do {\n            let endIndex = fileIndex + parseInt(chunkSize) > fileList.length ? fileList.length : fileIndex + parseInt(chunkSize);\n            let fileChunk = fileList.slice(fileIndex, endIndex);\n            this.executeCommand(cmd.replace(/REPLACE_VALUE/g, fileChunk.map((file) => `'${file}'`).join(' ')));\n            fileIndex = endIndex;\n        } while (fileIndex < fileList.length);\n    }\n}\n\nfunction discardFilesInGit(fileList) {\n    const unTrackedFiles = this.getUntrackedFiles();\n    const toBeCleanedFiles = fileList.filter((file) => unTrackedFiles.includes(file));\n    const trackedFiles = fileList.filter((file) => !toBeCleanedFiles.includes(file));\n    toBeCleanedFiles?.length && this.executeCommandinChunks(toBeCleanedFiles, chunkSize, `git clean -fd REPLACE_VALUE`);\n    trackedFiles?.length && this.executeCommandinChunks(trackedFiles, chunkSize, `( git checkout HEAD -- REPLACE_VALUE ) || true`);\n}\n\n\nfunction executeCommand(cmd, disableLogs) {\n    const options = {\n        shell: true,\n        maxBuffer: MAXBUFFER\n    };\n    const response = child_process.spawnSync(cmd, options);\n    const { output, error } = this.log(response, disableLogs);\n    if (response?.status != 0) {\n        if (response?.status == 2) {\n            if (isTest) {\n                throw output;\n            }\n            process.exit(2);\n        }\n        throw error ? error : `Error executing the command: ${cmd}`;\n    }\n    return output;\n}\n\nfunction getApiVersion(overriddenApiVersion, apiVersion) {\n    const finalApiVersion = overriddenApiVersion || apiVersion;\n    const regExpApiVersion = /\\d\\d\\.0/;\n    if (!regExpApiVersion.test(finalApiVersion)) {\n        this.executeCommand(this.getErrorCmdString(`Invalid API Version: ${finalApiVersion}`));\n    }\n    return finalApiVersion;\n}\n\nfunction getPath(filePath) {\n    return isTest ? `${__dirname}/__tests__/__mockDir__${filePath}` : filePath;\n}\n\nfunction uploadFile(filePath, name) {\n    child_process.exec(\n        `copado --uploadfile ${filePath} ${name ? '--name ' + name : ''} || ${this.getErrorCmdString('Error uploading file at filePath: ' + filePath)}`,\n        this.options(),\n        (error, stdout, stderr) => {\n            this.handleResponse(error, stdout, stderr);\n        }\n    );\n}\n\nfunction downloadFile(fileId, downloadDir, fileName) {\n    return `copado --downloadfiles ${fileId} --downloaddir ${downloadDir} || ${this.getErrorCmdString('Error downloading file ' + fileName)}`;\n}\n\nfunction validateCommitId(commitId) {\n    if (commitId) {\n        this.updateResultWithCommitDetails({ commitId });\n        process.exit(0);\n    }\n}\n\nfunction updateResultWithCommitDetails(resultData) {\n    this.executeCommand(\n        `copado -p 'Saving commit details' --result-data '${JSON.stringify(resultData)}' || ${this.getErrorCmdString('Error saving commit details')}`\n    );\n}\n\nfunction getGitDepth(gitDepth) {\n    gitDepth = parseInt(gitDepth);\n    return gitDepth >= 0 ? gitDepth : 100;\n}\n\nfunction fetchCheckoutBranch(branch, gitDepth, forceCreate, error) {\n    return (\n        `( git fetch origin ${branch} --depth ${gitDepth} && git checkout ${branch} )` +\n        (forceCreate ? ` || git checkout -b ${branch}` : '') +\n        `${error ? ' || ' + this.getErrorCmdString(error) : ''}`\n    );\n}\n\nfunction log(response, disableLogs) {\n    const output = response?.stdout?.toString().trim();\n    const error = response?.stderr?.toString().trim();\n    if (!disableLogs) {\n        if (output) {\n            console.log(output);\n        }\n        if (error) {\n            console.log(error);\n        }\n    }\n    return { output, error };\n}\n\nfunction copyFiles(source, target) {\n    child_process.execSync(\n        `\n            cp -R ${source} ${target}\n        `,\n        { stdio: STDIO.INHERIT }\n    );\n}\n\nfunction asyncCopadoLogMessage(msg) {\n    new Promise(resolve => {\n        child_process.exec(`copado -p \"${msg}\"`, { stdio: STDIO.INHERIT }, (err, response, stderr) => {\n            resolve();\n        });\n    });\n}\n\n\n\nmodule.exports.encodeFileNames = encodeFileNames\nmodule.exports.getCommitChanges = getCommitChanges\nmodule.exports.executeCommand = executeCommand\nmodule.exports.discardFilesInGit = discardFilesInGit\nmodule.exports.getUntrackedFiles = getUntrackedFiles\nmodule.exports.executeCommandinChunks = executeCommandinChunks\nmodule.exports.discardRetrieveOnlyFiles = discardRetrieveOnlyFiles\nmodule.exports.getFilePaths = getFilePaths\nmodule.exports.readFromPath = readFromPath\nmodule.exports.getErrorCmdString = getErrorCmdString\nmodule.exports.gitPush = gitPush\nmodule.exports.getCommitId = getCommitId\nmodule.exports.commitAndUpdateEnvironmentBranches = commitAndUpdateEnvironmentBranches\nmodule.exports.processMetadata = processMetadata\nmodule.exports.gitCommit = gitCommit\nmodule.exports.findAndReplace = findAndReplace\nmodule.exports.execute = execute\nmodule.exports.fetchCreateFeatureBranch = fetchCreateFeatureBranch\nmodule.exports.getFilesInScope = getFilesInScope\nmodule.exports.varReplace = varReplace\nmodule.exports.retrieveOrgMetadata = retrieveOrgMetadata\nmodule.exports.retrieveFullProfile = retrieveFullProfile\nmodule.exports.sfdxRetrieve = sfdxRetrieve\nmodule.exports.configureSFDXCLI = configureSFDXCLI\nmodule.exports.checkSFDXProjectJson = checkSFDXProjectJson\nmodule.exports.setup = setup\nmodule.exports.checkNestedParentMetadataDeletion = checkNestedParentMetadataDeletion\nmodule.exports.prepareMetadataChangesList = prepareMetadataChangesList\nmodule.exports.configureGit = configureGit\nmodule.exports.getApiVersion = getApiVersion\nmodule.exports.validateCommittedChanges = validateCommittedChanges\nmodule.exports.uploadFile = uploadFile\nmodule.exports.downloadFile = downloadFile\nmodule.exports.mergeFeatureBranchInSource = mergeFeatureBranchInSource\nmodule.exports.validateCommitId = validateCommitId\nmodule.exports.updateResultWithCommitDetails = updateResultWithCommitDetails\nmodule.exports.initialSetup = initialSetup\nmodule.exports.handleResponse = handleResponse\nmodule.exports.createTargetDirectoryAndFetchBaseBranch = createTargetDirectoryAndFetchBaseBranch\nmodule.exports.options = options\nmodule.exports.changeWorkingDirectory = changeWorkingDirectory\nmodule.exports.enrichChangeList = enrichChangeList\nmodule.exports.getEnrichServiceCommand = getEnrichServiceCommand\nmodule.exports.getGitDepth = getGitDepth;\nmodule.exports.fetchCheckoutBranch = fetchCheckoutBranch;\nmodule.exports.hasConflict = hasConflict;\nmodule.exports.log = log;\nmodule.exports.copyFiles = copyFiles;\nmodule.exports.getSFChanges = getSFChanges;\nmodule.exports.finishCommit = finishCommit;\nmodule.exports.asyncCopadoLogMessage = asyncCopadoLogMessage;\nmodule.exports.executeAfterCommitOperations = executeAfterCommitOperations;\nmodule.exports.updateCommitChangeFileWithProfilePaths = updateCommitChangeFileWithProfilePaths;\n\n// EXECUTION\n\n!isTest && this.execute(commitChanges);",
                    "copado__Type__c": "Standard",
                    "copado__Version__c": "1",
                    "copado__Worker_Size__c": "M",
                    "Id": "a0l7Q000000iAiLQAU",
                    "LastReferencedDate": "2023-07-11T17:23:25.000+0000",
                    "LastViewedDate": "2023-07-11T17:23:25.000+0000",
                    "Name": "Commit"
                },
                {
                    "attributes": {
                      "type": "copado__Function__c",
                      "url": "/services/data/v58.0/sobjects/copado__Function__c/a0l7Q000000iAiMQAU"
                    },
                    "copado__API_Name__c": "sfdx_promote",
                    "copado__Callback_Type__c": "Flow",
                    "copado__Description__c": "Creation of Promotion Branch and Promotion of user stories",
                    "copado__FlowHandler__c": "cmcSf.Update_Conflict_Resolution_File",
                    "copado__Image_Name__c": "copado-multicloud-dx:v3",
                    "copado__Options__c": "[ ]",
                    "copado__Parameters__c": "[ {\n  \"required\" : true,\n  \"name\" : \"userStoryBranches\",\n  \"defaultValue\" : \"{$Context.JobExecution__r.DataJson.userStoryBranches}\"\n}, {\n  \"required\" : true,\n  \"name\" : \"promotionBranch\",\n  \"defaultValue\" : \"{$Context.JobExecution__r.DataJson.promotionBranchName}\"\n}, {\n  \"required\" : true,\n  \"name\" : \"targetBranch\",\n  \"defaultValue\" : \"{$Context.JobExecution__r.DataJson.destinationBranchName}\"\n}, {\n  \"required\" : false,\n  \"name\" : \"tag\",\n  \"defaultValue\" : \"{$Context.JobExecution__r.Promotion__r.Release__r.Version__c}\"\n}, {\n  \"required\" : true,\n  \"name\" : \"git_json\",\n  \"defaultValue\" : \"{$Context.Repository.Credential}\"\n}, {\n  \"required\" : false,\n  \"name\" : \"recreatePromotionBranch\",\n  \"defaultValue\" : \"{$Context.JobExecution__r.Promotion__r.cmcSf__Recreate_Promotion_Branch__c}\"\n}, {\n  \"name\" : \"promotionId\",\n  \"defaultValue\" : \"{$Job.ExecutionParent.Id}\"\n}, {\n  \"name\" : \"fileChangesId\",\n  \"defaultValue\" : \"{$Context.JobExecution__r.DataJson.fileWithSelectedChanges}\"\n}, {\n  \"name\" : \"conflictResolutionAttachments\",\n  \"defaultValue\" : \"{$Context.apex.GetConflictResolutionAttachments}\"\n}, {\n  \"name\" : \"gitName\",\n  \"defaultValue\" : \"{$User.Name}\"\n}, {\n  \"name\" : \"gitEmail\",\n  \"defaultValue\" : \"{$User.Email}\"\n}, {\n  \"name\" : \"repositoryId\",\n  \"defaultValue\" : \"{$Pipeline.Git_Repository__r.Id}\"\n}, {\n  \"required\" : false,\n  \"name\" : \"gitDepth\",\n  \"defaultValue\" : \"{$Pipeline.Property.gitDepth_promote}\"\n}, {\n  \"name\" : \"maxBuffer\",\n  \"defaultValue\" : \"5242880\"\n}, {\n  \"required\" : true,\n  \"name\" : \"fileName\",\n  \"defaultValue\" : \"Copado Promotion changes\"\n}, {\n  \"name\" : \"overriddenApiVersion\",\n  \"defaultValue\" : \"\"\n} ]",
                    "copado__Script__c": "#!/usr/bin/env node\n'use strict';\n\n/**\n * Performs promotion of selected user story metadata changes.\n * Returns (If ACTION success) new peomotion branch in user repo with all the changes\n * (If ACTION failed) Returns details with conflict or error status on promotion record\n * @param userStoryBranches\n * @param promotionBranch\n * @param targetBranch\n * @param tag\n * @param recreatePromotionBranch\n * @param promotionId\n * @param fileChangesId\n * @param conflictResolutionAttachments\n * @param gitName\n * @param gitEmail\n * @param repositoryId\n * @param gitDepth\n * @param maxBuffer\n */\n\nconst child_process = require('child_process'),\n    { existsSync, readFileSync, writeFileSync } = require('fs'),\n    { exit, env, chdir } = require('process');\n\nconst {\n        fileChangesId,\n        targetBranch,\n        promotionBranch,\n        gitDepth,\n        gitEmail,\n        gitName,\n        promotionId,\n        repositoryId,\n        conflictResolutionAttachments,\n        userStoryBranches,\n        tag,\n        recreatePromotionBranch,\n        maxBuffer,\n        fileName,\n        overriddenApiVersion,\n        API_VERSION,\n        isTest,\n        GIT_BATCH_SIZE\n    } = env,\n    MAX_BUFFER = parseInt(maxBuffer),\n    STDIO = {\n        INHERIT: 'inherit',\n        PIPE: 'pipe'\n    },\n    APP_DIRECTORY = getPath('/app'),\n    TEMP_DIRECTORY = getPath('/tmp'),\n    TARGET_DIRECTORY = `${APP_DIRECTORY}/repository`,\n    OUTPUT_JSON_PATH = `${TEMP_DIRECTORY}/output.json`,\n    GIT_STATUS_FILE_PATH = `${TEMP_DIRECTORY}/git_status.txt`,\n    ENRICHED_CHANGE_FILE_PATH = `${TEMP_DIRECTORY}/enrichedPromotionChanges.json`,\n    VLOCITY_CATEGORY = 'Vlocity',\n    GIT_DEPTH = getGitDepth(gitDepth),\n    PORCELAIN_STATUS = {\n        ADDED: 'A',\n        DELETED: 'D',\n        UNMERGED: 'U'\n    };\n\n// SCRIPT FUNCTIONS\n\nfunction execute() {\n    try {\n        const promotionChangesFilePath = this.getPromotionChanges(fileChangesId, fileName);\n        this.setUpDirectory(TARGET_DIRECTORY);\n        this.fetchTargetBranch(targetBranch);\n        this.configureGit(gitEmail, gitName);\n        this.fetchCreatePromotionBranch(promotionBranch, recreatePromotionBranch);\n        this.checkSFDXProjectJson(overriddenApiVersion, API_VERSION);\n        this.promote(userStoryBranches, promotionChangesFilePath, promotionBranch, promotionId, repositoryId);\n        this.gitPush(tag, promotionBranch);\n    } catch (error) {\n        this.executeCommand(this.getErrorCommand(error.toString()));\n    }\n}\n\nfunction asyncCopadoLogMessage(msg) {\n    new Promise(resolve => {\n        child_process.exec(`copado -p \"${msg}\"`, { stdio: STDIO.INHERIT }, (err, response, stderr) => {\n            resolve();\n        });\n    });\n}\n\nfunction getPath(filePath) {\n    return isTest ? `${__dirname}/__tests__/__mockDirectory__${filePath}` : filePath;\n}\n\nfunction getPromotionChanges(fileChangesId, fileName) {\n    console.log('START getting promotion changes');\n    this.executeCommand(\n        `copado --downloadfiles ${fileChangesId} --downloaddir ${TEMP_DIRECTORY}/ || ${this.getErrorCommand('Error in downloading change list file')}`\n    );\n    console.log('END getting promotion changes');\n    if (existsSync(`${TEMP_DIRECTORY}/${fileName}`)) {\n        return `${TEMP_DIRECTORY}/${fileName}`;\n    } else if (existsSync(`${TEMP_DIRECTORY}/${fileName}.json`)) {\n        return `${TEMP_DIRECTORY}/${fileName}.json`;\n    } else {\n        throw 'Error fetching Promotion Changes';\n    }\n}\n\nfunction setUpDirectory(dir) {\n    const cmd = `\n        mkdir -p ${dir}\n    `;\n    this.executeCommand(cmd);\n    chdir(dir);\n}\n\nfunction fetchTargetBranch(targetBranch) {\n    console.log('START fetching target branch');\n    this.executeCommand(this.getRemoteBranchFetchCommand(targetBranch));\n    console.log('END fetching target branch');\n}\n\nfunction getRemoteBranchFetchCommand(branch) {\n    return `copado-git-get --depth \"${GIT_DEPTH}\" \"${branch}\" || ${this.getErrorCommand(`Error fetching branch ${branch}`)}`;\n}\n\nfunction fetchCreatePromotionBranch(promotionBranch, recreatePromotionBranch) {\n    console.log('START fetching / creating promotion branch');\n    let cmd = '';\n    if (!promotionBranch) {\n        throw `Kindly provide a valid promotion branch`;\n    }\n    if (recreatePromotionBranch === 'true' && this.remotePromotionBranchExists(promotionBranch)) {\n        this.asyncCopadoLogMessage(`Removing branch ${promotionBranch}`);\n        cmd = `\n            git push origin --delete \"${promotionBranch}\" || ${this.getErrorCommand(`Error deleting branch ${promotionBranch}`)}\n        `;\n    }\n    this.asyncCopadoLogMessage(`Fetching/creating branch ${promotionBranch}`);\n    cmd += `\n        ${this.fetchCheckoutBranch(promotionBranch, true, `Error fetching/creating branch ${promotionBranch}`)}\n    `;\n    this.executeCommand(cmd);\n    console.log('END fetching / creating promotion branch');\n}\n\nfunction remotePromotionBranchExists(promotionBranch) {\n    const cmd = `git ls-remote --heads origin ${promotionBranch} || ${this.getErrorCommand(\n        `Failure in validating remote branch ${promotionBranch} exist or not`\n    )}`;\n    return this.executeCommand(cmd, STDIO.PIPE);\n}\n\nfunction configureGit(gitEmail, gitName) {\n    this.executeCommand(`\n        git config --local user.email \"${gitEmail}\" || ${this.getErrorCommand('Failure in configuring git user email')}\n        git config --local user.name \"${gitName}\" || ${this.getErrorCommand('Failure in configuring git user name')}\n        git config --global diff.renames false || ${this.getErrorCommand('Failure in disabling git rename detection from diff.renames')}\n        git config --global merge.renames false || ${this.getErrorCommand('Failure in disabling git rename detection from merge.renames')}\n        git config --global status.renames false || ${this.getErrorCommand('Failure in disabling git rename detection from status.renames')}\n    `);\n}\n\nfunction promote(userStoryBranches, promotionChangesFilePath, promotionBranch, promotionId, repositoryId) {\n    console.log('START promote operation');\n    const featureBranches = JSON.parse(userStoryBranches);\n    this.fetchFeatureBranches(featureBranches);\n    let gitConflictsResolution = [];\n    console.log('START Merging branches into Promotion branch');\n    for (let story of featureBranches) {\n        this.checkoutFeatureAndPromotionBranch(story, promotionBranch);\n        try {\n            this.mergeFeatureBranchInPromotionBranch(story, promotionBranch);\n        } catch (error) {\n            writeFileSync(GIT_STATUS_FILE_PATH, this.executeCommand(`git status --porcelain=v1`, STDIO.PIPE));\n            if (this.hasConflict()) {\n                gitConflictsResolution.push(...this.handleConflicts(promotionChangesFilePath, promotionId, repositoryId, story, promotionBranch));\n            } else {\n                throw error;\n            }\n        }\n    }\n    console.log('END Merging branches into Promotion branch');\n    console.log('END promote operation');\n    this.uploadGitConflictsResolution(gitConflictsResolution);\n}\n\nfunction fetchFeatureBranches(userStoryBranches) {\n    console.log('START fetch feature branches');\n    const chunkSize = GIT_BATCH_SIZE ? parseInt(GIT_BATCH_SIZE) : 10;\n    if (userStoryBranches.length > 0) {\n        let index = 0;\n        do {\n            const endIndex = index + chunkSize > userStoryBranches.length ? userStoryBranches.length : index + chunkSize;\n            const branches = userStoryBranches.slice(index, endIndex);\n            this.executeCommand(this.buildFetchFeatureBranchesCommand(branches));\n            index = endIndex;\n        } while (index < userStoryBranches.length);\n    }\n    console.log('END fetch feature branches');\n}\n\nfunction buildFetchFeatureBranchesCommand(userStoryBranches) {\n    return `git fetch origin ${userStoryBranches.map(branch => `'${branch}'`).join(' ')} --depth ${GIT_DEPTH} || ${this.getErrorCommand(\n        'Error fetching feature branches'\n    )}`;\n}\n\nfunction checkoutFeatureAndPromotionBranch(userStoryBranch, promotionBranch) {\n    const checkoutFeatureAndPromotionBranch = `\n        git checkout \"${userStoryBranch}\" || ${this.getErrorCommand(`Error checking out branch ${userStoryBranch}`)}\n        git checkout \"${promotionBranch}\" || ${this.getErrorCommand(`Error checking out branch ${promotionBranch}`)}\n    `;\n    this.executeCommand(checkoutFeatureAndPromotionBranch);\n}\n\nfunction mergeFeatureBranchInPromotionBranch(userStoryBranch, promotionBranch) {\n    this.executeCommand(`git merge -m \"Merging ${userStoryBranch} to ${promotionBranch}\" \"${userStoryBranch}\" -Xignore-space-change`, STDIO.PIPE);\n}\n\nfunction handleConflicts(promotionChangesFilePath, promotionId, repositoryId, userStoryBranch, promotionBranch) {\n    let output;\n    let gitConflictsResolution = [];\n    this.resolveConflict(userStoryBranch.split('/')[1], promotionChangesFilePath, promotionId, repositoryId);\n    if (existsSync(OUTPUT_JSON_PATH)) {\n        output = JSON.parse(readFileSync(OUTPUT_JSON_PATH, 'utf8'));\n        if (output?.some(file => file.strategy === 'ONLINE_CONFLICT_RESOLUTION')) {\n            //reseting the conflicted files to reuse the volume later in the same promotion\n            this.executeCommand('git reset --hard || true');\n            this\n                .executeCommand(`copado -p 'Conflict found while merging ${userStoryBranch} to ${promotionBranch}. Conflict needs to be resolved manually.' -r '{\"status\": \"conflicts\"}' \n                exit 2`);\n        }\n    }\n    this.gitCommit(`Merging ${userStoryBranch} to ${promotionBranch} after auto conflict resolution`);\n    if (output?.length) {\n        gitConflictsResolution.push(...this.saveMergeCommitId(output));\n    }\n    return gitConflictsResolution;\n}\n\nfunction uploadGitConflictsResolution(gitConflictsResolution) {\n    console.log('START Uploading conflict resolution');\n    if (gitConflictsResolution?.length) {\n        const conflictResolutionsFilePath = `${TEMP_DIRECTORY}/GitConflictsResolution.json`;\n        writeFileSync(conflictResolutionsFilePath, JSON.stringify(gitConflictsResolution, null, 2));\n        this.executeCommand(\n            `copado --uploadfile ${conflictResolutionsFilePath} || ${this.getErrorCommand('Error uploading git conflicts resolution')}`\n        );\n    }\n    console.log('END Uploading conflict resolution');\n}\n\nfunction hasConflict() {\n    let hasConflict = false;\n    const gitStatus = readFileSync(GIT_STATUS_FILE_PATH, 'utf-8');\n    console.log(gitStatus);\n    if (gitStatus) {\n        const porcelainStatus = gitStatus.split('\\n').map(str => str.split(' ')?.[0]);\n        hasConflict = porcelainStatus.some(status => {\n            if (\n                (status[0] && status[1] && status[0] === PORCELAIN_STATUS.ADDED && status[1] === PORCELAIN_STATUS.ADDED) ||\n                (status[0] === PORCELAIN_STATUS.DELETED && status[1] === PORCELAIN_STATUS.DELETED)\n            ) {\n                return true;\n            }\n            return status[0] === PORCELAIN_STATUS.UNMERGED || status[1] === PORCELAIN_STATUS.UNMERGED;\n        });\n    }\n    return hasConflict;\n}\n\nfunction getCopadoMergeCommand(promotionChangesFilePath, promotionId, repositoryId) {\n    return `copado-merge ${TARGET_DIRECTORY} '${promotionChangesFilePath}' -p ${GIT_STATUS_FILE_PATH} -t sfdx -cp ${promotionId} -rp ${repositoryId}`;\n}\n\nfunction resolveConflict(userStoryName, promotionChangesFilePath, promotionId, repositoryId) {\n    const CONFLICTED_CHANGES = `${TEMP_DIRECTORY}/conflictedChanges`;\n    writeFileSync(CONFLICTED_CHANGES, this.getConflictingFilePaths().join('\\n'), 'utf-8');\n    const promotionChanges = JSON.parse(readFileSync(promotionChangesFilePath, 'utf8'));\n\n    // We encode Vlocity datapacks name to identify retrieved folder names.\n    this.updateVlocityChangesFile(promotionChangesFilePath, promotionChanges);\n\n    const enrichMetadataList = `enricher -p '${promotionChangesFilePath}' --changefile ${CONFLICTED_CHANGES} --repo ${TARGET_DIRECTORY}/  --out ${ENRICHED_CHANGE_FILE_PATH} || ${this.getErrorCommand(\n        'Error finding file paths for the promoted changes'\n    )}`;\n    this.executeCommand(enrichMetadataList);\n\n    this.executeCommand(`\n    echo \"${JSON.stringify(conflictResolutionAttachments)}\" > ${TEMP_DIRECTORY}/solvedByUser.json\n    touch ${OUTPUT_JSON_PATH}`);\n\n    this.executeCommand(\n        `${this.getCopadoMergeCommand(\n            promotionChangesFilePath,\n            promotionId,\n            repositoryId\n        )} -r ${TEMP_DIRECTORY}/solvedByUser.json  -u ${userStoryName}  --out ${TEMP_DIRECTORY} -v2 --conflictedchanges '${ENRICHED_CHANGE_FILE_PATH}' ||  ${this.getErrorCommand(\n            'Error processing merge'\n        )}`\n    );\n}\n\nfunction getConflictingFilePaths() {\n    const lines = readFileSync(GIT_STATUS_FILE_PATH, 'utf-8')?.split('\\n');\n    const conflictedFiles = [];\n    if (lines?.length) {\n        lines.forEach(line => {\n            if (line) {\n                const space = line.indexOf(' ');\n                // AA tmp/filepath\n                const conflictType = line.substring(0, space);\n                const filePath = line.substring(space + 1).replaceAll(/^\\\"|\\\"$/g, '');\n                if (filePath && conflictType.length == 2 && !conflictType.includes('?')) {\n                    conflictedFiles.push(filePath);\n                }\n            }\n        });\n    }\n    // throwing an error when the backend service responds that the merge has conflict, but the git status does not provide the paths\n    if (!conflictedFiles?.length) {\n        throw 'Could not find conflicting files';\n    }\n    return conflictedFiles;\n}\n\nfunction gitCommit(commitMessage) {\n    this.executeCommand(`\n        git add . # add all the resolved changes, if any \n        git commit -am \"${commitMessage}\" || true`);\n}\n\nfunction saveMergeCommitId(output) {\n    const cmd = `git rev-parse HEAD || ${this.getErrorCommand('There was some issue finding the commitid')}`;\n    const mergeCommitId = this.executeCommand(cmd, STDIO.PIPE)?.trim();\n    output.map(file => (file.sucessfulPromotion = mergeCommitId));\n    return output;\n}\n\nfunction gitPush(tag, promotionBranch) {\n    console.log('START push promotion branch');\n    const escapedTag = tag ? this.escapeSpecialCharacters(tag).replace(/[|]/g, \"'\\\\|'\") : null;\n    const cmd = escapedTag\n        ? `\n            git tag '${escapedTag}' || ${this.getErrorCommand(`Could not create the tag ${escapedTag}`)}\n            git push --all || ${this.getErrorCommand('Could not push the changes')}\n        `\n        : `\n            echo 'No tag specified'\n            git push origin \"${promotionBranch}\" || ${this.getErrorCommand('Could not push the changes')}\n        `;\n    this.asyncCopadoLogMessage(`Pushing all changes`);\n    this.executeCommand(`\n        ${cmd}\n    `);\n    console.log('END push promotion branch');\n}\n\nfunction checkSFDXProjectJson(overriddenApiVersion, apiVersion) {\n    const SOURCE_API_VERSION = this.getApiVersion(overriddenApiVersion, apiVersion);\n    const sfdxProjectJsonPath = `${TARGET_DIRECTORY}/sfdx-project.json`;\n    if (existsSync(sfdxProjectJsonPath)) {\n        let fileContent = JSON.parse(readFileSync(sfdxProjectJsonPath, { encoding: 'utf8' }));\n        if (fileContent.sourceApiVersion !== SOURCE_API_VERSION) {\n            const commitMessage = `Updated  sourceApiVersion from ${fileContent.sourceApiVersion} to ${SOURCE_API_VERSION} in sfdx-project.json to align the commit, promote and deploy operations with the latest supported api version of Copado.`;\n            fileContent.sourceApiVersion = SOURCE_API_VERSION;\n            writeFileSync(sfdxProjectJsonPath, JSON.stringify(fileContent, null, 2));\n            this.gitCommit(commitMessage);\n        }\n    } else {\n        throw 'Invalid configuration. sfdx-project.json is invalid or missing at project root. Copado Commit and Deploy operations are required to run from within a valid sfdx project.';\n    }\n}\n\nfunction getErrorCommand(error) {\n    const suffix = 'Please check the logs for details.';\n    return `{ copado -p 'Error' -e \"${error}. ${suffix}\"; exit 2; }`;\n}\n\nfunction executeCommand(cmd, ioconfig) {\n    const options = {\n        shell: true,\n        maxBuffer: MAX_BUFFER\n    };\n    options.stdio = ioconfig ? ioconfig : STDIO.INHERIT;\n    const response = child_process.spawnSync(cmd, options);\n    const { output, error } = this.log(response);\n    if (response?.status != 0) {\n        if (response?.status == 2) {\n            if (isTest) {\n                throw output;\n            }\n            exit(2);\n        }\n        throw error ? error : `Error executing the command: ${cmd}`;\n    }\n    return output;\n}\n\nfunction getApiVersion(overriddenApiVersion, apiVersion) {\n    const finalApiVersion = overriddenApiVersion || apiVersion;\n    const regExpApiVersion = /\\d\\d\\.0/;\n    if (!regExpApiVersion.test(finalApiVersion)) {\n        this.executeCommand(this.getErrorCommand(`Invalid API Version: ${finalApiVersion}`));\n    }\n    return finalApiVersion;\n}\n\nfunction escapeSpecialCharacters(text) {\n    return text.replace(/'/g, \"'\\\\''\");\n}\n\nfunction getGitDepth(gitDepth) {\n    gitDepth = parseInt(gitDepth);\n    return gitDepth >= 0 ? gitDepth : 100;\n}\n\nfunction fetchCheckoutBranch(branch, forceCreate, error) {\n    return (\n        `( git fetch origin ${branch} --depth ${GIT_DEPTH} && git checkout ${branch} )` +\n        (forceCreate ? ` || git checkout -b ${branch}` : '') +\n        ` || ${this.getErrorCommand(error)}`\n    );\n}\n\nfunction log(response) {\n    const output = response?.stdout?.toString().trim();\n    const error = response?.stderr?.toString().trim();\n    if (output) {\n        console.log(output);\n    }\n    if (error) {\n        console.log(error);\n    }\n    return { output, error };\n}\n\nfunction updateVlocityChangesFile(promotionChangesFilePath, promotionChanges) {\n    const hasVlocityChanges = promotionChanges.find(changeObj => changeObj.c === VLOCITY_CATEGORY)?.c;\n    if (hasVlocityChanges) {\n        promotionChanges.forEach(changeObj => {\n            if(changeObj.c === VLOCITY_CATEGORY) {\n                const datapackKey = JSON.parse(changeObj.j)?.vk?.split('/');\n                changeObj.n = datapackKey[1]\n                    ?.replace('\\\\', '-')\n                    .replace(/[^A-Za-z0-9/_\\-]+/g, '-')\n                    .replace(/[-]+/g, '-')\n                    .replace(/[-_]+_/g, '_')\n                    .replace(/[-]+\\/[-]+/g, '/')\n                    .replace(/^[-_\\\\/]+/, '')\n                    .replace(/[-_\\\\/]+$/, '');\n            }\n        });\n        writeFileSync(promotionChangesFilePath, JSON.stringify(promotionChanges, null, 2));\n    }\n}\n\nmodule.exports.execute = execute;\nmodule.exports.asyncCopadoLogMessage = asyncCopadoLogMessage;\nmodule.exports.getPromotionChanges = getPromotionChanges;\nmodule.exports.setUpDirectory = setUpDirectory;\nmodule.exports.fetchTargetBranch = fetchTargetBranch;\nmodule.exports.fetchCreatePromotionBranch = fetchCreatePromotionBranch;\nmodule.exports.configureGit = configureGit;\nmodule.exports.promote = promote;\nmodule.exports.uploadGitConflictsResolution = uploadGitConflictsResolution;\nmodule.exports.hasConflict = hasConflict;\nmodule.exports.getCopadoMergeCommand = getCopadoMergeCommand;\nmodule.exports.resolveConflict = resolveConflict;\nmodule.exports.getConflictingFilePaths = getConflictingFilePaths;\nmodule.exports.gitCommit = gitCommit;\nmodule.exports.saveMergeCommitId = saveMergeCommitId;\nmodule.exports.gitPush = gitPush;\nmodule.exports.checkSFDXProjectJson = checkSFDXProjectJson;\nmodule.exports.getErrorCommand = getErrorCommand;\nmodule.exports.executeCommand = executeCommand;\nmodule.exports.getApiVersion = getApiVersion;\nmodule.exports.escapeSpecialCharacters = escapeSpecialCharacters;\nmodule.exports.fetchFeatureBranches = fetchFeatureBranches;\nmodule.exports.mergeFeatureBranchInPromotionBranch = mergeFeatureBranchInPromotionBranch;\nmodule.exports.getRemoteBranchFetchCommand = getRemoteBranchFetchCommand;\nmodule.exports.remotePromotionBranchExists = remotePromotionBranchExists;\nmodule.exports.getPath = getPath;\nmodule.exports.handleConflicts = handleConflicts;\nmodule.exports.getGitDepth = getGitDepth;\nmodule.exports.fetchCheckoutBranch = fetchCheckoutBranch;\nmodule.exports.buildFetchFeatureBranchesCommand = buildFetchFeatureBranchesCommand;\nmodule.exports.checkoutFeatureAndPromotionBranch = checkoutFeatureAndPromotionBranch;\nmodule.exports.log = log;\nmodule.exports.updateVlocityChangesFile = updateVlocityChangesFile;\n\n// EXECUTION\n\n!isTest && this.execute();",
                    "copado__Type__c": "Standard",
                    "copado__Worker_Size__c": "M",
                    "Id": "a0l7Q000000iAiMQAU",
                    "LastReferencedDate": "2023-07-11T17:23:57.000+0000",
                    "LastViewedDate": "2023-07-11T17:23:57.000+0000",
                    "Name": "Promote"
                  },
                {
                    "attributes": {
                        "type": "copado__Function__c",
                        "url": "/services/data/v55.0/sobjects/copado__Function__c/a0l7Q000000MDYyQAO"
                    },
                    "copado__API_Name__c": "sfdx_encode_file_names",
                    "copado__Image_Name__c": "copado-multicloud-dx:v3",
                    "copado__Options__c": "[ ]",
                    "copado__Parameters__c": "[ {\n  \"name\" : \"file_changes_id\",\n  \"defaultValue\" : \"{$Context.JobExecution__r.DataJson.fileWithSelectedChanges}\"\n}, {\n  \"name\" : \"file_name\",\n  \"defaultValue\" : \"Copado Deploy changes\"\n} ]",
                    "copado__Script__c": "#!/usr/bin/env node\nconst execSync = require('child_process').execSync,\n    { existsSync, writeFileSync, readFileSync } = require('fs');\n\nlet deploymentMetadata = [];\n\n// EXECUTION\n\nexecute();\n\nfunction execute() {\n    getDeployChanges();\n    if (deploymentMetadata.length) {\n        encodeFileNames();\n    }\n}\n\n// SCRIPT FUNCTIONS\n\nfunction getDeployChanges() {\n    const { file_name, file_changes_id } = process.env;\n    execSync(`copado --downloadfiles ${file_changes_id} --downloaddir /tmp/`);\n    let downloadedFileName;\n    if (existsSync(`/tmp/${file_name}`)) {\n        downloadedFileName = file_name;\n    } else if (existsSync(`/tmp/${file_name}.json`)) {\n        downloadedFileName = `${file_name}.json`;\n    } else {\n        throw 'Error fetching Deployment Changes';\n    }\n    deploymentMetadata = readFromPath(`/tmp/${downloadedFileName}`);\n\n    //TODO : First condition needs to be removed, adding this now to make sure already committed files do not fail in further operations.\n    deploymentMetadata = deploymentMetadata.filter((element) => !element.c || element.c === 'SFDX');\n}\nfunction encodeFileNames() {\n    for (let change of deploymentMetadata) {\n        switch (change.t) {\n            case 'DashboardFolder':\n            case 'ReportFolder':\n            case 'Document':\n                change.n = change.n.substring(0, change.n.lastIndexOf('.')) ? change.n.substring(0, change.n.lastIndexOf('.')) : change.n;\n                break;\n\n            case 'EmailTemplate':\n                change.n = change.n.replace(/%24/gi, '$').replace(/%2F/gi, '/');\n                break;\n\n            case 'Layout':\n                const regExp = '(?:([a-zA-Z_][a-zA-Z0-9_]{0,14}?(?!__c-))__)?([^-]+)-(?:([a-zA-Z_][a-zA-Z0-9_]{0,14}?_?(?!__c$))__)?(.+)\\n?';\n                const layoutFullName = change.n.match(regExp);\n                let layoutName = layoutFullName[4].replace(/_{2}(?!c)/g, (match) => {\n                    return match.replace(/_/gi, '%5F');\n                });\n                layoutName = layoutName.replace(/\\./, '%2E');\n                change.n = `${layoutFullName[1] ? layoutFullName[1] + '__' : ''}${layoutFullName[2]}-${\n                    layoutFullName[3] ? layoutFullName[3] + '__' : ''\n                }${layoutName}`;\n                break;\n        }\n    }\n    writeFileSync('/app/encoded_changes.json', JSON.stringify(deploymentMetadata));\n}\n\nfunction readFromPath(filePath) {\n    return JSON.parse(readFileSync(filePath, 'utf-8'));\n}",
                    "copado__Type__c": "Standard",
                    "Id": "a0l7Q000000MDYyQAO",
                    "LastReferencedDate": "2022-09-16T10:59:41.000+0000",
                    "LastViewedDate": "2022-09-16T10:59:41.000+0000",
                    "Name": "Encode File Names"
                },
                {
                    "attributes": {
                        "type": "copado__Function__c",
                        "url": "/services/data/v56.0/sobjects/copado__Function__c/a0l7Q000000iAiOQAU"
                    },
                    "copado__API_Name__c": "sfdx_package_version_publish",
                    "copado__Description__c": "To publish the package version",
                    "copado__Image_Name__c": "copado-multicloud-dx:v3",
                    "copado__Options__c": "[ ]",
                    "copado__Parameters__c": "[ {\n  \"required\" : true,\n  \"name\" : \"versionDetails\",\n  \"defaultValue\" : \"{$Job.PrevStep.Result__r.Result_Data__c}\"\n}, {\n  \"required\" : true,\n  \"name\" : \"sessionId\",\n  \"defaultValue\" : \"{$Destination.Credential.SessionId}\"\n}, {\n  \"required\" : true,\n  \"name\" : \"endpoint\",\n  \"defaultValue\" : \"{$Destination.Credential.Endpoint}\"\n} ]",
                    "copado__Script__c": "#!/usr/bin/env node\n'use strict';\n\nconst { execSync } = require('child_process'),\n    { versionDetails, endpoint, sessionId, isTest } = process.env,\n    { subscriberId, apiVersion } = JSON.parse(versionDetails),\n    CHECK_LOG = 'Please check logs for more details',\n    TEMP_DIRECTORY = 'temp';\n\n// SCRIPT FUNCTIONS\n\nfunction execute() {\n    try {\n        endpoint && this.setInstanceURL(endpoint);\n        this.createSFDXProject(TEMP_DIRECTORY);\n        this.handlePromotionResponse(this.promotePackageVersion(subscriberId, sessionId, apiVersion, TEMP_DIRECTORY));\n\n        execSync(`\n            copado -p 'Package \"${subscriberId}\" promoted successfully'\n            copado -p 'Updating Results' -r ${subscriberId}`);\n    } catch (err) {\n        //Error status = 3, is when we have Custom Error Message, where error is already populated on result and hence we do not need to call it again.\n        if (err?.status === 3) {\n            process.exit(1);\n        }\n        execSync(this.showError(err?.toString()));\n    }\n}\n\nfunction setInstanceURL(endpoint) {\n    const url = endpoint.substring(0, endpoint.indexOf('/', endpoint.indexOf('/') + 2));\n    execSync(`\n        copado -p 'Setting instance url'\n        sfdx force:config:set instanceUrl=\"${url}\" --global || (${this.showError(`Error setting instance URL, ${CHECK_LOG}`)})\n    `);\n}\n\nfunction showError(error) {\n    const refinedErrorMsg = this.maskSensitiveInformation(error);\n    return `copado -p 'Error' -e ${JSON.stringify(refinedErrorMsg).replace(/\\\\n/g, '\\n')} ${isTest ? '' : ' && exit 3'}`;\n}\n\nfunction createSFDXProject(directory) {\n    execSync(`\n        copado -p 'Creating Temp Project'\n        sfdx force:project:create -n ${directory} || (${this.showError(`Error creating SFDX project, ${CHECK_LOG}`)})\n    `);\n}\n\nfunction promotePackageVersion(subscriberId, sessionId, apiVersion, directory) {\n    const promoteCmd = `sfdx force:package:version:promote -p ${subscriberId} -v ${sessionId} ${\n        apiVersion ? `--apiversion ${apiVersion}` : ''\n    } -n --json || true`;\n    this.logger(`Package Version Promotion Command ==> ${promoteCmd}`);\n\n    return JSON.parse(\n        execSync(`\n        copado -p 'Promoting package ${subscriberId}'\n        cd ${directory} || exit 1\n        ${promoteCmd}\n    `).toString()\n    );\n}\n\nfunction handlePromotionResponse(response) {\n    this.logger(`Package Version Promotion Response ==> ${JSON.stringify(response)}`);\n    if (response.status) {\n        throw `${response.message ? response.message : ''} ${CHECK_LOG}`;\n    }\n}\n\nfunction logger(text) {\n    console.log(text);\n}\n\nfunction maskSensitiveInformation(data) {\n    const sensitiveInfo = ['--targetdevhubusername', '-u', '-v'],\n        maskingSequence = '*****';\n\n    const arrayOfData = data.split(' ');\n    sensitiveInfo.forEach((subString) => {\n        const keyIndex = arrayOfData.indexOf(subString);\n        if (keyIndex > -1) {\n            arrayOfData[keyIndex + 1] = maskingSequence;\n            data = arrayOfData.join(' ');\n        }\n    });\n    return data;\n}\n\nmodule.exports.execute = execute;\nmodule.exports.logger = logger;\nmodule.exports.handlePromotionResponse = handlePromotionResponse;\nmodule.exports.promotePackageVersion = promotePackageVersion;\nmodule.exports.createSFDXProject = createSFDXProject;\nmodule.exports.showError = showError;\nmodule.exports.setInstanceURL = setInstanceURL;\nmodule.exports.maskSensitiveInformation = maskSensitiveInformation;\n\n// EXECUTION\n\n!isTest && this.execute();",
                    "copado__Type__c": "Standard",
                    "copado__Version__c": "1.0",
                    "Id": "a0l7Q000000iAiOQAU",
                    "LastReferencedDate": "2023-01-19T12:10:29.000+0000",
                    "LastViewedDate": "2023-01-19T12:10:29.000+0000",
                    "Name": "Sfdx Package Version Publish"
                },
                {
                    "attributes": {
                        "type": "copado__Function__c",
                        "url": "/services/data/v56.0/sobjects/copado__Function__c/a0l7Q000000iAiPQAU"
                    },
                    "copado__API_Name__c": "SFDX_Package_Version_Update",
                    "copado__Description__c": "Updates package version",
                    "copado__Image_Name__c": "copado-multicloud-dx:v3",
                    "copado__Options__c": "[ ]",
                    "copado__Parameters__c": "[ {\n  \"required\" : true,\n  \"name\" : \"devhubSession\",\n  \"defaultValue\" : \"{$Context.Credential.SessionId}\"\n}, {\n  \"required\" : true,\n  \"name\" : \"devhubEndpoint\",\n  \"defaultValue\" : \"{$Context.Credential.Endpoint}\"\n}, {\n  \"required\" : false,\n  \"name\" : \"packageVersion\",\n  \"defaultValue\" : \"{$Context.JobExecution__r.DataJson.packageVersion}\"\n}, {\n  \"name\" : \"installationKey\",\n  \"defaultValue\" : \"{$Context.JobExecution__r.DataJson.installationKey}\"\n}, {\n  \"name\" : \"apiVersion\",\n  \"defaultValue\" : \"{$Context.JobExecution__r.DataJson.apiVersion}\"\n} ]",
                    "copado__Script__c": "#!/usr/bin/env node\n'use strict';\nconst { execSync } = require('child_process'),\n    { devhubEndpoint, devhubSession, installationKey, apiVersion, isTest } = process.env,\n    baseUrl = devhubEndpoint.substring(0, devhubEndpoint.indexOf('/', devhubEndpoint.indexOf('/') + 2)),\n    packageVersion = JSON.parse(process.env.packageVersion),\n    CHECK_LOG = 'Please check the logs for details',\n    TEMP_DIRECTORY = 'temp';\n\n//SCRIPT FUNCTIONS\n\nfunction execute() {\n    try {\n        this.createSFDXProject(TEMP_DIRECTORY);\n        this.setInstanceURL(baseUrl);\n\n        const flags = this.buildParameters({\n            targetdevhubusername: devhubSession,\n            package: packageVersion.copado__Subscriber_Version_Id__c,\n            versionname: packageVersion.copado__Version_Name__c,\n            versiondescription: packageVersion.copado__Version_Description__c,\n            branch: packageVersion.copado__Branch__c,\n            tag: packageVersion.copado__Tag__c,\n            installationkey: installationKey,\n            apiversion: apiVersion\n        });\n\n        this.handleVersionPromotionResponse(this.updatePackageVersion(flags));\n        this.updateResult(packageVersion);\n    } catch (error) {\n        //Error status = 3, is when we have Custom Error Message, where error is already populated on result and hence we do not need to call it again.\n        if (error?.status === 3) {\n            process.exit(1);\n        }\n        execSync(this.showError(error.toString()));\n    }\n}\n\nfunction updateResult(packageVersion) {\n    const updateResultCmd = `copado -p 'Updating result' -r ${JSON.stringify(\n        JSON.stringify({\n            packageVersion\n        })\n    )}`;\n    //escaping special characters here, so it can be used in payload\n    execSync(this.escapeSpecialCharacters(updateResultCmd));\n}\n\nfunction buildParameters(flags) {\n    return Object.entries(flags).reduce((parameters, [key, value]) => {\n        return parameters + (value ? ` --${key} \"${value}\"` : '');\n    }, '');\n}\n\nfunction setInstanceURL(url) {\n    execSync(`\n        sfdx -v\n        copado -p 'Setting instance url'\n        sfdx force:config:set instanceUrl=${url} || (${this.showError(`Error setting instance URL, ${CHECK_LOG}`)})\n    `);\n}\n\nfunction createSFDXProject(directory) {\n    execSync(`\n        copado -p 'Creating Temp Project'\n        sfdx force:project:create -n ${directory} || (${this.showError(`Error creating SFDX project, ${CHECK_LOG}`)})\n    `);\n\n    process.chdir(directory);\n}\n\nfunction showError(error) {\n    const refinedErrorMsg = this.maskSensitiveInformation(error, { '--targetdevhubusername': devhubSession });\n    return `copado -p 'Error' -e ${this.escapeSpecialCharacters(JSON.stringify(refinedErrorMsg)).replace(/\\\\n/g, '\\n')}  ${\n        isTest ? '' : ' && exit 3'\n    }`;\n}\n\nfunction updatePackageVersion(parameters) {\n    const updateCmd = `\n        copado -p 'Updating package version'\n        sfdx force:package:version:update ${parameters} --json || true\n    `;\n\n    const logMessage = `Package Version Update Command ==> sfdx force:package:version:update ${parameters} --json`;\n    this.logger(installationKey ? maskSensitiveInformation(logMessage, { '--installationkey': installationKey }) : logMessage);\n\n    //escaping special characters here, so it can be used in payload\n    return JSON.parse(execSync(this.escapeSpecialCharacters(updateCmd)).toString());\n}\n\nfunction handleVersionPromotionResponse(response) {\n    this.logger(`Package Version Update Response ==> ${JSON.stringify(response)}`);\n    if (response.status) {\n        execSync(this.showError(`Package Version Update failed. ${response.message}, ${CHECK_LOG}`));\n    }\n}\n\nfunction escapeSpecialCharacters(text) {\n    return text.replace(/`/g, '\\\\`').replace(/\\$/g, '\\\\$');\n}\n\nfunction logger(text) {\n    console.log(text);\n}\n\nfunction maskSensitiveInformation(data, sensitiveFlags) {\n    const maskingSequence = '*****';\n\n    const arrayOfData = data.split(' ');\n    Object.keys(sensitiveFlags).forEach((subStr) => {\n        const keyIndex = arrayOfData.indexOf(subStr);\n        if (keyIndex > -1) {\n            arrayOfData[keyIndex + 1] = maskingSequence;\n            arrayOfData.splice(keyIndex + 2, sensitiveFlags[subStr].split(' ').length - 1);\n        }\n    });\n    return arrayOfData.join(' ');\n}\n\nmodule.exports.execute = execute;\nmodule.exports.updateResult = updateResult;\nmodule.exports.buildParameters = buildParameters;\nmodule.exports.setInstanceURL = setInstanceURL;\nmodule.exports.createSFDXProject = createSFDXProject;\nmodule.exports.showError = showError;\nmodule.exports.updatePackageVersion = updatePackageVersion;\nmodule.exports.handleVersionPromotionResponse = handleVersionPromotionResponse;\nmodule.exports.escapeSpecialCharacters = escapeSpecialCharacters;\nmodule.exports.logger = logger;\nmodule.exports.maskSensitiveInformation = maskSensitiveInformation;\n\n// EXECUTION\n\n!isTest && this.execute();",
                    "copado__Type__c": "Standard",
                    "copado__Version__c": "1",
                    "Id": "a0l7Q000000iAiPQAU",
                    "LastReferencedDate": "2022-10-06T09:24:14.000+0000",
                    "LastViewedDate": "2022-10-06T09:24:14.000+0000",
                    "Name": "SFDX Package Version Update"
                },
                {
                    "attributes": {
                        "type": "copado__Function__c",
                        "url": "/services/data/v56.0/sobjects/copado__Function__c/a0l7Q000000iAiQQAU"
                    },
                    "copado__API_Name__c": "SFDX_Package_Version_Create",
                    "copado__Description__c": "Create a package version record",
                    "copado__Image_Name__c": "copado-multicloud-dx:v3",
                    "copado__Options__c": "[ ]",
                    "copado__Parameters__c": "[ {\n  \"required\" : true,\n  \"name\" : \"endPoint\",\n  \"defaultValue\" : \"{$Destination.Credential.Endpoint}\"\n}, {\n  \"required\" : true,\n  \"name\" : \"session\",\n  \"defaultValue\" : \"{$Destination.Credential.SessionId}\"\n}, {\n  \"required\" : false,\n  \"name\" : \"packageId\",\n  \"defaultValue\" : \"\"\n}, {\n  \"name\" : \"versionName\",\n  \"defaultValue\" : \"\"\n}, {\n  \"name\" : \"versionNumber\",\n  \"defaultValue\" : \"\"\n}, {\n  \"name\" : \"description\",\n  \"defaultValue\" : \"\"\n}, {\n  \"required\" : false,\n  \"name\" : \"jsonInformation\",\n  \"defaultValue\" : \"\"\n}, {\n  \"required\" : true,\n  \"name\" : \"git_json\",\n  \"defaultValue\" : \"{$Context.Repository.Credential}\"\n}, {\n  \"name\" : \"gitName\",\n  \"defaultValue\" : \"{$User.Name}\"\n}, {\n  \"name\" : \"gitEmail\",\n  \"defaultValue\" : \"{$User.Email}\"\n}, {\n  \"name\" : \"pollInterval\",\n  \"defaultValue\" : \"{$Property.sfdx_package_version_create_poll_time_in_seconds}\"\n}, {\n  \"name\" : \"retrialTimes\",\n  \"defaultValue\" : \"{$Property.sfdx_package_version_create_retrial_number}\"\n} ]",
                    "copado__Script__c": "#!/usr/bin/env node\n\nconst { mkdirSync, readFileSync, writeFileSync } = require('fs'),\n    { execSync } = require('child_process'),\n    { packageId, versionName, versionNumber, description, endPoint, session, gitEmail, gitName, retrialTimes, pollInterval } = process.env,\n    params = JSON.parse(\n        process?.env['jsonInformation']\n            .replace(/(\\\\r\\\\n|\\\\r|\\\\n)/g, '')\n            .replace(/\\\\\"/g, '\"')\n            .replace(/\\\\\\\\/g, '\\\\')\n    ),\n    checkLog = 'Please check the logs for details',\n    baseUrl = endPoint?.substring(0, endPoint?.indexOf('/', endPoint?.indexOf('/') + 2)),\n    fetchReportRetrialTimes = retrialTimes ? parseInt(retrialTimes) : 10,\n    pollIntervalInSec = pollInterval ? parseInt(pollInterval) : 30;\nparams.tag = params.tag ? stripTag(params.tag) : '';\nconst {\n        branch,\n        tag,\n        loglevel,\n        apiversion,\n        path,\n        definitionfile,\n        installationkey,\n        installationkeybypass,\n        codecoverage,\n        releasenotesurl,\n        postinstallurl,\n        postinstallscript,\n        uninstallscript,\n        skipvalidation\n    } = params,\n    ERROR_LIMIT = 32760;\n\n// EXECUTION\nexecute();\n\nfunction execute() {\n    try {\n        mkdirSync('sfProject');\n        process.chdir('sfProject');\n\n        cloneRepo();\n        setInstanceURL();\n        configureGit();\n        updatePackageVersion(createPackageVersion());\n    } catch (err) {\n        //Error status = 3, is when we have Custom Error Message, where error is already populated on result and hence we do not need to call it again.\n        if (err?.status === 3) {\n            process.exit(1);\n        }\n        execSync(`${getErrorCmd(err.toString())}`);\n    }\n}\n\n// SCRIPT FUNCTIONS\nfunction updatePackageVersion(response) {\n    if (!response.status) {\n        const requestId = response?.result?.Id;\n        pollPackageVersionCreateRequest(requestId, 0)\n            .then(({ data, alias }) => {\n                commit();\n\n                updateTagBranchDetails(data?.result[0]?.SubscriberPackageVersionId, alias);\n                setProgressStatus({\n                    progressStatus: 'Package version created successfully',\n                    resultData: JSON.stringify(getLatestVersion(data?.result[0]?.SubscriberPackageVersionId))\n                });\n            })\n            .catch(function (error) {\n                setProgressStatus({\n                    progressStatus: 'Package Version creation failed',\n                    errorMessage: `Could not create package. ${error}`\n                });\n            });\n    } else if (response.status) {\n        setProgressStatus({ progressStatus: 'Package Version creation failed', errorMessage: `Could not create package. ${response.message}` });\n    }\n}\n\nfunction getLatestVersion(pkgVersionId) {\n    const versionList = execSync(`sfdx force:package:version:list -v ${session} -p ${packageId} --verbose --json`).toString();\n    return JSON.parse(versionList)?.result?.find((version) => version.SubscriberPackageVersionId === pkgVersionId);\n}\n\nfunction createPackageVersion() {\n    const parameters = buildParameters({\n        loglevel,\n        targetdevhubusername: session,\n        apiversion,\n        package: packageId,\n        path,\n        branch,\n        definitionfile,\n        tag,\n        installationkey,\n        installationkeybypass,\n        versionname: versionName,\n        versionnumber: versionNumber,\n        versiondescription: description,\n        codecoverage,\n        releasenotesurl,\n        postinstallurl,\n        postinstallscript,\n        uninstallscript,\n        skipvalidation\n    });\n\n    const logMessage = `Package Version Create Command ==> sfdx force:package:version:create ${parameters} --json`;\n    logger(installationkey ? maskSensitiveInformation(logMessage, { '--installationkey': installationkey }) : logMessage);\n\n    const versionCreateCmd = `\n        copado -p 'Creating package version'\n        sfdx force:package:version:create ${parameters} --json || true\n    `;\n\n    const response = execSync(escapeSpecialCharacters(versionCreateCmd)).toString();\n    logger(`Package Version Create Response ==> ${response}`);\n    return JSON.parse(response);\n}\n\nfunction pollPackageVersionCreateRequest(requestId, counter) {\n    return new Promise(function (resolve, reject) {\n        let timerId = setTimeout(function poll() {\n            const result = execSync(`sfdx force:package:version:create:report -i ${requestId} -v ${session} --json || true`);\n            const data = JSON.parse(result);\n\n            if (!data?.status && data?.result && data?.result[0]?.Status == 'Success') {\n                const alias = updateSFProjectFile(data.result[0]);\n\n                resolve({ data, alias });\n            } else if (data.status && data.message) {\n                counter++;\n\n                if (counter <= fetchReportRetrialTimes) {\n                    logger(`Retrying attempt ${counter} to get status of Package Version creation request: ${requestId}`);\n                    timerId = poll();\n                } else {\n                    reject(data?.message);\n                }\n            } else if (data.result && data.result[0]?.Status == 'Error') {\n                reject(data.result[0]?.Error);\n            } else {\n                timerId = poll();\n            }\n        }, pollIntervalInSec * 1000);\n    });\n}\n\nfunction updateSFProjectFile(data) {\n    const sfProjectFile = readProjectJson();\n    const packageAliases = sfProjectFile?.packageAliases;\n\n    const pkgVersionInfo = getVersionInfo(data?.SubscriberPackageVersionId);\n    const alias = getVersionAlias(packageAliases, data?.Package2Id, pkgVersionInfo);\n\n    packageAliases[alias] = data?.SubscriberPackageVersionId;\n\n    writeFileSync('sfdx-project.json', JSON.stringify(sfProjectFile, null, 2));\n    logger('sfdx-project.json file updated with subscriber package version Id');\n    return alias;\n}\n\nfunction getVersionInfo(versionId) {\n    const query = `SELECT Branch, MajorVersion, MinorVersion, PatchVersion, BuildNumber FROM Package2Version WHERE SubscriberPackageVersionId='${versionId}'`;\n    const response = execSync(`sfdx force:data:soql:query -t -q \"${query}\" -u ${session} --json`);\n    const parsedResponse = JSON.parse(response);\n\n    if (parsedResponse?.status || !parsedResponse?.result?.records[0])\n        setProgressStatus({\n            progressStatus: 'Error in updating sfdx-project.json file. Version Information not found',\n            errorMessage: `Could not create package. ${error}`\n        });\n    return parsedResponse.result.records[0];\n}\n\nfunction createTag(tag) {\n    execSync(\n        `\n        git tag '${tag}' HEAD ||\n            (${getErrorCmd(`Error creating tag '${tag}' in git, ${checkLog}`)})\n    `,\n        { stdio: 'inherit' }\n    );\n}\n\nfunction deleteTag(tag) {\n    let tagForDeletion = escapeCharactersForTagDeletion(tag);\n    execSync(\n        `git push --delete origin refs/tags/${tagForDeletion} || (${getErrorCmd(\n            `Error deleting existing tag ${tagForDeletion} in git, ${checkLog}`\n        )})`,\n        { stdio: 'inherit' }\n    );\n}\n\nfunction escapeCharactersForTagDeletion(tag) {\n    return tag\n        .replace(/`/g, '\\\\`')\n        .replace(/\\$/g, '\\\\$')\n        .replace(/\\\"/g, '\\\\\"')\n        .replace(/\\'/g, \"\\\\'\")\n        .replace(/\\(/g, '\\\\(')\n        .replace(/\\)/g, '\\\\)')\n        .replace(/\\|/g, '\\\\|')\n        .replace(/</g, '\\\\<')\n        .replace(/>/g, '\\\\>')\n        .replace(/#/g, '\\\\#')\n        .replace(/&/g, '\\\\&')\n        .replace(/\\\\\"/g, '\"');\n}\n\nfunction commit() {\n    execSync(\n        `\n        git add 'sfdx-project.json' || exit 1\n        git commit -m 'Committing sfdx-project.json' || exit 1\n    `,\n        { stdio: 'inherit' }\n    );\n}\n\nfunction pushTagAndBranchChanges(branch, tag) {\n    if (branch) {\n        execSync(`git push origin ${branch} || (${getErrorCmd(`Error pushing changes in git, ${checkLog}`)})`, { stdio: 'inherit' });\n    }\n    if (tag) {\n        execSync(`git push origin '${tag}' || (${getErrorCmd(`Error pushing changes in git, ${checkLog}`)})`, { stdio: 'inherit' });\n    }\n}\n\nfunction cloneRepo() {\n    execSync(\n        `\n    copado -p 'Cloning git repository'\n    copado-git-get ${branch} || (${getErrorCmd(`Error check out branch, ${checkLog}`)})\n  `,\n        { stdio: 'inherit' }\n    );\n}\n\nfunction setInstanceURL() {\n    execSync(\n        `\n    copado -p 'Setting instance url'\n    sfdx force:config:set instanceUrl=${baseUrl} --global || (${getErrorCmd(`Error setting instance URL, ${checkLog}`)})\n  `,\n        { stdio: 'inherit' }\n    );\n}\n\nfunction setProgressStatus({ progressStatus, errorMessage, resultData }) {\n    let escapedData = resultData ? JSON.stringify(resultData).replace(/`/g, '\\\\`').replace(/\\$/g, '\\\\$') : '';\n\n    let truncatedError = truncateError(errorMessage);\n\n    const resultUpdateCmd = `copado -p '${progressStatus}' ${errorMessage ? `-e \"${truncatedError}\" && exit 3` : ''} ${\n        resultData ? `-r ${escapedData}` : ''\n    }`;\n\n    execSync(resultUpdateCmd);\n}\n\nfunction truncateError(errorMessage) {\n    return errorMessage?.length > ERROR_LIMIT ? errorMessage.substring(0, ERROR_LIMIT) + '...' : errorMessage;\n}\n\nfunction getErrorCmd(error) {\n    let refinedErrorMsg = maskSensitiveInformation(error, { '--targetdevhubusername': session });\n    return `copado -p 'Error' -e ${escapeSpecialCharacters(JSON.stringify(refinedErrorMsg)).replace(/\\\\n/g, '\\n').replace(/\\\\t/g, '\\t')} && exit 3`;\n}\n\nfunction readProjectJson() {\n    return JSON.parse(readFileSync('sfdx-project.json', 'utf-8'));\n}\n\nfunction getVersionAlias(object, value, pkgVersionInfo) {\n    let packageName = Object.keys(object).find((key) => object[key] === value);\n    if (!packageName) {\n        const response = execSync(`sfdx force:data:soql:query -t -q \"SELECT Name FROM Package2 WHERE Id='${value}'\" -u ${session} --json`);\n        packageName = JSON.parse(response).result.records[0].Name;\n    }\n    return `${packageName}@${pkgVersionInfo.MajorVersion}.${pkgVersionInfo.MinorVersion}.${pkgVersionInfo.PatchVersion}-${pkgVersionInfo.BuildNumber}-${pkgVersionInfo.Branch}`;\n}\n\nfunction updateTagBranchDetails(subscriberVersionId, alias) {\n    const gitTag = tag ? tag : stripTag(alias);\n    let isTagExist = false;\n\n    if (tag) {\n        const remoteTags = execSync(`git ls-remote --tags --refs origin`).toString();\n        isTagExist = remoteTags\n            .split('\\n')\n            .map((step) => step.substring(step.indexOf('refs/tags/') + 10, step.length))\n            .includes(gitTag.replace(/\\\\\"/g, '\"'));\n    }\n\n    if (isTagExist) {\n        deleteTag(gitTag);\n    }\n\n    const escapedGitTag = escapeCharactersForTagCreation(gitTag);\n    createTag(escapedGitTag);\n\n    if (!tag) {\n        const response = updatePackageVersionTag(session, escapedGitTag, subscriberVersionId);\n        if (response.status) {\n            setProgressStatus({ progressStatus: 'Package Version tag update failed', errorMessage: response.message });\n        } else {\n            setProgressStatus({ progressStatus: `Package Version tag updated to ${escapedGitTag}` });\n        }\n    }\n\n    pushTagAndBranchChanges(branch, escapedGitTag);\n}\n\nfunction updatePackageVersionTag(devhubSession, tag, subscriberVersionId) {\n    const parameters = buildParameters({\n        targetdevhubusername: devhubSession,\n        package: subscriberVersionId,\n        tag: tag\n    });\n    const updateCmd = `\n        copado -p 'Updating package version'\n        sfdx force:package:version:update ${parameters} --json || true\n    `;\n    const response = execSync(updateCmd).toString();\n    logger(`Package Version Update Response ==> ${response}`);\n    return JSON.parse(response);\n}\n\nfunction buildParameters(flags) {\n    return Object.entries(flags).reduce((parameters, [key, value]) => {\n        return parameters + (typeof value == 'boolean' ? (value ? ` --${key}` : '') : value ? ` --${key} \"${value}\"` : '');\n    }, '');\n}\n\nfunction escapeCharactersForTagCreation(text) {\n    return text.replace(/\\\\\"/g, '\"').replace(/'/g, \"'\\\\''\").replace(/[|]/g, \"'\\\\|'\");\n}\n\nfunction escapeSpecialCharacters(text) {\n    let result = text.replace(/`/g, '\\\\`').replace(/\\$/g, '\\\\$');\n\n    return result;\n}\n\nfunction stripTag(tag) {\n    //removing ascii characters below 20hex, mentioned sequences, and a few characters such as (?*[~^\\*:)\n    return tag\n        .replace(/[\\u0000-\\u0020]/g, '')\n        .replace(/[~^:?*[\\\\]/g, '')\n        .replace(/(\\/\\/)/g, '')\n        .replace(/(\\.\\.)/g, '')\n        .replace(/(@{)/g, '')\n        .replace(/(\\/\\.)/g, '')\n        .replace(/^[\\/]/g, '')\n        .replace(/(\\.lock)$/g, '')\n        .replace(/[\\/\\.]$/g, '')\n        .replace(/(\\.\\/$)/g, '')\n        .replace(/\\\"/g, '\\\\\"');\n}\n\nfunction logger(text) {\n    console.log(text);\n}\n\nfunction configureGit() {\n    execSync(\n        `\n        git config --local user.email \"${gitEmail}\" || exit 1\n        git config --local user.name \"${gitName}\" || exit 1`,\n        { stdio: 'inherit' }\n    );\n}\n\nfunction maskSensitiveInformation(data, sensitiveFlags) {\n    const maskingSequence = '*****';\n\n    const arrayOfData = data.split(' ');\n    Object.keys(sensitiveFlags).forEach((subStr) => {\n        const keyIndex = arrayOfData.indexOf(subStr);\n        if (keyIndex > -1) {\n            arrayOfData[keyIndex + 1] = maskingSequence;\n            arrayOfData.splice(keyIndex + 2, sensitiveFlags[subStr].split(' ').length - 1);\n        }\n    });\n    return arrayOfData.join(' ');\n}",
                    "copado__Type__c": "Standard",
                    "copado__Version__c": "1",
                    "Id": "a0l7Q000000iAiQQAU",
                    "LastReferencedDate": "2022-10-17T09:29:23.000+0000",
                    "LastViewedDate": "2022-10-17T09:29:23.000+0000",
                    "Name": "SFDX Package Version Create"
                },
                {
                    "attributes": {
                        "type": "copado__Function__c",
                        "url": "/services/data/v56.0/sobjects/copado__Function__c/a0l7Q000000iAiRQAU"
                    },
                    "copado__API_Name__c": "SFDX_Get_Package_Version_Dependencies",
                    "copado__Image_Name__c": "copado-multicloud-dx:v3",
                    "copado__Options__c": "[ ]",
                    "copado__Parameters__c": "[ {\n  \"required\" : true,\n  \"name\" : \"endpoint\",\n  \"defaultValue\" : \"{$Source.Credential.Endpoint}\"\n}, {\n  \"required\" : true,\n  \"name\" : \"session\",\n  \"defaultValue\" : \"{$Source.Credential.SessionId}\"\n}, {\n  \"required\" : true,\n  \"name\" : \"subscriberVersionId\",\n  \"defaultValue\" : \"{$Context.JobExecution__r.DataJson.subscriberId}\"\n}, {\n  \"required\" : false,\n  \"name\" : \"installationKey\",\n  \"defaultValue\" : \"{$Context.JobExecution__r.DataJson.installationKey}\"\n} ]",
                    "copado__Script__c": "#!/usr/bin/env node\nconst { execSync } = require('child_process'),\n    { endpoint, session, subscriberVersionId, installationKey } = process.env,\n    baseUrl = endpoint.substring(0, endpoint.indexOf('/', endpoint.indexOf('/') + 2)),\n    checkLog = 'Please check the logs for details';\n\n// EXECUTON\n\nexecute();\n\nfunction execute() {\n    try {\n        setInstanceURL();\n        const dependencies = getVersionDependencies();\n        handleDependenciesResponse(dependencies);\n    } catch (err) {\n        //Error status = 3, is when we have Custom Error Message, where error is already populated on result and hence we do not need to call it again.\n        if (err?.status === 3) {\n            process.exit(1);\n        }\n        execSync(`${getErrorCmd(err.toString())}`);\n    }\n}\n\n// SCRIPT FUNCTIONS\n\nfunction setInstanceURL() {\n    execSync(\n        `\n\t  copado -p 'Setting instance url'\n\t  sfdx force:config:set instanceUrl=${baseUrl} --global || (${getErrorCmd(`Error setting instance URL, ${checkLog}`)})\n\t`,\n        { stdio: 'inherit' }\n    );\n}\n\nfunction getVersionDependencies() {\n    const query = `SELECT MajorVersion, MinorVersion, PatchVersion, BuildNumber, SubscriberPackageId, Dependencies FROM SubscriberPackageVersion WHERE Id='${subscriberVersionId}' ${addFilter()}`;\n\n    const logMessage = `SubscriberPackageVersion Query From Devhub  ==> ${query}`;\n    logger(installationKey ? maskSensitiveInformation(logMessage, { 'InstallationKey=': installationKey }) : logMessage);\n\n    const result = execSync(`\n\t\t\tcopado -p 'Getting dependencies'\n\t\t\tsfdx force:data:soql:query -t -q \"${query}\" -u ${session} --json || true\n\t\t`).toString();\n    logger(`SubscriberPackageVersion Tooling API Response ==> ${JSON.stringify(result)}`);\n\n    return JSON.parse(result);\n}\n\nfunction getErrorCmd(error) {\n    const refinedErrorMsg = installationKey\n        ? maskSensitiveInformation(error, { '-u': session, 'InstallationKey=': installationKey })\n        : maskSensitiveInformation(error, { '-u': session });\n    return `copado -p 'Error' -e ${JSON.stringify(refinedErrorMsg).replace(/\\\\n/g, '\\n').replace(/\\\\t/g, '\\t')} && exit 3`;\n}\n\nfunction addFilter() {\n    return installationKey ? `AND InstallationKey= '${installationKey}'` : '';\n}\n\nfunction handleDependenciesResponse(response) {\n    let updateResult;\n    if (!response.status) {\n        const apiResponse = response?.result?.totalSize && response?.result?.records[0];\n        const result = getResult(apiResponse);\n\n        updateResult = `copado -p 'Updating dependencies' -r '${JSON.stringify(result)}'`;\n    } else {\n        updateResult = getErrorCmd(`${response.name}: ${response.message}`);\n    }\n    if (updateResult) {\n        execSync(updateResult, {\n            stdio: 'inherit'\n        });\n    }\n}\n\nfunction logger(text) {\n    console.log(text);\n}\n\nfunction mapDependencies(response) {\n    let dependencies = [];\n    if (response?.Dependencies?.ids?.length) {\n        dependencies = response.Dependencies.ids.map((dependency) => dependency.subscriberPackageVersionId);\n    }\n    return dependencies;\n}\n\nfunction getResult(apiResponse) {\n    return {\n        subscriberVersionId: subscriberVersionId,\n        dependencies: apiResponse && mapDependencies(apiResponse),\n        versionNumber:\n            apiResponse && `${apiResponse.MajorVersion}.${apiResponse.MinorVersion}.${apiResponse.PatchVersion}.${apiResponse.BuildNumber}`,\n        subscriberPackageId: apiResponse && apiResponse.SubscriberPackageId\n    };\n}\n\nfunction maskSensitiveInformation(data, sensitiveFlags) {\n    const maskingSequence = '*****';\n\n    const arrayOfData = data.split(' ');\n    Object.keys(sensitiveFlags).forEach((subStr) => {\n        const keyIndex = arrayOfData.indexOf(subStr);\n        if (keyIndex > -1) {\n            arrayOfData[keyIndex + 1] = maskingSequence;\n            arrayOfData.splice(keyIndex + 2, sensitiveFlags[subStr].split(' ').length - 1);\n        }\n    });\n    return arrayOfData.join(' ');\n}",
                    "copado__Type__c": "Standard",
                    "copado__Worker_Size__c": "S",
                    "Id": "a0l7Q000000iAiRQAU",
                    "LastReferencedDate": "2022-11-15T12:30:28.000+0000",
                    "LastViewedDate": "2022-11-15T12:30:28.000+0000",
                    "Name": "SFDX Get Package Version Dependencies"
                },
                {
                    "attributes": {
                        "type": "copado__Function__c",
                        "url": "/services/data/v55.0/sobjects/copado__Function__c/a0k09000000qQSoAAM"
                    },
                    "copado__API_Name__c": "sfdx_execute_apex",
                    "copado__Description__c": "Run sfdx force:apex:execute to execute Apex Job Steps.",
                    "copado__Image_Name__c": "copado-multicloud-dx:v3",
                    "copado__Options__c": "[ ]",
                    "copado__Parameters__c": "[ {\n  \"required\" : true,\n  \"name\" : \"destination_sessionid\",\n  \"defaultValue\" : \"{$Destination.Credential.SessionId}\"\n}, {\n  \"required\" : true,\n  \"name\" : \"destination_endpoint\",\n  \"defaultValue\" : \"{$Destination.Credential.Endpoint}\"\n}, {\n  \"required\" : false,\n  \"name\" : \"script\"\n}, {\n  \"required\" : true,\n  \"name\" : \"destination_env_var\",\n  \"defaultValue\" : \"{$Destination.apex.EnvironmentVariables}\"\n}, {\n  \"required\" : true,\n  \"name\" : \"isValidation\",\n  \"defaultValue\" : \"{$Context.JobExecution__r.DataJson.deploymentDryRun}\"\n} ]",
                    "copado__Script__c": "#!/usr/bin/env node\n/**\n * Performs execution of apex script using sfdx cli command.\n * @param destination_sessionid\n * @param destination_endpoint\n * @param script\n * @param destination_env_var\n * @param isValidation\n */\n\nconst fs = require(\"fs\"),\n  { execSync } = require(\"child_process\"),\n  { destination_sessionid, destination_endpoint, script, destination_env_var, isValidation } = process.env,\n  destination_base_url = getBaseUrl(destination_endpoint),\n  scriptName = \"script.apex\",\n  validationModeMessage = \"This step will not be executed for validate changes\";\n\n// EXECUTION\n\ntry {\n  validateExecutionMode();\n  setup();\n  executeApexScript();\n} catch (error) {\n  logError(error);\n}\n\n// FUNCTIONS\n\nfunction getBaseUrl(endpoint) {\n  return endpoint.substring(\n    0,\n    endpoint.indexOf(\"/\", endpoint.indexOf(\"/\") + 2)\n  );\n}\n\nfunction setup() {\n  const content = script.replace(\"\\\\n\", \" \");\n  fs.writeFileSync(scriptName, content);\n  const cmd = `\n      copado -p \"Replacing environment dependent value\"\n\t  varreplace '${destination_env_var}' '${scriptName}' --valuename=false\n      copado -p 'Connecting to destination environment'\n      sfdx force:config:set instanceUrl=${destination_base_url} --global\n  `;\n  execSync(cmd, { stdio: \"inherit\" });\n}\n\nfunction executeApexScript() {\n  const cmd = `\n        copado -p 'Executing apex script'\n        sfdx force:apex:execute -u ${destination_sessionid} -f '${scriptName}' --json\n  `;\n  const response = execSync(cmd, { maxBuffer: 50 * 1024 * 1024 });\n  validateResponse(response);\n}\n\nfunction validateResponse(response) {\n  if (!response) {\n    throw \"Apex script execution failed\";\n  }\n  const formattedResponse = JSON.parse(response.toString());\n  if (formattedResponse.status != 0) {\n    throw formattedResponse?.message;\n  } else if (!formattedResponse?.result?.compiled || !formattedResponse?.result?.success) {\n    throw `Error occured: \"${JSON.stringify(formattedResponse?.result)}\". Please check logs for more details.`;\n  } else {\n    execSync(`copado -p 'Apex script execution completed successfully'`);\n  }\n}\n\nfunction logError(error) {\n  execSync(`copado -p 'Error' -e \"${error.toString()}\" && exit 1`);\n}\n\nfunction validateExecutionMode() {\n  if(isValidation === 'true') {\n    execSync(`copado -p '${validationModeMessage}' --result-data '${validationModeMessage}'`);\n\tprocess.exit(0);\n  }\n}",
                    "copado__Timeout__c": 60,
                    "copado__Type__c": "Standard",
                    "copado__Version__c": "1",
                    "copado__Worker_Size__c": "M",
                    "Id": "a0k09000000qQSoAAM",
                    "LastReferencedDate": "2022-06-27T07:54:21.000+0000",
                    "LastViewedDate": "2022-06-27T07:54:21.000+0000",
                    "Name": "SFDX Execute Apex"
                },
                {
                    "attributes": {
                        "type": "copado__Function__c",
                        "url": "/services/data/v56.0/sobjects/copado__Function__c/a0l7Q000000iAiTQAU"
                    },
                    "copado__API_Name__c": "SFDXPackageCreate",
                    "copado__Image_Name__c": "copado-multicloud-dx:v3",
                    "copado__Options__c": "[ ]",
                    "copado__Parameters__c": "[ {\n  \"required\" : true,\n  \"name\" : \"devhubEndpoint\",\n  \"defaultValue\" : \"{$Destination.Credential.Endpoint}\"\n}, {\n  \"required\" : true,\n  \"name\" : \"devhubSession\",\n  \"defaultValue\" : \"{$Destination.Credential.SessionId}\"\n}, {\n  \"required\" : false,\n  \"name\" : \"packageName\",\n  \"defaultValue\" : \"\"\n}, {\n  \"name\" : \"path\",\n  \"defaultValue\" : \"\"\n}, {\n  \"name\" : \"jsonInformation\",\n  \"defaultValue\" : \"\"\n}, {\n  \"name\" : \"description\",\n  \"defaultValue\" : \"\"\n}, {\n  \"required\" : true,\n  \"name\" : \"git_json\",\n  \"defaultValue\" : \"{$Context.Repository.Credential}\"\n}, {\n  \"name\" : \"branch\",\n  \"defaultValue\" : \"\"\n}, {\n  \"name\" : \"gitName\",\n  \"defaultValue\" : \"{$User.Name}\"\n}, {\n  \"name\" : \"gitEmail\",\n  \"defaultValue\" : \"{$User.Email}\"\n} ]",
                    "copado__Script__c": "#!/usr/bin/env node\n'use strict';\nconst { mkdirSync, readFileSync } = require('fs'),\n    { execSync } = require('child_process'),\n    { gitEmail, gitName, devhubEndpoint, branch, devhubSession, packageName, path, description, isTest } = process.env,\n    { loglevel, apiversion, packagetype, nonamespace, orgdependent, errornotificationusername, namespaceprefix } = JSON.parse(\n        process.env['jsonInformation']?.replace(/\\\\/g, '')\n    ),\n    baseUrl = devhubEndpoint?.substring(0, devhubEndpoint?.indexOf('/', devhubEndpoint?.indexOf('/') + 2)),\n    DIR_NAME = 'sfProject',\n    CHECK_LOG = 'Please check the logs for details',\n    SFDX_PROJECT_JSON = 'sfdx-project.json';\n\n// SCRIPT FUNCTIONS\n\nfunction execute() {\n    try {\n        this.setupDirectory(DIR_NAME);\n        this.prepareAndCloneRepo(branch);\n        this.setInstanceUrl(baseUrl);\n        this.configureGit(gitEmail, gitName);\n        this.validateNamespace(namespaceprefix, nonamespace);\n        const flags = this.buildParameters({\n            loglevel,\n            targetdevhubusername: devhubSession,\n            apiversion,\n            name: packageName,\n            path,\n            packagetype,\n            nonamespace,\n            orgdependent,\n            description,\n            errornotificationusername\n        });\n        this.createPackage(flags);\n    } catch (err) {\n        //Error status = 3, is when we have Custom Error Message, where error is already populated on result and hence we do not need to call it again.\n        if (err?.status === 3) {\n            process.exit(1);\n        }\n        execSync(`${this.getErrorCmd(err.toString())}`);\n    }\n}\n\nfunction setupDirectory(dirName) {\n    mkdirSync(dirName);\n    process.chdir(dirName);\n}\n\nfunction buildParameters(flags) {\n    return Object.entries(flags).reduce((parameters, [key, value]) => {\n        return parameters + (typeof value == 'boolean' ? (value ? ` --${key}` : '') : value ? ` --${key} \"${value}\"` : '');\n    }, '');\n}\n\nfunction getPackagesList(sessionId) {\n    return JSON.parse(execSync(`sfdx force:package:list -v ${sessionId} --json || true`).toString());\n}\n\nfunction prepareAndCloneRepo(branchName) {\n    execSync(`\n        copado -p 'Cloning git repository'\n        copado-git-get '${branchName}' || (${this.getErrorCmd(`Could not checkout branch ${branchName}, ${CHECK_LOG}`)})\n    `);\n}\n\nfunction setInstanceUrl(baseUrl) {\n    execSync(`\n        copado -p 'Setting instance url'\n        sfdx force:config:set instanceUrl=${baseUrl} --global || (${this.getErrorCmd(`Failed setting an instance URL, ${CHECK_LOG}`)})\n    `);\n}\n\nfunction createPackage(pkgCreateParam) {\n    const createCmd = `sfdx force:package:create ${pkgCreateParam} --json`,\n        createCmdExec = `\n            copado -p 'Creating package'\n            ${createCmd} || true\n            copado -p 'Finishing'\n        `;\n    this.logger(`Package Create Command ==> ${createCmd}`);\n\n    //escaping special characters here, so it can be used in payload\n    const response = JSON.parse(execSync(this.escapeSpecialCharacters(createCmdExec)).toString());\n    this.logger(`Package Create Command Response ==> ${JSON.stringify(response)}`);\n\n    if (!response?.status && response?.result?.Id) {\n        this.commit();\n        const packageId = response.result.Id,\n            packagesDetails = this.getPackagesList(devhubSession);\n\n        if (packagesDetails?.status) {\n            this.setProgressStatus({\n                progressStatus: 'Error',\n                errorMessage: `Error fetching package version list from devhub, ${packagesDetails.message}`\n            });\n        } else {\n            const namespace = packagesDetails.result.find(pkg => pkg.Id === packageId)?.NamespacePrefix,\n                resultData = { packageId: packageId, namespace: namespace ? namespace : '' };\n            this.setProgressStatus({ progressStatus: 'Package created successfully', resultData: JSON.stringify(resultData) });\n        }\n    } else {\n        this.setProgressStatus({\n            progressStatus: 'Package creation failed',\n            errorMessage: `Could not create package, ${response.message}`\n        });\n    }\n}\n\nfunction commit() {\n    execSync(\n        `\n        git add '${SFDX_PROJECT_JSON}' || (${this.getErrorCmd(`Error adding git change, ${CHECK_LOG}`)})\n        git commit -m 'Committing sfdx-project.json' || (${this.getErrorCmd(`Error commiting git change, ${CHECK_LOG}`)})\n        git push origin ${branch} || (${this.getErrorCmd(`Error pushing changes in git, ${CHECK_LOG}`)})`,\n        { stdio: 'inherit' }\n    );\n}\n\nfunction setProgressStatus({ progressStatus, errorMessage, resultData }) {\n    execSync(`copado -p '${progressStatus}' ${errorMessage ? `-e '${errorMessage}'` : ''} ${resultData ? `-r '${resultData}'` : ''}`);\n    if (errorMessage) {\n        throw errorMessage;\n    }\n}\n\nfunction getErrorCmd(error) {\n    const refinedErrorMsg = this.maskSensitiveInformation(error);\n    return `copado -p 'Error' -e ${this.escapeSpecialCharacters(JSON.stringify(refinedErrorMsg).replace(/\\\\n/g, '\\n'))} ${isTest ? '' : '&& exit 3'}`;\n}\n\nfunction readProjectJson(fileName) {\n    try {\n        return JSON.parse(readFileSync(fileName, 'utf-8'));\n    } catch (err) {\n        throw `Issue while parsing sfdx-project.json file. \\n${err.toString()}`;\n    }\n}\n\nfunction escapeSpecialCharacters(text) {\n    return text?.replace(/`/g, '\\\\`')?.replace(/\\$/g, '\\\\$');\n}\n\nfunction logger(text) {\n    console.log(text);\n}\n\nfunction configureGit(gitEmail, gitName) {\n    execSync(\n        `\n        git config --local user.email \"${gitEmail}\" || (${this.getErrorCmd(`Issue configuring git email, ${CHECK_LOG}`)})\n        git config --local user.name \"${gitName}\" || (${this.getErrorCmd(`Issue configuring git name, ${CHECK_LOG}`)})`,\n        { stdio: 'inherit' }\n    );\n}\n\nfunction validateNamespace(namespaceprefix, nonamespace) {\n    if (namespaceprefix && !nonamespace && this.readProjectJson(SFDX_PROJECT_JSON)?.namespace !== namespaceprefix) {\n        this.setProgressStatus({\n            progressStatus: 'Error',\n            errorMessage: `Namespace in package record does not match with sfdx-project.json file in git repository.`\n        });\n    }\n}\n\nfunction maskSensitiveInformation(data) {\n    const sensitiveInfo = ['--targetdevhubusername', '-u', '-v'],\n        maskingSequence = '*****';\n\n    const arrayOfData = data.split(' ');\n    sensitiveInfo.forEach((subString) => {\n        const keyIndex = arrayOfData.indexOf(subString);\n        if (keyIndex > -1) {\n            arrayOfData[keyIndex + 1] = maskingSequence;\n            data = arrayOfData.join(' ');\n        }\n    });\n    return data;\n}\n\nmodule.exports.configureGit = configureGit;\nmodule.exports.logger = logger;\nmodule.exports.escapeSpecialCharacters = escapeSpecialCharacters;\nmodule.exports.readProjectJson = readProjectJson;\nmodule.exports.getErrorCmd = getErrorCmd;\nmodule.exports.setProgressStatus = setProgressStatus;\nmodule.exports.commit = commit;\nmodule.exports.createPackage = createPackage;\nmodule.exports.prepareAndCloneRepo = prepareAndCloneRepo;\nmodule.exports.setInstanceUrl = setInstanceUrl;\nmodule.exports.getPackagesList = getPackagesList;\nmodule.exports.buildParameters = buildParameters;\nmodule.exports.execute = execute;\nmodule.exports.setupDirectory = setupDirectory;\nmodule.exports.validateNamespace = validateNamespace;\nmodule.exports.maskSensitiveInformation = maskSensitiveInformation;\n\n// EXECUTION\n\n!isTest && this.execute();",
                    "copado__Type__c": "Standard",
                    "Id": "a0l7Q000000iAiTQAU",
                    "LastReferencedDate": "2023-01-17T08:03:11.000+0000",
                    "LastViewedDate": "2023-01-17T08:03:11.000+0000",
                    "Name": "SFDX Package Create"
                },
                {
                    "attributes": {
                        "type": "copado__Function__c",
                        "url": "/services/data/v57.0/sobjects/copado__Function__c/a0l7Q000000MDZ5QAO"
                    },
                    "copado__ApexClass__c": null,
                    "copado__API_Name__c": "SFDXRunApexTests",
                    "copado__Callback_Type__c": null,
                    "copado__Image_Name__c": "copado-multicloud-dx:v3",
                    "copado__Options__c": "[ ]",
                    "copado__Parameters__c": "[ {\n  \"name\" : \"source_session_id\",\n  \"defaultValue\" : \"{$Source.Credential.SessionId}\"\n}, {\n  \"name\" : \"source_endpoint\",\n  \"defaultValue\" : \"{$Source.Credential.Endpoint}\"\n}, {\n  \"name\" : \"namespace\",\n  \"defaultValue\" : \"\"\n}, {\n  \"name\" : \"source_path\",\n  \"defaultValue\" : \"force-app\"\n}, {\n  \"name\" : \"test_minutes_timeout\",\n  \"defaultValue\" : \"1440\"\n}, {\n  \"name\" : \"test_result_ids\",\n  \"defaultValue\" : \"{$Context.JobExecution__r.DataJson.resultIds}\"\n}, {\n  \"required\" : true,\n  \"name\" : \"test_classes\",\n  \"defaultValue\" : \"{$Context.apex.cmcSf.GetTestClasses}\"\n}, {\n  \"name\" : \"consolidated_result_id\",\n  \"defaultValue\" : \"{$Context.JobExecution__r.DataJson.resultId}\"\n} ]",
                    "copado__Script__c": "prepareSfdxProject() {\n\tcopado -p \"Preparing sfdx project configuration\"\n\n\tsource_endpoint=($(node -p \"('$source_endpoint').substring(0, '$source_endpoint'.indexOf('.com') + 4)\"))\n    \n    mkdir -p .sfdx\n\tcat << __EOF__ > \".sfdx/sfdx-config.json\"\n\t{\n\t\t\"instanceUrl\": \"$source_endpoint\"\n\t}\n__EOF__\n\t\n    cat << __EOF__ > \"sfdx-project.json\"\n\t{\n\t\t\"namespace\": \"$namespace\",\n\t\t\"packageDirectories\": [\n\t\t\t{\n\t\t\t\t\"path\": \"$source_path\",\n                \"default\": true\n            }\n\t\t],\n        \"sfdcLoginUrl\": \"\"\n\t}\n__EOF__\n}\n\nrunApexTests() {\n\techo \"test classes: ${test_classes}\"\n    copado -p \"Running Apex Tests in the source environment\"\n    sfdx force:apex:test:run -u ${source_session_id} -t ${test_classes} -r json --detailedcoverage --codecoverage --verbose --wait ${test_minutes_timeout} > /tmp/apex-tests-output.json || true\n    jq 'del(.result.summary.username)' /tmp/apex-tests-output.json > tmp.$$.json && mv tmp.$$.json /tmp/apex-tests-output.json\n}\n\nattachResultFile() {\n    # To function result\n\tcopado -u /tmp/apex-tests-output.json --name \"apex-tests-output.json\"\n\n\t# To test independent results, if existing\n\tif [ -n \"$test_result_ids\" ];\n    then\n      test_result_ids=$(echo $test_result_ids | sed -e \"s/\\[//g\" | sed -e \"s/\\]//g\" | sed -e \"s/ //g\" | xargs)\n      IFS=','\n      for test_result_id in ${test_result_ids};\n      do\n          copado -u /tmp/apex-tests-output.json --name \"apex-tests-output.json\" --parentid $test_result_id\n      done\n    fi\n    \n    # To consolidated result, if existing\n\tif [ -n \"$consolidated_result_id\" ];\n    then\n\t    copado -u /tmp/apex-tests-output.json --name \"apex-tests-output.json\" --parentid $consolidated_result_id\n    fi\n}\n\nprepareSfdxProject\nrunApexTests\nattachResultFile",
                    "copado__Timeout__c": 1440,
                    "copado__Type__c": "Standard",
                    "copado__Version__c": "1",
                    "copado__Worker_Size__c": "S",
                    "Id": "a0l7Q000000MDZ5QAO",
                    "LastReferencedDate": "2023-03-29T04:19:26.000+0000",
                    "LastViewedDate": "2023-03-29T04:19:26.000+0000",
                    "Name": "SFDX Run Apex Tests"
                },
                {
                    "attributes": {
                        "type": "copado__Function__c",
                        "url": "/services/data/v56.0/sobjects/copado__Function__c/a0l7Q000000iFzHQAU"
                    },
                    "copado__API_Name__c": "SFDX_Package_Version_Git_Config",
                    "copado__Description__c": "SFDX Package Version Git Config",
                    "copado__Image_Name__c": "copado-multicloud-dx:v3",
                    "copado__Options__c": "[ ]",
                    "copado__Parameters__c": "[ {\n  \"required\" : true,\n  \"name\" : \"packageVersion\",\n  \"defaultValue\" : \"{$Context.JobExecution__r.DataJson.packageVersion}\"\n}, {\n  \"required\" : true,\n  \"name\" : \"git_json\",\n  \"defaultValue\" : \"{$Context.Repository.Credential}\"\n}, {\n  \"name\" : \"dxNamespace\",\n  \"defaultValue\" : \"{$Context.apex.cmcSf.GetDxNamespace}\"\n} ]",
                    "copado__Script__c": "#!/usr/bin/env node\n'use strict';\n\n// IMPORTS\nconst fs = require('fs'),\n    { execSync } = require('child_process'),\n    process = require('process'),\n    { packageVersion, isTest, dxNamespace } = process.env,\n    versionDetail = JSON.parse(packageVersion);\n\n// CONSTANTS\n\nconst STDIO = {\n        INHERIT: 'inherit'\n    },\n    CHECK_LOG = 'Please check the logs for details',\n    PROJECT_DIRECTORY = 'sfProject',\n    PROJECT_JSON = 'sfdx-project.json';\n\n// SCRIPT FUNCTIONS\n\nfunction cloneRepo(branchName) {\n    if (!branchName) {\n        throw `Could not find branch name.`;\n    }\n\n    execSync(\n        `\n\t\tcopado -p 'Cloning git repository'\n\t\tcopado-git-get ${branchName} --depth 1 || (${this.getErrorCmd(`Error check out branch ${branchName}, ${CHECK_LOG}`)})`,\n        { stdio: STDIO.INHERIT }\n    );\n}\n\nfunction readProjectJson(file) {\n    try {\n        return JSON.parse(fs.readFileSync(file, 'utf-8'));\n    } catch (error) {\n        throw `Error parsing ${file}. ${error?.toString()}`;\n    }\n}\n\nfunction escapeSpecialCharacters(text) {\n    return text.replace(/`/g, '\\\\`').replace(/\\$/g, '\\\\$');\n}\n\nfunction getErrorCmd(error) {\n    return `copado -p 'Error' -e ${this.escapeSpecialCharacters(JSON.stringify(error))} ${isTest ? '' : '&& exit 3'}`;\n}\n\nfunction getDetailsFromProjectJson(projectJson, version, dxNamespace) {\n    const packageId = version?.copado__Artifact__r?.copado__Package_Id__c,\n        packageAliases = projectJson?.packageAliases,\n        recordNamespace = version?.copado__Artifact__r?.copado__Package_Namespace__c,\n        projectJsonNamespace = projectJson?.namespace,\n        pkgName = packageAliases ? Object.keys(packageAliases)?.find(pckgId => packageAliases[pckgId] === packageId) : undefined;\n\n    this.checkAttributesAndHandleErrors({ packageAliases, packageId, pkgName, recordNamespace, projectJsonNamespace });\n\n    const {\n        versionNumber,\n        versionDescription,\n        versionName,\n        postInstallUrl,\n        ancestorVersion,\n        ancestorId,\n        postInstallScript,\n        releaseNotesUrl,\n        uninstallScript,\n        definitionFile\n    } = this.getPackageDirectory(projectJson, pkgName);\n\n    return JSON.stringify({\n        packageVersion: {\n            Id: version.Id,\n            copado__Version_number__c: versionNumber,\n            copado__Version_Description__c: versionDescription,\n            copado__Version_Name__c: versionName,\n            [`${dxNamespace}Post_Install_URL__c`]: postInstallUrl,\n            [`${dxNamespace}Post_Install_Script__c`]: postInstallScript,\n            [`${dxNamespace}Release_Notes_URL__c`]: releaseNotesUrl,\n            [`${dxNamespace}Uninstall_Script__c`]: uninstallScript,\n            copado__DefinitionFile__c: definitionFile,\n            [`${dxNamespace}Ancestor_Version__c`]: ancestorVersion,\n            [`${dxNamespace}Ancestor_Id__c`]: ancestorId ? (packageAliases[ancestorId] ? packageAliases[ancestorId] : ancestorId) : undefined\n        }\n    });\n}\n\nfunction checkAttributesAndHandleErrors({ packageAliases, packageId, pkgName, recordNamespace, projectJsonNamespace }) {\n    if (!packageAliases) {\n        throw `Missing attribute packageAliases from project JSON file`;\n    }\n\n    if (!packageId || !pkgName) {\n        throw `Missing associated package either in Salesforce record or project JSON file.`;\n    }\n\n    if (recordNamespace && projectJsonNamespace && recordNamespace != projectJsonNamespace) {\n        throw `Mismatch of namespace in Package record and repository.`;\n    }\n}\n\nfunction setupDirectory(directory) {\n    fs.mkdirSync(directory);\n    process.chdir(directory);\n}\n\nfunction execute() {\n    try {\n        this.setupDirectory(PROJECT_DIRECTORY);\n        this.cloneRepo(versionDetail.copado__Branch__c);\n        execSync(\n            `\n            copado -p 'Fetching details from repository'`,\n            { stdio: STDIO.INHERIT }\n        );\n        const projectJson = this.readProjectJson(PROJECT_JSON);\n        const versionDetails = this.getDetailsFromProjectJson(projectJson, versionDetail, dxNamespace);\n        const result = this.escapeSpecialCharacters(JSON.stringify(versionDetails));\n        execSync(`copado -p 'Fetch Successful' -r ${result}`, { stdio: STDIO.INHERIT });\n    } catch (err) {\n        //Error status = 3, is when we have Custom Error Message, where error is already populated on result and hence we do not need to call it again.\n        if (err?.status === 3) {\n            process.exit(1);\n        }\n        execSync(`${this.getErrorCmd(err?.toString())}`);\n    }\n}\n\nfunction getPackageDirectory(projectJson, pkgName) {\n    const pkgDirectory = projectJson?.packageDirectories?.find(dir => dir.package === pkgName);\n    if (!pkgDirectory) {\n        throw `Could not find directory for package '${pkgName}' in packageDirectories attribute in project JSON file.`;\n    }\n    return pkgDirectory;\n}\n\nmodule.exports.cloneRepo = cloneRepo;\nmodule.exports.escapeSpecialCharacters = escapeSpecialCharacters;\nmodule.exports.readProjectJson = readProjectJson;\nmodule.exports.getErrorCmd = getErrorCmd;\nmodule.exports.getDetailsFromProjectJson = getDetailsFromProjectJson;\nmodule.exports.checkAttributesAndHandleErrors = checkAttributesAndHandleErrors;\nmodule.exports.execute = execute;\nmodule.exports.setupDirectory = setupDirectory;\nmodule.exports.getPackageDirectory = getPackageDirectory;\n\n// EXECUTION\n\n!isTest && this.execute();",
                    "copado__Timeout__c": 120,
                    "copado__Type__c": "Standard",
                    "Id": "a0l7Q000000iFzHQAU",
                    "LastReferencedDate": "2023-01-30T10:18:48.000+0000",
                    "LastViewedDate": "2023-01-30T10:18:48.000+0000",
                    "Name": "SFDX Package Version Git Config"
                },
                {
                    "attributes": {
                        "type": "copado__Function__c",
                        "url": "/services/data/v55.0/sobjects/copado__Function__c/a0k09000000rbjMAAQ"
                    },
                    "copado__API_Name__c": "SFDX_Deploy_Custom_Setting",
                    "copado__Description__c": "This function is used to create custom setting records",
                    "copado__Image_Name__c": "copado-multicloud-dx:v3",
                    "copado__Options__c": "[ ]",
                    "copado__Parameters__c": "[ {\n  \"required\" : true,\n  \"name\" : \"source_sessionid\",\n  \"defaultValue\" : \"{$Source.Credential.SessionId}\"\n}, {\n  \"required\" : true,\n  \"name\" : \"source_endpoint\",\n  \"defaultValue\" : \"{$Source.Credential.Endpoint}\"\n}, {\n  \"required\" : true,\n  \"name\" : \"source_env_var\",\n  \"defaultValue\" : \"{$Source.apex.EnvironmentVariables}\"\n}, {\n  \"required\" : true,\n  \"name\" : \"destination_env_var\",\n  \"defaultValue\" : \"{$Destination.apex.EnvironmentVariables}\"\n}, {\n  \"required\" : true,\n  \"name\" : \"destination_sessionid\",\n  \"defaultValue\" : \"{$Destination.Credential.SessionId}\"\n}, {\n  \"required\" : true,\n  \"name\" : \"destination_endpoint\",\n  \"defaultValue\" : \"{$Destination.Credential.Endpoint}\"\n}, {\n  \"required\" : false,\n  \"name\" : \"records\",\n  \"defaultValue\" : \"\"\n}, {\n  \"required\" : false,\n  \"name\" : \"custom_setting_name\",\n  \"defaultValue\" : \"\"\n}, {\n  \"required\" : false,\n  \"name\" : \"profiles\",\n  \"defaultValue\" : \"\"\n}, {\n  \"required\" : false,\n  \"name\" : \"users\",\n  \"defaultValue\" : \"\"\n}, {\n  \"required\" : false,\n  \"name\" : \"organizations\",\n  \"defaultValue\" : \"\"\n}, {\n  \"required\" : false,\n  \"name\" : \"key_prefix\",\n  \"defaultValue\" : \"\"\n}, {\n  \"required\" : true,\n  \"name\" : \"isValidation\",\n  \"defaultValue\" : \"{$Context.JobExecution__r.DataJson.deploymentDryRun}\"\n} ]",
                    "copado__Script__c": "#!/usr/bin/env node\n/**\n * Performs deployment of custom setting records.\n * @param source_sessionid\n * @param source_endpoint\n * @param source_env_var\n * @param destination_env_var\n * @param destination_sessionid\n * @param destination_endpoint\n * @param records\n * @param custom_setting_name\n * @param profiles\n * @param users\n * @param organizations\n * @param key_prefix\n * @param isValidation\n */\n\nconst fs = require('fs'),\n    { execSync, exec } = require('child_process'),\n    {\n        source_sessionid,\n        source_endpoint,\n        source_env_var,\n        destination_env_var,\n        destination_sessionid,\n        destination_endpoint,\n        custom_setting_name,\n        isValidation\n    } = process.env,\n    sourceApiVersion = '55.0',\n    source_base_url = getBaseUrl(source_endpoint),\n    destination_base_url = getBaseUrl(destination_endpoint),\n    source_environment = 'source',\n    destination_environment = 'destination';\n\nlet { records, profiles, users, organizations, key_prefix } = process.env,\n    profileQuery,\n    userQuery,\n    organizationQuery,\n    recordNames,\n    sourceCustomSetting = {},\n    sourceRecords = {\n        profileMapping: {},\n        userMapping: {},\n        organizationMapping: {},\n        records: []\n    },\n    destinationRecords = {\n        profileMapping: {},\n        userMapping: {},\n        organizationMapping: {},\n        records: {}\n    };\n\n// EXECUTION\n\nexecute();\n\n// FUNCTIONS\n\nfunction execute() {\n    try {\n        validateExecutionMode();\n        setup();\n        validateSource();\n        prepareQueryForDependentRecords();\n        Promise.all(getCustomSettingDependentData(source_sessionid, `Retrieve records from ${source_environment}`))\n            .then((data) => {\n                queryCustomSettingInSource(data);\n                validateDestination();\n                Promise.all(getCustomSettingDependentData(destination_sessionid, `Retrieve records from ${destination_environment}`))\n                    .then((data) => {\n                        queryCustomSettingInDestination(data);\n                        mergeAndDeployRecords();\n                    })\n                    .catch((error) => {\n                        logError(error);\n                    });\n            })\n            .catch((error) => {\n                logError(error);\n            });\n    } catch (error) {\n        logError(error);\n    }\n}\n\nfunction getBaseUrl(endpoint) {\n    return endpoint.substring(0, endpoint.indexOf('/', endpoint.indexOf('/') + 2));\n}\n\nfunction validateExecutionMode() {\n    const validationModeMessage = 'This step will not be executed for validate changes';\n    if (isValidation === 'true') {\n        execSync(`copado -p '${validationModeMessage}' --result-data '${validationModeMessage}'`);\n        process.exit(0);\n    }\n}\n\nfunction logError(error) {\n    execSync(`copado -p 'Error' -e '${error.toString()}' && exit 1`);\n}\n\nfunction setup() {\n    const cmd = `\n copado -p 'Preparing sfdx project configuration'\n cd /app\n sfdx force:project:create --projectname 'sfdx_project' --json\n `;\n    execSync(cmd, { stdio: 'inherit' });\n    let projectJson = fs.readFileSync('/app/sfdx_project/sfdx-project.json')?.toString();\n    if (projectJson) {\n        projectJson = JSON.parse(projectJson);\n        if(projectJson.sourceApiVersion !== sourceApiVersion) {\n        \tprojectJson = { ...projectJson, sourceApiVersion };\n        \tfs.writeFileSync('/app/sfdx_project/sfdx-project.json', JSON.stringify(projectJson));\n        }\n    }\n}\n\nfunction setInstanceUrl(url, message) {\n    const cmd = `\n copado -p '${message}'\n cd /app/sfdx_project\n sfdx config:set instanceUrl=${url}\n `;\n    execSync(cmd, { stdio: 'inherit' });\n}\n\nfunction retrieveCustomSettingMetadata(sessionid, message, environment) {\n    let result;\n    if (!custom_setting_name) {\n        throw `Error occured (${environment}), invalid custom setting name. Please check logs for more details.`;\n    }\n    const cmd = `\n copado -p '${message}'\n cd /app/sfdx_project\n sfdx force:source:retrieve --metadata CustomObject:${custom_setting_name} -u ${sessionid} --json`;\n    const response = execSync(cmd);\n    if (!response) {\n        throw `Error occured (${environment}), custom setting metadata retrieval failed. Please check logs for more details.`;\n    } else {\n        result = extractCustomSettingMetadata(JSON.parse(response.toString()), environment);\n    }\n    return result;\n}\n\nfunction extractCustomSettingMetadata(metadataResponse, environment) {\n    const result = { fields: [], filePath: '' };\n    const metadata = metadataResponse?.result?.inboundFiles;\n    if (metadataResponse.status != 0 || !metadata) {\n        throw `Error occured (${environment}), '${JSON.stringify(metadataResponse)}'. Please check logs for more details.`;\n    } else {\n        metadata.forEach((element) => {\n            if (element.error) {\n                throw `Error occured (${environment}), '${JSON.stringify(element.error)}'. Please check logs for more details.`;\n            } else if (element.type === 'CustomField') {\n                result.fields.push(element.fullName.replace(`${custom_setting_name}.`, ''));\n            } else if (element.type === 'CustomObject') {\n                result.filePath = element.filePath;\n            }\n        });\n    }\n    return result;\n}\n\nfunction checkCustomSettingTypeAndVisibility(customSettingPath, message, environment) {\n    const result = { isHierarchy: false };\n    if (!customSettingPath) {\n        throw `Error occured (${environment}), invalid custom setting filePath. Please check logs for more details.`;\n    }\n    const cmd = `\n copado -p '${message}'\n cd /app/sfdx_project\n cat ${customSettingPath}\n `;\n    let response = execSync(cmd);\n    if (!response) {\n        throw `Error occured (${environment}), custom setting details not found. Please check logs for more details.`;\n    } else {\n        response = response.toString();\n        if (!response.includes('<visibility>Public</visibility>')) {\n            throw `Error occured (${environment}), '${JSON.stringify(\n                response\n            )}'. Only public custom setting records can be moved from source org to destination org. Please check logs for more details.`;\n        }\n        result.isHierarchy = response.includes('<customSettingsType>Hierarchy</customSettingsType>');\n    }\n    return result;\n}\n\nfunction validateSource() {\n    setInstanceUrl(source_base_url, `Setting instance url to ${source_environment}`);\n    const metadata = retrieveCustomSettingMetadata(\n        source_sessionid,\n        `Retrieve and validate custom setting in ${source_environment}`,\n        source_environment\n    );\n    Object.assign(sourceCustomSetting, metadata);\n    const type = checkCustomSettingTypeAndVisibility(\n        sourceCustomSetting.filePath,\n        `Checking custom setting type and visibility in ${source_environment}`,\n        source_environment\n    );\n    Object.assign(sourceCustomSetting, type);\n}\n\nfunction prepareQueryForDependentRecords() {\n    const hierarchyCustomSettingError = `Error occured, for hierarchy custom setting we need profile, user or organization record(s) to deploy the custom setting data. Please check logs for more details.`;\n    const listCustomSettingError = `Error occured, no custom setting record(s) found for deployment. Please check logs for more details.`;\n    if (sourceCustomSetting.isHierarchy) {\n        if (!profiles && !users && !organizations) {\n            throw hierarchyCustomSettingError;\n        }\n        profiles = JSON.parse(profiles);\n        users = JSON.parse(users);\n        organizations = JSON.parse(organizations);\n        if (profiles?.length) {\n            profileQuery = `SELECT Id, Name FROM Profile WHERE Name IN ('${profiles.map((profile) => profile.Name).join(\"','\")}')`;\n        }\n        if (users?.length) {\n            const userNames = [];\n            const userProfileNames = [];\n            users.forEach((user) => {\n                userNames.push(user.Name);\n                userProfileNames.push(user.Profile.Name);\n            });\n            userQuery = `SELECT Id, Name FROM User WHERE Name IN ('${userNames.join(\"','\")}') AND Profile.Name IN ('${userProfileNames.join(\n                \"','\"\n            )}')`;\n        }\n        if (organizations?.length) {\n            organizationQuery = `SELECT Id, Name FROM Organization WHERE Name IN ('${organizations\n                .map((organization) => organization.Name)\n                .join(\"','\")}')`;\n        }\n        if (!profileQuery && !userQuery && !organizationQuery) {\n            throw hierarchyCustomSettingError;\n        }\n    } else if (!records) {\n        throw listCustomSettingError;\n    } else {\n        records = JSON.parse(records);\n        if (!records?.length) {\n            throw listCustomSettingError;\n        } else {\n            recordNames = records.map((record) => record.Name);\n        }\n    }\n}\n\nfunction queryCustomSettingInSource(data) {\n    const filterResponse = prepareCustomSettingQueryFilter(data, sourceCustomSetting.isHierarchy, 'Id', 'Name', source_environment);\n    Object.assign(sourceRecords, filterResponse);\n    delete sourceRecords.customSettingNames;\n    const queryResponse = queryCustomSettingRecords(\n        sourceCustomSetting.isHierarchy,\n        Object.keys(sourceRecords.profileMapping),\n        Object.keys(sourceRecords.userMapping),\n        Object.keys(sourceRecords.organizationMapping),\n        filterResponse.customSettingNames,\n        `Error occured, no filters avaliable to query custom seting records in ${source_environment}. Please check logs for more details.`,\n        sourceCustomSetting.fields,\n        source_sessionid,\n        source_environment\n    );\n    sourceRecords.records = getCustomSettingRecords(\n        JSON.parse(queryResponse),\n        source_environment,\n        `Error occured, there are no custom setting records available in ${source_environment} as per the mentioned filters. Please check logs for more details.`\n    );\n}\n\nfunction getCustomSettingRecords(data, environment, noRecordsError) {\n    let result;\n    if (data.status != 0) {\n        throw `Error occured (${environment}), '${JSON.stringify(data)}' Please check logs for more details.`;\n    } else {\n        result = data?.result?.records;\n        if (!records?.length && noRecordsError) {\n            throw noRecordsError;\n        }\n    }\n    return result;\n}\n\nfunction prepareCustomSettingQueryFilter(data, isHierarchy, key, value, environment) {\n    const result = { profileMapping: {}, userMapping: {}, organizationMapping: {}, customSettingNames: null };\n    data.forEach((response) => {\n        if (isHierarchy) {\n            response = JSON.parse(response);\n            if (response.status != 0) {\n                throw `Error occured (${environment}), '${JSON.stringify(response)}'. Please check logs for more details.`;\n            } else {\n                const records = response?.result?.records;\n                if (records?.length) {\n                    mapRecords(records, result, key, value);\n                }\n            }\n        } else {\n            result.customSettingNames = response;\n        }\n    });\n    return result;\n}\n\nfunction queryCustomSettingRecords(\n    isHierarchy,\n    profileIds,\n    userIds,\n    orgIds,\n    customSettingNames,\n    noFilterError,\n    fieldsToQuery,\n    sessionid,\n    environment\n) {\n    let response;\n    let filters = [];\n    if (isHierarchy) {\n        filters = filters.concat(profileIds, userIds, orgIds);\n    } else {\n        filters = filters.concat(customSettingNames);\n    }\n\n    if (!filters?.length) {\n        if (noFilterError) {\n            throw noFilterError;\n        }\n    } else {\n        const filterIds = `('${filters.join(\"','\")}')`;\n        const query = `SELECT Id, Name, SetupOwnerId ${\n            fieldsToQuery?.length ? ',' + fieldsToQuery.join(',') : ''\n        } FROM ${custom_setting_name} WHERE ${isHierarchy ? 'SetupOwnerId IN ' : 'Name IN '} ${filterIds}`;\n        response = doSoqlSyncQuery(query, sessionid);\n    }\n\n    if (!response) {\n        throw `Error occured (${environment}), force:data:soql:query command failed. Please check logs for more details.`;\n    }\n    return response;\n}\n\nfunction mapRecords(records, dataSet, key, value) {\n    records.forEach((record) => {\n        switch (record?.attributes?.type) {\n            case 'Profile':\n                dataSet.profileMapping[record[key]] = record[value];\n                break;\n            case 'User':\n                dataSet.userMapping[record[key]] = record[value];\n                break;\n            case 'Organization':\n                dataSet.organizationMapping[record[key]] = record[value];\n                break;\n        }\n    });\n}\n\nfunction getCustomSettingDependentData(sessionId, message) {\n    exec(`copado -p '${message}'`, { stdio: 'inherit' });\n    const promises = [];\n    if (sourceCustomSetting.isHierarchy) {\n        [profileQuery, userQuery, organizationQuery].forEach((query) => {\n            if (query) {\n                promises.push(\n                    new Promise((resolve, reject) => {\n                        doSoqlAsyncQuery(resolve, reject, query, sessionId);\n                    })\n                );\n            }\n        });\n    } else {\n        promises.push(\n            new Promise((resolve, reject) => {\n                resolve(recordNames);\n            })\n        );\n    }\n    return promises;\n}\n\nfunction doSoqlAsyncQuery(resolve, reject, query, sessionId) {\n    exec(getQueryCmd(query, sessionId), (error, data, stderr) => {\n        if (error) {\n            reject(error);\n        } else {\n            resolve(data);\n        }\n    });\n}\n\nfunction doSoqlSyncQuery(query, sessionId) {\n    const response = execSync(getQueryCmd(query, sessionId));\n    if (!response) {\n        throw `Error occured, force:data:soql:query command failed. Please check logs for more details.`;\n    } else {\n        return response.toString();\n    }\n}\n\nfunction getQueryCmd(query, sessionId) {\n    return `\n cd /app/sfdx_project\n sfdx force:data:soql:query --query \"${query}\" --json -u ${sessionId}\n `;\n}\n\nfunction validateDestination() {\n    setInstanceUrl(destination_base_url, `Setting instance url to ${destination_environment}`);\n    const metadata = retrieveCustomSettingMetadata(\n        destination_sessionid,\n        `Retrieve and validate custom setting in ${destination_environment}`,\n        destination_environment\n    );\n    const missingFields = sourceCustomSetting.fields.filter((field) => metadata.fields.indexOf(field) === -1);\n    if (missingFields?.length) {\n        throw `Error occured, fields missing in ${destination_environment} ${missingFields.join(',')}. Please check logs for more details.`;\n    }\n    const type = checkCustomSettingTypeAndVisibility(\n        metadata.filePath,\n        `Checking custom setting type and visibility in ${destination_environment}`,\n        destination_environment\n    );\n    if (sourceCustomSetting.isHierarchy != type.isHierarchy) {\n        throw `Error occured, there is a mismatch in the custom setting type for source and destination. Please check logs for more details.`;\n    }\n}\n\nfunction queryCustomSettingInDestination(data) {\n    const filterResponse = prepareCustomSettingQueryFilter(data, sourceCustomSetting.isHierarchy, 'Name', 'Id', destination_environment);\n    Object.assign(destinationRecords, filterResponse);\n    delete destinationRecords.customSettingNames;\n    const queryResponse = queryCustomSettingRecords(\n        sourceCustomSetting.isHierarchy,\n        Object.values(destinationRecords.profileMapping),\n        Object.values(destinationRecords.userMapping),\n        Object.values(destinationRecords.organizationMapping),\n        filterResponse.customSettingNames,\n        null,\n        null,\n        destination_sessionid,\n        destination_environment\n    );\n    const records = getCustomSettingRecords(JSON.parse(queryResponse), destination_environment, null);\n    records.forEach((record) => {\n        destinationRecords.records[sourceCustomSetting.isHierarchy ? record.SetupOwnerId : record.Name] = record.Id;\n    });\n}\n\nfunction mergeAndDeployRecords() {\n    const finalRecords = mergeRecords();\n    createCSV(finalRecords);\n    varreplace();\n    deployRecords();\n}\n\nfunction mergeRecords() {\n    const finalRecords = [];\n    key_prefix = JSON.parse(key_prefix);\n    let destinationSetupOwnerId;\n    sourceRecords.records.forEach((record) => {\n        if (sourceCustomSetting.isHierarchy) {\n            destinationSetupOwnerId = null;\n            switch (key_prefix[record.SetupOwnerId.substring(0, 3)]) {\n                case 'Profile':\n                    destinationSetupOwnerId = destinationRecords.profileMapping[sourceRecords.profileMapping[record.SetupOwnerId]];\n                    break;\n                case 'User':\n                    destinationSetupOwnerId = destinationRecords.userMapping[sourceRecords.userMapping[record.SetupOwnerId]];\n                    break;\n                case 'Organization':\n                    destinationSetupOwnerId =\n                        destinationRecords.organizationMapping[sourceRecords.organizationMapping[record.SetupOwnerId]];\n                    break;\n            }\n            if (!destinationSetupOwnerId) {\n                return;\n            }\n        } else {\n            destinationSetupOwnerId = null;\n        }\n        delete record.attributes;\n        record.SetupOwnerId = destinationSetupOwnerId;\n        record.Id = sourceCustomSetting.isHierarchy\n            ? destinationRecords.records[destinationSetupOwnerId]\n            : destinationRecords.records[record.Name];\n        finalRecords.push(record);\n    });\n    return finalRecords;\n}\n\nfunction createCSV(finalRecords) {\n    if (!finalRecords?.length) {\n        throw `No custom setting records avaliable for deployment in ${destination_environment}`;\n    } else {\n        const csvData = arrayToCSV(finalRecords);\n        fs.writeFileSync('/tmp/records.csv', csvData);\n    }\n}\n\nfunction arrayToCSV(data) {\n    let csv = data.map((row) => Object.values(row));\n    csv.unshift(Object.keys(data[0]));\n    return `\"${csv.join('\"\\n\"').replace(/,/g, '\",\"')}\"`;\n}\n\nfunction varreplace() {\n    const cmd = `\n copado -p \"Replacing environment variables, if any\"\n varreplace '${source_env_var}' '/tmp/records.csv' --valuename=true\n varreplace '${destination_env_var}' '/tmp/records.csv' --valuename=false\n `;\n    execSync(cmd);\n}\n\nfunction deployRecords() {\n    sourceCustomSetting = sourceRecords = destinationRecords = profileQuery = userQuery = organizationQuery = recordNames = null;\n    const cmd = `\n cd /app/sfdx_project\n copado -p 'Deploying custom setting records in ${destination_environment}'\n sfdx force:data:bulk:upsert --sobjecttype ${custom_setting_name} --csvfile /tmp/records.csv --externalid Id -u ${destination_sessionid} --wait 60 > /tmp/result.txt\n copado -u /tmp/records.csv --name \"records.csv\"\n copado -u /tmp/result.txt --name \"result.txt\"\n `;\n    execSync(cmd, { maxBuffer: 50 * 1024 * 1024 });\n    const result = fs.readFileSync('/tmp/result.txt');\n    if (!result) {\n        throw 'Error occured while deploying records in destination, kindly check logs for more details';\n    } else if (result.includes('Upsert errors')) {\n        throw 'Error occured, kindly check the result.txt file for more details';\n    }\n}",
                    "copado__Timeout__c": 60,
                    "copado__Type__c": "Standard",
                    "copado__Version__c": "1",
                    "copado__Worker_Size__c": "M",
                    "Id": "a0k09000000rbjMAAQ",
                    "LastReferencedDate": "2022-06-27T07:34:47.000+0000",
                    "LastViewedDate": "2022-06-27T07:34:47.000+0000",
                    "Name": "SFDX Deploy Custom Setting"
                },
                {
                    "attributes": {
                        "type": "copado__Function__c",
                        "url": "/services/data/v56.0/sobjects/copado__Function__c/a0k0900000C7opaAAB"
                    },
                    "copado__ApexClass__c": "cmcSf.RefreshMetadataCallback",
                    "copado__API_Name__c": "SFDX_Refresh_Metadata",
                    "copado__Callback_Type__c": "ApexClass",
                    "copado__Description__c": "This function generates metadata and deleted metadata files for the Salesforce org",
                    "copado__Image_Name__c": "copado-multicloud-dx:v3",
                    "copado__Options__c": "[ ]",
                    "copado__Parameters__c": "[ {\n  \"required\" : true,\n  \"name\" : \"sessionId\",\n  \"defaultValue\" : \"{$Source.Credential.SessionId}\"\n}, {\n  \"required\" : true,\n  \"name\" : \"endpoint\",\n  \"defaultValue\" : \"{$Source.Credential.Endpoint}\"\n}, {\n  \"required\" : false,\n  \"name\" : \"metadataFileId\",\n  \"defaultValue\" : \"{$Context.JobExecution__r.DataJson.metadataFileId}\"\n}, {\n  \"name\" : \"ignoredType\",\n  \"defaultValue\" : \"{$Context.JobExecution__r.DataJson.ignoredType}\"\n}, {\n  \"name\" : \"typeFilter\",\n  \"defaultValue\" : \"{$Context.JobExecution__r.DataJson.typeFilter}\"\n}, {\n  \"name\" : \"maxBuffer\",\n  \"defaultValue\" : \"5242880\"\n} ]",
                    "copado__Script__c": "#!/usr/bin/env node\n/**\n * Generates metadata and deleted metadata files for the Salesforce org\n * @param sessionId\n * @param endpoint\n * @param metadataFileId\n * @param ignoredType\n * @param typeFilter\n * @param maxBuffer\n */\nconst { writeFileSync } = require('fs'),\n    { env, chdir, exit } = require('process'),\n    { spawnSync } = require('child_process'),\n    { sessionId, endpoint, metadataFileId, ignoredType, typeFilter, maxBuffer } = env,\n    MAX_BUFFER_SIZE = parseInt(maxBuffer),\n    METADATA_FILE = 'MetaData',\n    NEW_METADATA_FILE = 'NewMetaData',\n    DELETED_METADATA_FILE = 'DeletedMetaData',\n    IGNORED_TYPE_FILE = 'IgnoredType.json',\n    TYPE_FILTER_FILE = 'TypeFilter.json',\n    STDIO = {\n        INHERIT: 'inherit'\n    };\n\n// EXECUTION\n\nexecute();\n\n// FUNCTIONS\n\nfunction execute() {\n    try {\n        chdir('/tmp');\n        createFile(IGNORED_TYPE_FILE, ignoredType ? ignoredType : '[]');\n        createFile(TYPE_FILTER_FILE, typeFilter ? typeFilter : '[]');\n        generateMetadataFile(sessionId, endpoint);\n        findDeletedMetadata(metadataFileId);\n    } catch (error) {\n        logError(error);\n    }\n}\n\nfunction logError(error) {\n    executeCommand(getErrorCmdString(error.toString()));\n}\n\nfunction createFile(fileName, data) {\n    writeFileSync(fileName, data);\n}\n\nfunction generateMetadataFile(sessionId, endpoint) {\n    const metadataRetrieveCmd =\n        'metadata-retrieve ' +\n        buildParameters({\n            ignoredTypes: IGNORED_TYPE_FILE,\n            output: NEW_METADATA_FILE,\n            typeFilter: TYPE_FILTER_FILE\n        }) +\n        ' refresh ' +\n        buildParameters({\n            endpointUrl: sessionId,\n            sessionId: getBaseUrl(endpoint)\n        }) +\n        ' || ' +\n        getErrorCmdString('Error in generating metadata file');\n    generateFile('Generating Metadata File', metadataRetrieveCmd, NEW_METADATA_FILE, METADATA_FILE, 'Error in uploading metadata file');\n}\n\nfunction generateDeletedMetadataFile() {\n    const metadataRetrieveCmd =\n        'metadata-retrieve ' +\n        buildParameters({\n            ignoredTypes: IGNORED_TYPE_FILE,\n            output: DELETED_METADATA_FILE,\n            typeFilter: TYPE_FILTER_FILE\n        }) +\n        ` difference ${METADATA_FILE} ${NEW_METADATA_FILE}  || ` +\n        getErrorCmdString('Error in generating deleted metadata file');\n    generateFile(\n        'Generating Deleted Metadata File',\n        metadataRetrieveCmd,\n        DELETED_METADATA_FILE,\n        DELETED_METADATA_FILE,\n        'Error in uploading deleted metadata file'\n    );\n}\n\nfunction generateFile(progressMessage, metadataRetrieveCmd, filePath, fileName, fileUploadErrorMessage) {\n    const cmd = `\n         copado -p '${progressMessage}'\n         ${metadataRetrieveCmd}\n         copado -u ${filePath} -n ${fileName} || ${getErrorCmdString(fileUploadErrorMessage)}\n  `;\n    executeCommand(cmd, STDIO.INHERIT);\n}\n\nfunction getBaseUrl(endpoint) {\n    return endpoint.substring(0, endpoint.indexOf('/', endpoint.indexOf('/') + 2));\n}\n\nfunction findDeletedMetadata(metadataFileId) {\n    if (metadataFileId) {\n        downloadCredentialMetadataFile(metadataFileId);\n        generateDeletedMetadataFile();\n    }\n}\n\nfunction downloadCredentialMetadataFile(metadataFileId) {\n    executeCommand(\n        `copado --downloadfiles ${metadataFileId} || ${getErrorCmdString('Error in downloading credential metadata file')}`,\n        STDIO.INHERIT\n    );\n}\n\nfunction buildParameters(data) {\n    return Object.entries(data).reduce((parameters, [key, value]) => {\n        return parameters + (value ? ` --${key} ${value}` : '');\n    }, '');\n}\n\nfunction executeCommand(cmd, ioconfig) {\n    const options = {\n        shell: true,\n        maxBuffer: MAX_BUFFER_SIZE\n    };\n    if (ioconfig) {\n        options.stdio = ioconfig;\n    }\n    const response = spawnSync(cmd, options);\n    if (response?.stderr) {\n        throw response?.stderr;\n    } else if (response?.status === 1) {\n        exit(1);\n    }\n}\n\nfunction getErrorCmdString(error) {\n    const suffix = 'Please check the logs for details.';\n    return `{ copado -p 'Error' -e \"${error}. ${suffix}\"; exit 1; }`;\n}",
                    "copado__Type__c": "Standard",
                    "Id": "a0k0900000C7opaAAB",
                    "LastReferencedDate": "2022-12-20T06:35:41.000+0000",
                    "LastViewedDate": "2022-12-20T06:35:41.000+0000",
                    "Name": "SFDX Refresh Metadata"
                },
                {
                    "attributes": {
                        "type": "copado__Function__c",
                        "url": "/services/data/v57.0/sobjects/copado__Function__c/a0l7Q000000Og66QAC"
                    },
                    "copado__API_Name__c": "Initialize_Git_With_SFDX_Project",
                    "copado__Image_Name__c": "copado-multicloud-dx:v3",
                    "copado__Options__c": "[ ]",
                    "copado__Parameters__c": "[ {\n  \"required\" : false,\n  \"name\" : \"branch\",\n  \"defaultValue\" : \"{$Context.JobExecution__r.DataJson.branch}\"\n}, {\n  \"required\" : false,\n  \"name\" : \"defaultDirectory\",\n  \"defaultValue\" : \"{$Context.JobExecution__r.DataJson.defaultDirectory}\"\n}, {\n  \"name\" : \"template\",\n  \"defaultValue\" : \"{$Context.JobExecution__r.DataJson.template}\"\n}, {\n  \"name\" : \"projectName\",\n  \"defaultValue\" : \"{$Context.JobExecution__r.DataJson.projectName}\"\n}, {\n  \"name\" : \"recreateProject\",\n  \"defaultValue\" : \"{$Context.JobExecution__r.DataJson.recreateProject}\"\n}, {\n  \"name\" : \"maxBuffer\",\n  \"defaultValue\" : \"5242880\"\n}, {\n  \"name\" : \"gitName\",\n  \"defaultValue\" : \"{$User.Name}\"\n}, {\n  \"name\" : \"gitEmail\",\n  \"defaultValue\" : \"{$User.Email}\"\n}, {\n  \"name\" : \"overriddenApiVersion\",\n  \"defaultValue\" : \"\"\n}, {\n  \"name\" : \"git_json\",\n  \"defaultValue\" : \"{$Context.apex.cmcSf.GetGitJson}\"\n} ]",
                    "copado__Script__c": "#!/usr/bin/env node\n\n'use strict';\n\nconst {\n        isTest,\n        branch,\n        defaultDirectory,\n        git_json,\n        template,\n        projectName,\n        recreateProject,\n        maxBuffer,\n        gitEmail,\n        gitName,\n        API_VERSION,\n        overriddenApiVersion\n    } = process.env,\n    child_process = require('child_process'),\n    MAXBUFFER = parseInt(maxBuffer),\n    { existsSync, writeFileSync, readFileSync } = require('fs'),\n    STDIO = {\n        INHERIT: 'inherit',\n        PIPE: 'pipe',\n        IGNORE: 'ignore'\n    },\n    APP_DIRECTORY = getPath('/app'),\n    TARGET_DIRECTORY = `${APP_DIRECTORY}/${projectName}`;\n\nfunction execute() {\n    try {\n        this.setUpWorkingDirectory(TARGET_DIRECTORY);\n        this.switchToWorkingDirectory(TARGET_DIRECTORY);\n        this.fetchRemoteGitBranch(branch);\n        this.validateExistingSFDXProject(recreateProject);\n        this.configureGit(gitEmail, gitName);\n        this.createSFDXProject(APP_DIRECTORY, projectName, template, defaultDirectory);\n        this.createExcludeAutoResolveFile();\n        this.updateGitIgnore();\n        const sourceApiVersion = this.getApiVersion(overriddenApiVersion, API_VERSION);\n        const isSourceApiVersionUpdated = this.updateSourceApiVersion(branch, sourceApiVersion);\n        this.validateGitStatus();\n        this.pushChangesToRemoteBranch(branch, isSourceApiVersionUpdated, sourceApiVersion);\n    } catch (error) {\n        this.executeCommand(this.getErrorCommand(error.toString()), STDIO.INHERIT);\n    }\n}\n\nfunction setUpWorkingDirectory(workingDirectory) {\n    this.executeCommand(`\n        copado -p 'Setting up working directory'\n    \tmkdir -p '${workingDirectory}'\n    `);\n}\n\nfunction switchToWorkingDirectory(workingDirectory) {\n    process.chdir(workingDirectory);\n}\n\nfunction fetchRemoteGitBranch(branchName) {\n    this.executeCommand(`\n        copado -p 'Fetching git branch'\n        copado-git-get '${branchName}' || ${this.getErrorCommand(`Error fetching git branch ${branchName}`)}\n    `);\n}\n\nfunction validateExistingSFDXProject(recreateProject) {\n    if (existsSync('sfdx-project.json') && (!recreateProject || recreateProject.toLowerCase() === 'false')) {\n        throw 'An existing SFDX project was found in your repository, initialization canceled';\n    }\n}\n\nfunction configureGit(gitEmail, gitName) {\n    const cmd = `\n    git config --local user.email \"${gitEmail}\" || ${this.getErrorCommand('Failure in configuring git user email')}\n    git config --local user.name \"${gitName}\" || ${this.getErrorCommand('Failure in configuring git user name')}\n    git config --global diff.renames false || ${this.getErrorCommand('Failure in disabling git rename detection from diff.renames')}\n    git config --global merge.renames false || ${this.getErrorCommand('Failure in disabling git rename detection from merge.renames')}\n    git config --global status.renames false || ${this.getErrorCommand('Failure in disabling git rename detection from status.renames')}\n    `;\n    this.executeCommand(cmd, STDIO.INHERIT);\n}\n\nfunction createSFDXProject(appDirectory, projectName, template, defaultDirectory) {\n    this.executeCommand(`copado -p 'Creating SFDX project'`);\n    const sfProjectCreateCmd = `sf project generate --name \"${projectName}\" --default-package-dir \"${defaultDirectory}\" --template \"${template}\"`;\n    this.logger(sfProjectCreateCmd);\n    this.executeCommand(`\n        cd '${appDirectory}'\n        ${sfProjectCreateCmd}\n    `);\n}\n\nfunction createExcludeAutoResolveFile() {\n    const fileContent =\n        '# Files matching patterns in this file will be excluded from auto-resolve during merge conflicts\\n' +\n        '# The pattern syntax is the same as for .gitignore files\\n' +\n        '# here is more documentation:\\n' +\n        '# Copado Docs & Samples: https://docs.copado.com/articles/copado-ci-cd-publication/conflict-resolution-in-copado-devops-platform\\n' +\n        '# Sample statements for metadata which is frequently excluded.\\n' +\n        '# please remove comment (#) to \"activate\" a statement and start resolving conflicts for specific metadata manually in Copado:\\n' +\n        '#**/classes/*.cls\\n' +\n        '#**/pages/*.page\\n' +\n        '#**/layouts/*.layout-meta.xml';\n    writeFileSync('.copado_exclude_autoresolve', fileContent);\n}\n\nfunction updateGitIgnore() {\n    let fileContent = readFileSync('.gitignore', 'utf-8')?.toString();\n    fileContent = `${fileContent}\\n.copado`;\n    writeFileSync('.gitignore', fileContent);\n}\n\nfunction getApiVersion(overriddenApiVersion, apiVersion) {\n    const finalApiVersion = overriddenApiVersion || apiVersion;\n    const regExpApiVersion = /\\d\\d\\.0/;\n    if (!regExpApiVersion.test(finalApiVersion)) {\n        this.executeCommand(this.getErrorCommand(`Invalid API Version: ${finalApiVersion}`));\n    }\n    return finalApiVersion;\n}\n\nfunction updateSourceApiVersion(branchName, sourceApiVersion) {\n    let result = false;\n    const sfdxProjectJsonPath = `sfdx-project.json`;\n    if (!existsSync(sfdxProjectJsonPath)) {\n        throw `Invalid configuration in ${branchName}. sfdx-project.json is invalid or missing at project root`;\n    }\n    let fileContent = JSON.parse(readFileSync(sfdxProjectJsonPath, 'utf-8'));\n    if (fileContent.sourceApiVersion !== sourceApiVersion) {\n        fileContent.sourceApiVersion = sourceApiVersion;\n        writeFileSync(sfdxProjectJsonPath, JSON.stringify(fileContent, null, 2));\n        result = true;\n    }\n    return result;\n}\n\nfunction validateGitStatus() {\n    const gitStatus = this.executeCommand(`git status --porcelain`);\n    if (!gitStatus) {\n        this.executeCommand(`copado -p 'There are no changes to be committed' -r 'No changes to be committed'`);\n        if (!isTest) {\n            process.exit(0);\n        }\n    }\n}\n\nfunction pushChangesToRemoteBranch(branchName, isSourceApiVersionUpdated, sourceApiVersion) {\n    let cmd = isSourceApiVersionUpdated\n        ? `copado -p 'Pushing changes in git' -r 'SourceApiVersion in sfdx-project.json is set as ${sourceApiVersion} to support Copado operations'`\n        : `copado -p 'Pushing changes in git'`;\n    cmd += `\n    git add . || ${this.getErrorCommand('There was some issue when staging changes')}\n    git commit -m 'Initialize SFDX Project' || ${this.getErrorCommand('There was some issue when committing changes')}\n    git push origin '${branchName}' ||  ${this.getErrorCommand('Could not push the changes to remote branch')}\n    `;\n    this.executeCommand(cmd, STDIO.INHERIT);\n}\n\nfunction getPath(filePath) {\n    return isTest ? `${__dirname}/__tests__/__mockDirectory__${filePath}` : filePath;\n}\n\nfunction getErrorCommand(error) {\n    const suffix = 'Please check the logs for details.';\n    return `{ copado -p 'Error' -e '${error}. ${suffix}'; exit 2; }`;\n}\n\nfunction executeCommand(cmd, ioconfig) {\n    const options = {\n        shell: true,\n        maxBuffer: MAXBUFFER\n    };\n    if (ioconfig) {\n        options.stdio = ioconfig;\n    }\n    const response = child_process.spawnSync(cmd, options);\n    const { output, error } = this.log(response);\n    if (response?.status != 0) {\n        if (response?.status == 2) {\n            if (isTest) {\n                throw output;\n            }\n            process.exit(2);\n        }\n        throw error ? error : `Error executing the command: ${cmd}`;\n    }\n    return output;\n}\n\nfunction log(response) {\n    const output = response?.stdout?.toString().trim();\n    const error = response?.stderr?.toString().trim();\n    if (output) {\n        this.logger(output);\n    }\n    if (error) {\n        this.logger(error);\n    }\n    return { output, error };\n}\n\nfunction logger(text) {\n    console.log(text);\n}\n\nmodule.exports.execute = execute;\nmodule.exports.setUpWorkingDirectory = setUpWorkingDirectory;\nmodule.exports.switchToWorkingDirectory = switchToWorkingDirectory;\nmodule.exports.fetchRemoteGitBranch = fetchRemoteGitBranch;\nmodule.exports.configureGit = configureGit;\nmodule.exports.executeCommand = executeCommand;\nmodule.exports.log = log;\nmodule.exports.getPath = getPath;\nmodule.exports.getErrorCommand = getErrorCommand;\nmodule.exports.validateExistingSFDXProject = validateExistingSFDXProject;\nmodule.exports.createSFDXProject = createSFDXProject;\nmodule.exports.createExcludeAutoResolveFile = createExcludeAutoResolveFile;\nmodule.exports.updateGitIgnore = updateGitIgnore;\nmodule.exports.updateSourceApiVersion = updateSourceApiVersion;\nmodule.exports.getApiVersion = getApiVersion;\nmodule.exports.validateGitStatus = validateGitStatus;\nmodule.exports.pushChangesToRemoteBranch = pushChangesToRemoteBranch;\nmodule.exports.logger = logger;\n\n// EXECUTION\n\n!isTest && this.execute();",
                    "copado__Type__c": "Standard",
                    "copado__Worker_Size__c": "S",
                    "Id": "a0l7Q000000Og66QAC",
                    "LastReferencedDate": "2023-05-11T11:10:37.000+0000",
                    "LastViewedDate": "2023-05-11T11:10:37.000+0000",
                    "Name": "Initialize Git With SFDX Project"
                },
                {
                    "attributes": {
                      "type": "copado__Function__c",
                      "url": "/services/data/v58.0/sobjects/copado__Function__c/a0l7Q00000D1gMjQAJ"
                    },
                    "copado__API_Name__c": "vlocity_retrieve",
                    "copado__Image_Name__c": "copado-multicloud-vlocity:v1",
                    "copado__Options__c": "[ ]",
                    "copado__Parameters__c": "[ {\n  \"required\" : false,\n  \"name\" : \"fileChangesId\",\n  \"defaultValue\" : \"{$Context.JobExecution__r.DataJson.fileWithSelectedChanges}\"\n}, {\n  \"required\" : true,\n  \"name\" : \"sourceSessionId\",\n  \"defaultValue\" : \"{$Source.Credential.SessionId}\"\n}, {\n  \"required\" : true,\n  \"name\" : \"sourceEndPoint\",\n  \"defaultValue\" : \"{$Source.Credential.Endpoint}\"\n}, {\n  \"required\" : true,\n  \"name\" : \"sourceDirectory\",\n  \"defaultValue\" : \"vlocity\"\n}, {\n  \"required\" : true,\n  \"name\" : \"copadoCommitFileName\",\n  \"defaultValue\" : \"Copado Commit changes\"\n}, {\n  \"name\" : \"maxDepth\",\n  \"defaultValue\" : \"0\"\n}, {\n  \"name\" : \"selectedDataPacks\",\n  \"defaultValue\" : \"\"\n}, {\n  \"name\" : \"vlocitySettingsDocumentId\",\n  \"defaultValue\" : \"{$Context.apex.cmcSf.VlocitySettingsSourceId}\"\n} ]",
                    "copado__Script__c": "#!/usr/bin/env node\n'use strict';\n\nconst { execSync } = require('child_process'),\n    {\n        sourceEndPoint,\n        sourceSessionId,\n        isTest,\n        fileChangesId,\n        sourceDirectory,\n        copadoCommitFileName,\n        maxDepth,\n        selectedDataPacks,\n        vlocitySettingsDocumentId\n    } = process.env,\n    fs = require('fs'),\n    js_yaml = isTest ? require('js-yaml') : require('/usr/local/lib/node_modules/js-yaml'),\n    TEMP_DIRECTORY = getPath('/tmp'),\n    VLOCITY_CATEGORY = 'Vlocity',\n    ADD_ACTION = 'Add',\n    JOB_FILE = 'jobfile.yaml',\n    VLOCITY_SETTINGS_YAML_FILE = 'vlocity-settings',\n    maxDepthPackExport = parseInt(maxDepth),\n    baseUrl = sourceEndPoint?.substring(0, sourceEndPoint?.indexOf('/', sourceEndPoint?.indexOf('/') + 2));\n\n// SCRIPT FUNCTIONS\n\nfunction execute() {\n    try {\n        const changes = this.getCommitChanges(selectedDataPacks);\n        const vlocitySelections = this.getVlocitySelections(changes);\n        if (vlocitySelections?.length) {\n            this.createJobFile(JOB_FILE, vlocitySelections);\n            this.updateJobFileFromSettings(vlocitySettingsDocumentId, JOB_FILE, selectedDataPacks);\n            this.retrieveVlocityDataPacks(JOB_FILE, maxDepthPackExport);\n        } else if (selectedDataPacks && !vlocitySelections?.length) {\n            execSync(this.showError('Select at least one vlocity datapack to get dependencies'));\n        } else {\n            execSync(`copado -p 'No vlocity changes'`, { stdio: 'inherit' });\n        }\n    } catch (err) {\n        //Error status = 3, is when we have Custom Error Message, where error is already populated on result and hence we do not need to call it again.\n        if (err?.status === 3) {\n            process.exit(1);\n        }\n        execSync(this.showError(err?.toString()));\n    }\n}\n\nfunction downloadFile(fileId, downloadDir, fileName) {\n    execSync(\n        `\n            copado -p 'Retrieve vlocity selections'\n            copado --downloadfiles ${fileId} --downloaddir ${downloadDir} || (${showError('Error downloading file ' + fileName)})\n        `,\n        { stdio: 'inherit' }\n    );\n}\n\nfunction retrieveVlocityDataPacks(jobFile) {\n    const vlocityCmd = `vlocity -sf.instanceUrl ${baseUrl} -sf.sessionId ${sourceSessionId} -job ${jobFile} packExport  --json || true`;\n    this.logger('Vlocity Command: ' + vlocityCmd);\n    this.logger('jobfile.yaml: ' + fs.readFileSync(jobFile, 'utf-8'));\n\n    const retrievedDataPacks = JSON.parse(execSync(vlocityCmd).toString());\n    this.logger(JSON.stringify(retrievedDataPacks, null, 2));\n    if (retrievedDataPacks?.status === 'error') {\n        execSync(this.showError(retrievedDataPacks?.message));\n    }\n    this.updateResult(selectedDataPacks, retrievedDataPacks);\n}\n\nfunction createJobFile(jobFile, vlocityDataPacks) {\n    const jobFileParameters = this.defaultJobParameters(vlocityDataPacks);\n    fs.writeFileSync(jobFile, js_yaml.dump(jobFileParameters), 'utf8');\n}\n\nfunction defaultJobParameters(vlocityDataPacks) {\n    return {\n        projectPath: `./${sourceDirectory}`,\n        oauthConnection: true,\n        autoUpdateSettings: true,\n        separateMatrixVersions: true,\n        separateCalculationProcedureVersions: true,\n        maxDepth: parseInt(maxDepth),\n        manifest: vlocityDataPacks.map((currentData) => {\n            return JSON.parse(currentData.j)?.vk;\n        })\n    };\n}\n\nfunction updateJobFileFromSettings(vlocitySettingsDocumentId, jobFileName, isRetrievingDependencies) {\n    if (vlocitySettingsDocumentId) {\n        this.downloadFile(vlocitySettingsDocumentId, TEMP_DIRECTORY, VLOCITY_SETTINGS_YAML_FILE);\n        const vlocitySettings = js_yaml.load(fs.readFileSync(`${TEMP_DIRECTORY}/${VLOCITY_SETTINGS_YAML_FILE}`, 'utf-8'));\n\n        let settings = [];\n        if (isRetrievingDependencies) {\n            settings = vlocitySettings?.dependencies ? Object.keys(vlocitySettings?.dependencies) : [];\n        } else {\n            settings = vlocitySettings?.retrieve ? Object.keys(vlocitySettings.retrieve) : [];\n        }\n\n        if (settings.length) {\n            const jobYaml = js_yaml.load(fs.readFileSync(jobFileName, 'utf-8'));\n\n            settings.forEach((setting) => {\n                if (setting !== 'manifest' && setting !== 'projectPath' && setting !== 'maxDepth') {\n                    jobYaml[setting] = isRetrievingDependencies ? vlocitySettings?.dependencies[setting] : vlocitySettings.retrieve[setting];\n                }\n                if (setting === 'maxDepth' && isRetrievingDependencies) {\n                    jobYaml[setting] = vlocitySettings?.dependencies[setting];\n                }\n            });\n            fs.writeFileSync(jobFileName, js_yaml.dump(jobYaml), 'utf8');\n            this.logger('Vlocity Settings would be applied');\n        } else {\n            this.logger('Vlocity Settings not found');\n        }\n    }\n}\n\nfunction showError(error) {\n    const refinedErrorMsg = maskSensitiveInformation(error, { '-sf.sessionId': '*****' });\n    return `copado -p 'Error' -e ${JSON.stringify(refinedErrorMsg).replace(/\\\\n/g, '\\n').replace(/\\\\t/g, '\\t')} ${isTest ? '' : '&& exit 3'}`;\n}\n\nfunction logger(text) {\n    console.log(text);\n}\n\nfunction maskSensitiveInformation(data, sensitiveFlags) {\n    const maskingSequence = '*****';\n\n    const arrayOfData = data.split(' ');\n    Object.keys(sensitiveFlags).forEach((subStr) => {\n        const keyIndex = arrayOfData.indexOf(subStr);\n        if (keyIndex > -1) {\n            arrayOfData[keyIndex + 1] = maskingSequence;\n            arrayOfData.splice(keyIndex + 2, sensitiveFlags[subStr].split(' ').length - 1);\n        }\n    });\n    return arrayOfData.join(' ');\n}\n\nfunction getPath(filePath) {\n    return isTest ? `${__dirname}/__tests__/__mockDir__${filePath}` : filePath;\n}\n\nfunction getFileDetails(dir, fileName) {\n    let downloadedFileName;\n    if (fs.existsSync(`${dir}/${fileName}`)) {\n        downloadedFileName = fileName;\n    } else if (fs.existsSync(`${dir}/${fileName}.json`)) {\n        downloadedFileName = `${fileName}.json`;\n    } else {\n        throw 'Error fetching Commit Changes';\n    }\n    return this.readFromPath(`${dir}/${downloadedFileName}`);\n}\n\nfunction getCommitChanges(selectedDataPacks) {\n    let changes;\n    if (selectedDataPacks) {\n        changes = JSON.parse(selectedDataPacks);\n    } else {\n        this.downloadFile(fileChangesId, TEMP_DIRECTORY, copadoCommitFileName);\n        changes = this.getFileDetails(TEMP_DIRECTORY, copadoCommitFileName);\n    }\n    return changes;\n}\n\nfunction updateResult(selectedDataPacks, retrievedDataPacks) {\n    if (selectedDataPacks) {\n        const records = retrievedDataPacks?.records\n            ?.filter((record) => record.VlocityDataPackStatus === 'Success')\n            ?.map((record) => ({\n                Operation: ADD_ACTION,\n                MemberName: record?.VlocityDataPackDisplayLabel,\n                MemberType: record?.VlocityDataPackType,\n                OtherInformation: JSON.stringify({ vk: record?.VlocityDataPackKey })\n            }));\n        execSync(`copado -p 'Updating results' -r '${JSON.stringify(records)}'`, { stdio: 'inherit' });\n    }\n}\n\nfunction readFromPath(filePath) {\n    if (!fs.existsSync(filePath)) {\n        throw `Could not find file at path: ${filePath}`;\n    }\n    const data = fs.readFileSync(filePath, 'utf-8');\n    let result;\n    try {\n        result = JSON.parse(data);\n    } catch (err) {\n        throw `Content at ${filePath} is not a valid JSON`;\n    }\n    return result;\n}\n\nfunction getVlocitySelections(changes) {\n    return changes?.filter((selected) => selected.c === VLOCITY_CATEGORY && selected.a === ADD_ACTION);\n}\n\nmodule.exports.execute = execute;\nmodule.exports.logger = logger;\nmodule.exports.showError = showError;\nmodule.exports.maskSensitiveInformation = maskSensitiveInformation;\nmodule.exports.downloadFile = downloadFile;\nmodule.exports.getPath = getPath;\nmodule.exports.getFileDetails = getFileDetails;\nmodule.exports.readFromPath = readFromPath;\nmodule.exports.retrieveVlocityDataPacks = retrieveVlocityDataPacks;\nmodule.exports.getVlocitySelections = getVlocitySelections;\nmodule.exports.getCommitChanges = getCommitChanges;\nmodule.exports.updateResult = updateResult;\nmodule.exports.createJobFile = createJobFile;\nmodule.exports.defaultJobParameters = defaultJobParameters;\nmodule.exports.updateJobFileFromSettings = updateJobFileFromSettings;\n\n// EXECUTION\n\n!isTest && this.execute();",
                    "copado__Type__c": "Standard",
                    "copado__Version__c": "1",
                    "copado__Worker_Size__c": "M",
                    "Id": "a0l7Q00000D1gMjQAJ",
                    "LastReferencedDate": "2023-06-30T09:02:23.000+0000",
                    "LastViewedDate": "2023-06-30T09:02:23.000+0000",
                    "Name": "Vlocity Retrieve"
                  },
                  {
                    "attributes": {
                      "type": "copado__Function__c",
                      "url": "/services/data/v58.0/sobjects/copado__Function__c/a0l7Q00000D28NjQAJ"
                    },
                    "copado__ApexClass__c": "cmcSf.RefreshVlocityCallback",
                    "copado__API_Name__c": "vlocity_refresh_index",
                    "copado__Callback_Type__c": "ApexClass",
                    "copado__Description__c": "Function to refresh Vlocity Index from Source Org",
                    "copado__Image_Name__c": "copado-multicloud-vlocity:v1",
                    "copado__Options__c": "[ ]",
                    "copado__Parameters__c": "[ {\n  \"required\" : true,\n  \"name\" : \"sessionId\",\n  \"defaultValue\" : \"{$Context.Credential.SessionId}\"\n}, {\n  \"required\" : true,\n  \"name\" : \"endpoint\",\n  \"defaultValue\" : \"{$Context.Credential.Endpoint}\"\n}, {\n  \"required\" : true,\n  \"name\" : \"credentialId\",\n  \"defaultValue\" : \"\"\n} ]",
                    "copado__Script__c": "#!/usr/bin/env node\n'use strict';\nconst { execSync } = require('child_process'),\n    { writeFileSync } = require('fs'),\n    { sessionId, endpoint, credentialId, isTest } = process.env,\n    url = endpoint.substring(0, endpoint.indexOf('/', endpoint.indexOf('/') + 2)),\n    CHECK_LOG = 'Please check the logs for details',\n    VLOCITY_CATEGORY = 'Vlocity',\n    VLOCITY_FILE = 'Vlocity.json',\n    js_yaml = isTest ? require('js-yaml') : require('/usr/local/lib/node_modules/js-yaml'),\n    JOB_FILE = 'jobfile.yaml';\n\nfunction execute() {\n    try {\n        this.createJobFile(JOB_FILE);\n        const packGetAllAvailable = this.retrieveVlocityAllAvailableExports(JOB_FILE);\n        const records = JSON.parse(packGetAllAvailable)?.records;\n\n        const formattedOutput = this.parseOutputToValidFormat(records);\n\n        this.writeAndUploadFile(formattedOutput, VLOCITY_FILE);\n    } catch (error) {\n        if (error?.status === 3) {\n            process.exit(1);\n        }\n        execSync(this.showError(error.toString()));\n    }\n}\n\nfunction retrieveVlocityAllAvailableExports(jobFile) {\n    const packGetAllAvailableCmd = `vlocity -sf.sessionId ${sessionId} -sf.instanceUrl ${url} -job ${jobFile} packGetAllAvailableExports --json-pretty || (${this.showError(\n        `Error in refreshing Vlocity. ${CHECK_LOG}`\n    )})`;\n\n    this.logger(`Vlocity Get All Available Export Command ==> ${packGetAllAvailableCmd}`);\n\n    const result = execSync(packGetAllAvailableCmd, { maxBuffer: 50 * 1024 * 1024 });\n\n    return result;\n}\n\nfunction createJobFile(jobFile) {\n    const jobFileParameters = this.defaultJobParameters();\n\n    writeFileSync(jobFile, js_yaml.dump(jobFileParameters), 'utf8');\n}\n\nfunction defaultJobParameters() {\n    return { separateMatrixVersions: true, separateCalculationProcedureVersions: true };\n}\n\nfunction parseOutputToValidFormat(records) {\n    return records.map((record) => ({\n        t: record.VlocityDataPackType,\n        n: record.VlocityDataPackDisplayLabel,\n        j: JSON.stringify({ vk: record.VlocityDataPackKey }),\n        b: record.LastModifiedByName,\n        d: record.LastModifiedDate,\n        cb: record.CreatedByName,\n        cd: record.CreatedDate,\n        c: VLOCITY_CATEGORY\n    }));\n}\n\nfunction writeAndUploadFile(output, filePath) {\n    writeFileSync(filePath, JSON.stringify(output));\n    execSync(`copado -u '${filePath}' --parentid '${credentialId}' || (${this.showError(`Error uploading file. ${CHECK_LOG}`)})`);\n}\n\nfunction showError(error) {\n    const refinedErrorMsg = this.maskSensitiveInformation(error, { '-sf.sessionId': sessionId });\n    return `copado -p 'Error' -e ${JSON.stringify(refinedErrorMsg).replace(/\\\\n/g, '\\n')}  ${isTest ? '' : '&&  exit 3'}`;\n}\n\nfunction logger(text) {\n    console.log(text);\n}\n\nfunction maskSensitiveInformation(data, sensitiveFlags) {\n    const maskingSequence = '*****';\n\n    const arrayOfData = data.split(' ');\n    Object.keys(sensitiveFlags).forEach((subStr) => {\n        const keyIndex = arrayOfData.indexOf(subStr);\n        if (keyIndex > -1) {\n            arrayOfData[keyIndex + 1] = maskingSequence;\n            arrayOfData.splice(keyIndex + 2, sensitiveFlags[subStr].split(' ').length - 1);\n        }\n    });\n    return arrayOfData.join(' ');\n}\n\nmodule.exports.execute = execute;\nmodule.exports.retrieveVlocityAllAvailableExports = retrieveVlocityAllAvailableExports;\nmodule.exports.parseOutputToValidFormat = parseOutputToValidFormat;\nmodule.exports.writeAndUploadFile = writeAndUploadFile;\nmodule.exports.createJobFile = createJobFile;\nmodule.exports.defaultJobParameters = defaultJobParameters;\nmodule.exports.showError = showError;\nmodule.exports.logger = logger;\nmodule.exports.maskSensitiveInformation = maskSensitiveInformation;\n\n!isTest && this.execute();",
                    "copado__Type__c": "Standard",
                    "copado__Worker_Size__c": "S",
                    "Id": "a0l7Q00000D28NjQAJ",
                    "LastReferencedDate": "2023-07-21T02:22:19.000+0000",
                    "LastViewedDate": "2023-07-21T02:22:19.000+0000",
                    "Name": "Vlocity Refresh Index"
                  },
                  {
                    "attributes": {
                      "type": "copado__Function__c",
                      "url": "/services/data/v58.0/sobjects/copado__Function__c/a0l7Q00000D2yXGQAZ"
                    },
                    "copado__API_Name__c": "deploy_vlocity",
                    "copado__Image_Name__c": "copado-multicloud-vlocity:v1",
                    "copado__Options__c": "[ ]",
                    "copado__Parameters__c": "[ {\n  \"name\" : \"promotionBranch\",\n  \"defaultValue\" : \"{$Context.JobExecution__r.DataJson.promotionBranchName}\"\n}, {\n  \"name\" : \"targetBranch\",\n  \"defaultValue\" : \"{$Context.JobExecution__r.DataJson.destinationBranchName}\"\n}, {\n  \"name\" : \"destinationInstanceUrl\",\n  \"defaultValue\" : \"{$Destination.Credential.Endpoint}\"\n}, {\n  \"name\" : \"destinationSessionid\",\n  \"defaultValue\" : \"{$Destination.Credential.SessionId}\"\n}, {\n  \"name\" : \"validationId\",\n  \"defaultValue\" : \"{$Job.ExecutionParent.Promotion__r.cmcSf__Validate_Deploy_Request_Id__c}\"\n}, {\n  \"name\" : \"gitName\",\n  \"defaultValue\" : \"{$User.Name}\"\n}, {\n  \"name\" : \"gitEmail\",\n  \"defaultValue\" : \"{$User.Email}\"\n}, {\n  \"name\" : \"gitDepth\",\n  \"defaultValue\" : \"100\"\n}, {\n  \"name\" : \"maxBuffer\",\n  \"defaultValue\" : \"5242880\"\n}, {\n  \"name\" : \"hasVlocityChanges\",\n  \"defaultValue\" : \"{$Context.apex.cmcSf.HasVlocityChanges}\"\n}, {\n  \"name\" : \"isValidation\",\n  \"defaultValue\" : \"{$Context.JobExecution__r.DataJson.deploymentDryRun}\"\n}, {\n  \"name\" : \"vlocityDirectory\",\n  \"defaultValue\" : \"vlocity\"\n}, {\n  \"name\" : \"git_json\",\n  \"defaultValue\" : \"{$Context.Repository.Credential}\"\n}, {\n  \"name\" : \"repository_id\",\n  \"defaultValue\" : \"{$Pipeline.Git_Repository__r.Id}\"\n}, {\n  \"name\" : \"file_changes_id\",\n  \"defaultValue\" : \"{$Context.JobExecution__r.DataJson.fileWithSelectedChanges}\"\n}, {\n  \"name\" : \"file_name\",\n  \"defaultValue\" : \"Copado Deploy changes\"\n}, {\n  \"name\" : \"attachVlocityLogFile\",\n  \"defaultValue\" : \"{$Job.ExecutionParent.Promotion__r.cmcSf__Attach_Vlocity_Build_File__c}\"\n}, {\n  \"name\" : \"vlocitySettingsDocumentId\",\n  \"defaultValue\" : \"{$Context.apex.cmcSf.VlocitySettingsDestinationId}\"\n} ]",
                    "copado__Script__c": "#!/usr/bin/env node\n'use strict';\n\n/**\n * Performs deploy of selected user story metadata changes.\n * Returns (If ACTION success) destination branch with merged changes of the user story metadata\n * (If ACTION failed) Returns details with error status on the job execution\n\n * @param promotionBranch\n * @param targetBranch\n * @param destinationInstanceUrl\n * @param destinationSessionid\n * @param isValidation\n * @param gitName\n * @param gitEmail\n * @param maxBuffer\n * @param vlocityDirectory\n * @param hasVlocityChanges\n * @param file_changes_id\n * @param file_name\n */\n\nconst child_process = require('child_process'),\n    fs = require('fs'),\n    { env } = require('process'),\n    {\n        destinationSessionid,\n        promotionBranch,\n        targetBranch,\n        destinationInstanceUrl,\n        gitDepth,\n        isTest,\n        hasVlocityChanges,\n        isValidation,\n        vlocityDirectory,\n        file_changes_id,\n        file_name,\n        attachVlocityLogFile,\n        vlocitySettingsDocumentId\n    } = env,\n    url = destinationInstanceUrl.substring(0, destinationInstanceUrl.indexOf('/', destinationInstanceUrl.indexOf('/') + 2)),\n    APP_DIRECTORY = getPath('/app'),\n    js_yaml = isTest ? require('js-yaml') : require('/usr/local/lib/node_modules/js-yaml'),\n    TEMP_DIRECTORY = getPath('/tmp'),\n    TARGET_DIRECTORY = `${APP_DIRECTORY}/repository`,\n    ENCODED_CHANGES_FILE = 'encoded_changes.json',\n    JOB_FILE = 'jobfile.yaml',\n    STDIO = {\n        INHERIT: 'inherit',\n        PIPE: 'pipe',\n        IGNORE: 'ignore'\n    },\n    GIT_DEPTH = getGitDepth(gitDepth),\n    VLOCITY_BUILD_LOG = 'VlocityBuildLog.yaml',\n    VLOCITY_SETTINGS_YAML_FILE = 'vlocity-settings',\n    VLOCITY_TEMP = 'vlocity-temp';\n\nlet isSfMetadataPresent, isVlocityDataPackPresent;\n\n// EXECUTION\n\nasync function execute() {\n    const { targetBranch, gitEmail, gitName } = env;\n\n    try {\n        this.checkChangesWrtCategory(`${APP_DIRECTORY}/${ENCODED_CHANGES_FILE}`);\n        const vlocityChanges = this.getVlocityChanges(file_name, file_changes_id);\n\n        //TODO: Promotion and merge to be improved to run conditionally.\n        this.fetchPromotionBranch(promotionBranch, GIT_DEPTH);\n        this.configureGit(gitEmail, gitName);\n        this.gitMergePromotionToTarget(promotionBranch, targetBranch, GIT_DEPTH);\n\n        this.writeJobFile(JOB_FILE, vlocityChanges);\n        this.updateJobFileFromSettings(vlocitySettingsDocumentId, JOB_FILE);\n        this.validateVlocityData(JOB_FILE);\n        this.deployVlocity(JOB_FILE, attachVlocityLogFile === 'true');\n\n        this.logger(`Pushing the changes to ${targetBranch}`);\n        const pushToRemote = [this.pushChangesToRemote(targetBranch)];\n        await Promise.all([...pushToRemote, this.cleanDeploymentFiles()]);\n    } catch (err) {\n        this.executeCommand(this.getErrorCmdString(err.toString()));\n        if (!isTest) {\n            process.exit(1);\n        }\n    }\n}\n\n// SCRIPT FUNCTIONS\n\nfunction checkChangesWrtCategory(sfdxFilePath) {\n    isSfMetadataPresent = fs.existsSync(sfdxFilePath);\n    isVlocityDataPackPresent = hasVlocityChanges?.toLowerCase() === 'true';\n\n    if (isSfMetadataPresent) {\n        this.logger('Salesforce changes found.');\n    } else {\n        this.logger('Salesforce changes not found.');\n    }\n\n    if (isVlocityDataPackPresent) {\n        this.logger('Vlocity changes found.');\n    } else {\n        this.logger('Vlocity changes not found.');\n        this.executeCommand(`copado -p 'No Vlocity datapacks'`);\n    }\n\n    if (!isVlocityDataPackPresent || isValidation === 'true') {\n        this.executeCommand(`copado -p \"Exiting Vlocity Deployment Step\"`);\n        process.exit(0);\n    }\n}\n\nfunction getVlocityChanges(fileName, fileChangesId) {\n    this.executeCommand(`copado --downloadfiles ${fileChangesId} --downloaddir /tmp/`);\n    let downloadedFileName;\n    if (fs.existsSync(`/tmp/${fileName}`)) {\n        downloadedFileName = fileName;\n    } else if (fs.existsSync(`/tmp/${fileName}.json`)) {\n        downloadedFileName = `${fileName}.json`;\n    } else {\n        throw 'Error fetching Deployment Changes';\n    }\n    const deploymentMetadata = this.readFromPath(`/tmp/${downloadedFileName}`);\n    return deploymentMetadata.filter((element) => element.c === 'Vlocity');\n}\n\nfunction writeJobFile(jobFile, vlocityChanges) {\n    const jobFileParameters = this.defaultJobParameters(vlocityChanges);\n    fs.writeFileSync(jobFile, js_yaml.dump(jobFileParameters), 'utf8');\n}\n\nfunction defaultJobParameters(vlocityDataPacks) {\n    return {\n        projectPath: `./${vlocityDirectory}`,\n        oauthConnection: true,\n        autoUpdateSettings: true,\n        separateMatrixVersions: true,\n        separateCalculationProcedureVersions: true,\n        reactivateOmniScriptsWhenEmbeddedTemplateFound: true,\n        manifest: vlocityDataPacks.map((currentData) => {\n            return JSON.parse(currentData.j)?.vk;\n        })\n    };\n}\n\nfunction updateJobFileFromSettings(vlocitySettingsDocumentId, jobFileName) {\n    if (vlocitySettingsDocumentId) {\n        this.downloadFile(vlocitySettingsDocumentId, TEMP_DIRECTORY, VLOCITY_SETTINGS_YAML_FILE);\n        const vlocitySettings = js_yaml.load(fs.readFileSync(`${TEMP_DIRECTORY}/${VLOCITY_SETTINGS_YAML_FILE}`, 'utf-8'));\n        let settings = vlocitySettings?.deploy ? Object.keys(vlocitySettings.deploy) : [];\n\n        if (settings.length) {\n            const jobYaml = js_yaml.load(fs.readFileSync(jobFileName, 'utf-8'));\n            settings.forEach((setting) => {\n                if (setting !== 'manifest' && setting !== 'projectPath' && setting !== 'maxDepth') {\n                    jobYaml[setting] = vlocitySettings.deploy[setting];\n                }\n            });\n            fs.writeFileSync(jobFileName, js_yaml.dump(jobYaml), 'utf8');\n            this.logger('Vlocity Settings would be applied');\n        } else {\n            this.logger('Vlocity Settings not found');\n        }\n    }\n}\n\nfunction downloadFile(fileId, downloadDir, fileName) {\n    this.executeCommand(`\n        copado -p 'Retrieve vlocity selections'\n        copado --downloadfiles ${fileId} --downloaddir ${downloadDir} || (${this.getErrorCmdString('Error downloading file ' + fileName)})\n    `);\n}\n\nfunction validateVlocityData(jobFile) {\n    const validateVlocityDataPacks = `copado -p \"Validating Vlocity DataPacks\"\n    vlocity -sf.sessionId ${destinationSessionid} -sf.instanceUrl ${url} -job ${jobFile} validateLocalData --json-pretty || ${this.getErrorCmdString(\n        'Failure while validating Vlocity DataPacks'\n    )}`;\n\n    const response = this.executeCommand(validateVlocityDataPacks);\n    this.evaluateResponse(response);\n}\n\nfunction deployVlocity(jobFile, attachFile) {\n    const deployVlocityCommand = `copado -p \"Deploying Vlocity DataPacks\"\n    vlocity -sf.sessionId ${destinationSessionid} -sf.instanceUrl ${url} -job ${jobFile} packDeploy --json-pretty || ${this.getErrorCmdString(\n        'Failure while deploying Vlocity DataPacks'\n    )}`;\n\n    this.logger('Deploy Command: ' + deployVlocityCommand);\n    this.logger('jobfile.yaml \\n' + fs.readFileSync(jobFile, 'utf-8'));\n\n    const response = this.executeCommand(deployVlocityCommand);\n    if (attachFile || JSON.parse(response)?.status === 'error') {\n        this.uploadFile(VLOCITY_BUILD_LOG);\n    }\n    this.evaluateResponse(response);\n}\n\nfunction fetchPromotionBranch(promotionBranch, gitDepth) {\n    fs.mkdirSync(TARGET_DIRECTORY, { recursive: true });\n    process.chdir(TARGET_DIRECTORY);\n\n    this.executeCommand(\n        `\n            copado --progress \"fetching ${promotionBranch}\"\n            copado-git-get \"${promotionBranch}\" --depth \"${gitDepth}\" || ${this.getErrorCmdString('Error fetching ' + promotionBranch)}\n        `,\n        STDIO.INHERIT\n    );\n}\n\nfunction configureGit(gitEmail, gitName) {\n    const configureGit = `\n        git config --local user.email \"${gitEmail}\" || ${this.getErrorCmdString('Failure in configuring git user email')}\n        git config --local user.name \"${gitName}\" || ${this.getErrorCmdString('Failure in configuring git user name')}\n        git config --global diff.renames false || ${this.getErrorCmdString('Failure in disabling git rename detection from diff.renames')}\n        git config --global merge.renames false || ${this.getErrorCmdString('Failure in disabling git rename detection from merge.renames')}\n        git config --global status.renames false || ${this.getErrorCmdString('Failure in disabling git rename detection from status.renames')}\n        `;\n    this.executeCommand(`${configureGit}`, STDIO.INHERIT);\n}\n\nfunction cleanDeploymentFiles() {\n    const cleanUp = `\n        git reset --hard\n    `;\n    return new Promise((resolve, reject) => {\n        child_process.exec(cleanUp, this.getOptions(), (error, stdout, stderr) => {\n            this.handleResponse(error, stdout, stderr, reject);\n            resolve();\n        });\n    });\n}\n\nfunction gitMergePromotionToTarget(promotionBranch, targetBranch, gitDepth) {\n    let checkoutTargetBranch = `\n        git reset --hard || exit 2\n        copado --progress \"Locally merging ${promotionBranch} into ${targetBranch}\"\n        ${this.fetchCheckoutBranch(targetBranch, gitDepth, false, `Error fetching branch ${targetBranch}`)}`;\n\n    this.executeCommand(checkoutTargetBranch);\n\n    try {\n        const merge = `git merge \"${promotionBranch}\"  --no-commit -Xignore-space-change`;\n        this.executeCommand(merge, STDIO.PIPE);\n    } catch (error) {\n        this.evaluateMergeStatus();\n        throw error;\n    }\n    this.commitGit(`Merging ${promotionBranch} into ${targetBranch} after auto conflict resolution`);\n}\n\nfunction commitGit(commitMessage) {\n    this.executeCommand(\n        `git add . ':!${VLOCITY_BUILD_LOG}' ':!${JOB_FILE}' ':!${VLOCITY_TEMP}/*' ||  ${this.getErrorCmdString(\n            'There was some issue when staging changes'\n        )} # add all the resolved changes, if any \n        git commit -am \"${commitMessage}\" || true`,\n        STDIO.INHERIT\n    );\n}\n\nfunction evaluateMergeStatus() {\n    const gitStatus = this.executeCommand('git status --porcelain=v1 -uno'),\n        porcelainStatus = gitStatus.split('\\n').map((str) => str.split(' ')?.[0]),\n        isConflict = porcelainStatus.length ? ['AA', 'UU', 'DD', 'UA', 'UD', 'DU', 'AU'].some((s) => porcelainStatus.includes(s)) : false;\n    let infoMessage;\n\n    if (isConflict)\n        this.executeCommand(\n            this.getErrorCmdString(\n                `Changes detected in target branch '${targetBranch}' after promotion branch '${promotionBranch}' was created, please recreate promotion branch out of the new target branch state.`\n            )\n        );\n    else if (!gitStatus) {\n        infoMessage = 'Already up to date';\n    } else {\n        infoMessage = `Changes detected in target branch '${targetBranch}' after promotion branch '${promotionBranch}' was created.`;\n    }\n    infoMessage && this.executeCommand(`copado -p \"${infoMessage}\"`);\n    console.log(infoMessage);\n}\n\nfunction pushChangesToRemote(remoteBranchName) {\n    const push = `\n        copado --progress \"Push changes into remote ${targetBranch} branch\"\n        git push origin \"${remoteBranchName}\" || ${this.getErrorCmdString('Could not push the changes to ' + remoteBranchName)}`;\n    return new Promise((resolve, reject) => {\n        child_process.exec(push, this.getOptions(), (error, stdout, stderr) => {\n            this.handleResponse(error, stdout, stderr, reject);\n            resolve();\n        });\n    });\n}\n\nfunction getErrorCmdString(error) {\n    const suffix = 'Please check the logs for details.';\n    return `{ copado -p \"Error\" -e \"${error.trim()}; ${suffix}\"; exit 2; }`;\n}\n\nfunction executeCommand(cmd, ioconfig) {\n    const response = child_process.spawnSync(cmd, this.getOptions(ioconfig));\n    const { output, error } = log(response);\n    if (response?.status != 0) {\n        if (response?.status == 2) {\n            if (isTest) {\n                throw output;\n            }\n            process.exit(2);\n        }\n        throw error ? error : `Error executing the command ${cmd}`;\n    }\n    return output;\n}\n\nfunction evaluateResponse(response) {\n    response = JSON.parse(response);\n    if (response?.status === 'error' && response?.message) {\n        this.handleDeploymentErrors(response);\n    }\n\n    if (response?.status === 'success' && response?.message === '0 Completed') {\n        this.executeCommand(this.getErrorCmdString(`No output processed `));\n    }\n}\n\nfunction handleDeploymentErrors(response) {\n    let errorCount = 0, successCount = 0, warningCount = 0;\n    response?.records.forEach(record => {\n        if(record?.VlocityDataPackStatus === 'Success') {\n            this.logger(`INFO: Deployment was successful for ${record?.VlocityDataPackDisplayLabel}`);\n            successCount++;\n        }\n        else if(record?.VlocityDataPackStatus === 'Error') {\n            if(record?.ErrorMessage.includes('Activation Error >>')) {\n                this.logger(`WARNING: ${record?.ErrorMessage}`);\n                warningCount++;\n                return;\n            }\n            this.logger(`ERROR: ${record?.ErrorMessage}`);\n            errorCount++;\n        }\n    })\n\n    if(warningCount > 0) {\n        this.executeCommand(`copado -p 'Warnings during deployment'`);\n    }\n\n    if(successCount > 0 && errorCount > 0) {\n        this.executeCommand(`copado -p 'Git merge aborted due to errors'`);\n        this.logger(`ERROR: Some datapacks were successfully deployed but the changes were not merged into the destination branch.`);\n    }\n\n    if(errorCount > 0) {\n        this.executeCommand(this.getErrorCmdString(`Deployment for following DataPacks failed : ${response.message}`));\n    } \n\n}\n\nfunction getPath(filePath) {\n    return isTest ? `${__dirname}/__tests__/__mockDir__${filePath}` : filePath;\n}\n\nfunction getGitDepth(gitDepth) {\n    gitDepth = parseInt(gitDepth);\n    return gitDepth >= 0 ? gitDepth : 100;\n}\n\nfunction fetchCheckoutBranch(branch, gitDepth, forceCreate, error) {\n    return (\n        `( git fetch origin ${branch} --depth ${gitDepth} && git checkout ${branch} )` +\n        (forceCreate ? ` || git checkout -b ${branch}` : '') +\n        ` || ${this.getErrorCmdString(error)}`\n    );\n}\n\nfunction handleResponse(error, stdout, stderr, reject) {\n    if (stdout) {\n        console.log(stdout);\n    }\n    if (stderr) {\n        console.log(stderr);\n    }\n    if (error) {\n        if (reject) {\n            reject(stderr?.toString());\n        }\n        if (error.code == 2) {\n            process.exit(2);\n        } else {\n            throw error;\n        }\n    }\n}\n\nfunction getOptions(ioconfig) {\n    const { maxBuffer } = env;\n    const options = {\n        shell: true,\n        maxBuffer: parseInt(maxBuffer)\n    };\n    if (ioconfig) {\n        options.stdio = ioconfig;\n    }\n    return options;\n}\n\nfunction logger(text) {\n    console.log(text);\n}\n\nfunction log(response) {\n    const output = response?.stdout?.toString().trim();\n    const error = response?.stderr?.toString().trim();\n    if (output) {\n        console.log(output);\n    }\n    if (error) {\n        console.log(error);\n    }\n    return { output, error };\n}\n\nfunction readFromPath(filePath) {\n    return JSON.parse(fs.readFileSync(filePath, 'utf-8'));\n}\n\nfunction uploadFile(fileName) {\n    this.executeCommand(`copado --uploadfile ${fileName} || (${this.getErrorCmdString(`Error uploading ${fileName}`)})`);\n}\n\nmodule.exports.execute = execute;\nmodule.exports.fetchPromotionBranch = fetchPromotionBranch;\nmodule.exports.configureGit = configureGit;\nmodule.exports.gitMergePromotionToTarget = gitMergePromotionToTarget;\nmodule.exports.getGitDepth = getGitDepth;\nmodule.exports.handleResponse = handleResponse;\nmodule.exports.getOptions = getOptions;\nmodule.exports.defaultJobParameters = defaultJobParameters;\nmodule.exports.writeJobFile = writeJobFile;\nmodule.exports.getVlocityChanges = getVlocityChanges;\nmodule.exports.validateVlocityData = validateVlocityData;\nmodule.exports.handleResponse = handleResponse;\nmodule.exports.pushChangesToRemote = pushChangesToRemote;\nmodule.exports.cleanDeploymentFiles = cleanDeploymentFiles;\nmodule.exports.getOptions = getOptions;\nmodule.exports.deployVlocity = deployVlocity;\nmodule.exports.commitGit = commitGit;\nmodule.exports.evaluateMergeStatus = evaluateMergeStatus;\nmodule.exports.fetchCheckoutBranch = fetchCheckoutBranch;\nmodule.exports.checkChangesWrtCategory = checkChangesWrtCategory;\nmodule.exports.executeCommand = executeCommand;\nmodule.exports.evaluateResponse = evaluateResponse;\nmodule.exports.getErrorCmdString = getErrorCmdString;\nmodule.exports.log = log;\nmodule.exports.logger = logger;\nmodule.exports.readFromPath = readFromPath;\nmodule.exports.uploadFile = uploadFile;\nmodule.exports.updateJobFileFromSettings = updateJobFileFromSettings;\nmodule.exports.downloadFile = downloadFile;\nmodule.exports.handleDeploymentErrors = handleDeploymentErrors;\n\n!isTest && this.execute();",
                    "copado__Timeout__c": 120,
                    "copado__Type__c": "Standard",
                    "copado__Worker_Size__c": "M",
                    "Id": "a0l7Q00000D2yXGQAZ",
                    "LastReferencedDate": "2023-07-21T02:21:45.000+0000",
                    "LastViewedDate": "2023-07-21T02:21:45.000+0000",
                    "Name": "Deploy Vlocity"
                  },
                {
                    "attributes": {
                      "type": "copado__Function__c",
                      "url": "/services/data/v58.0/sobjects/copado__Function__c/a0l7Q000000OyrMQAS"
                    },
                    "copado__API_Name__c": "SFDX_Data_Deploy",
                    "copado__Image_Name__c": "copado-multicloud-dx:v3",
                    "copado__Options__c": "[ ]",
                    "copado__Parameters__c": "[ {\n  \"required\" : true,\n  \"name\" : \"dataTemplateDetail\",\n  \"defaultValue\" : \"{$Context.Apex.cmcSf.GetDataTemplatePayload}\"\n}, {\n  \"required\" : true,\n  \"name\" : \"sourceOrgId\",\n  \"defaultValue\" : \"{$Source.Id}\"\n}, {\n  \"required\" : true,\n  \"name\" : \"sourceInstanceUrl\",\n  \"defaultValue\" : \"{$Source.Credential.Endpoint}\"\n}, {\n  \"required\" : true,\n  \"name\" : \"sourceSessionId\",\n  \"defaultValue\" : \"{$Source.Credential.SessionId}\"\n}, {\n  \"required\" : true,\n  \"name\" : \"destinationOrgId\",\n  \"defaultValue\" : \"{$Destination.Id}\"\n}, {\n  \"required\" : true,\n  \"name\" : \"destinationInstanceUrl\",\n  \"defaultValue\" : \"{$Destination.Credential.Endpoint}\"\n}, {\n  \"required\" : true,\n  \"name\" : \"destinationSessionId\",\n  \"defaultValue\" : \"{$Destination.Credential.SessionId}\"\n}, {\n  \"required\" : true,\n  \"name\" : \"maxBuffer\",\n  \"defaultValue\" : \"5242880\"\n}, {\n  \"required\" : true,\n  \"name\" : \"host\",\n  \"defaultValue\" : \"https://na.api.copado.com\"\n}, {\n  \"required\" : true,\n  \"name\" : \"pollInterval\",\n  \"defaultValue\" : \"5000\"\n}, {\n  \"required\" : true,\n  \"name\" : \"isValidation\",\n  \"defaultValue\" : \"{$Context.JobExecution__r.DataJson.deploymentDryRun}\"\n} ]",
                    "copado__Script__c": "#!/usr/bin/env node\n'use strict';\n\n/**\n * Performs deployment of data based on the data template details provided as input\n * Returns (If ACTION success) the data records are successfully inserted/upserted from the source to the destination org\n * (If ACTION failed) Returns details with error status on the result record\n * @param sourceOrgId\n * @param sourceInstanceUrl\n * @param sourceSessionId\n * @param destinationOrgId\n * @param destinationInstanceUrl\n * @param destinationSessionId\n * @param maxBuffer\n * @param dataTemplateDetail\n */\n\nconst child_process = require('child_process'),\n    fs = require('fs'),\n    {\n        sourceOrgId,\n        sourceInstanceUrl,\n        sourceSessionId,\n        destinationOrgId,\n        destinationInstanceUrl,\n        destinationSessionId,\n        maxBuffer,\n        host,\n        pollInterval,\n        dataTemplateDetail,\n        isTest,\n        isValidation\n    } = process.env,\n    response = {\n        STATUS: {\n            REQUEST_ACCEPTED: 'REQUEST_ACCEPTED',\n            FAILED: 'FAILED',\n            COMPLETED: 'COMPLETED'\n        },\n        TYPE: {\n            JSON: 'json',\n            BUFFER: 'buffer'\n        }\n    },\n    request = {\n        GET: 'GET',\n        POST: 'POST'\n    },\n    TEMP_DIRECTORY = getPath('/tmp'),\n    RESULT_ZIP_FILE_PATH = `${TEMP_DIRECTORY}/deploymentResult.zip`,\n    DATA_DEPLOYMENT_RESULT_DIR = `${TEMP_DIRECTORY}/result`,\n    MAXBUFFER = parseInt(maxBuffer),\n    VALIDATION_MODE_MESSAGE = 'This step will not be executed for validate changes';\n\nasync function execute() {\n    try {\n        this.validateExecutionMode(isTest, isValidation, VALIDATION_MODE_MESSAGE);\n        const dataTemplatePayload = this.parseDatatemplate(dataTemplateDetail);\n        const apiPayload = this.populateCredentialsValues(dataTemplatePayload);\n        const deploymentId = await this.initiateDataDeployment(apiPayload);\n        await this.pollDataDeploymentStatus(deploymentId);\n        await this.downloadDataDeploymentResult(deploymentId);\n        this.uploadDataDeploymentInfoOnResult();\n    } catch (error) {\n        this.executeCommand(this.getErrorCmdString(error?.toString()));\n    }\n}\n\nfunction validateExecutionMode(isTest, isValidation, validationModeMessage) {\n    const isValidationDeployment = (isValidation === 'true');\n    if(isTest) {\n        return isValidationDeployment;\n    } else if (isValidationDeployment) {\n        this.executeCommand(`copado -p '${validationModeMessage}' --result-data '${validationModeMessage}'`);\n        process.exit(0);\n    }\n}\n\nfunction parseDatatemplate(dataTemplateDetail) {\n    try {\n        const payload = JSON.parse(dataTemplateDetail);\n        this.setPayloadDataLimit(payload);\n        // Added logs to debug the payload in case of an error\n        this.logger(payload);\n        return payload;\n    } catch (error) {\n        throw 'The input data template information is not a valid JSON';\n    }\n}\n\nfunction setPayloadDataLimit(payload) {\n    payload.main_template['limit'] = payload.main_template['limitValue'];\n    delete payload.main_template['limitValue'];\n    payload.related_templates?.forEach((template) => {\n        template['limit'] = template['limitValue'];\n        delete template['limitValue'];\n    }); \n}\n\nfunction populateCredentialsValues(dataTemplateDetail) {\n    const result = {\n        ...dataTemplateDetail,\n        org_credentials: {\n            source: {\n                organizationId: sourceOrgId,\n                instance: sourceInstanceUrl,\n                token: sourceSessionId\n            },\n            destination: {\n                organizationId: destinationOrgId,\n                instance: destinationInstanceUrl,\n                token: destinationSessionId\n            }\n        }\n    };\n    return result;\n}\n\nasync function initiateDataDeployment(payload) {\n    const result = await this.sendRequest('/ddapi/data_deploy', request.POST, response.TYPE.JSON, payload);\n    // Added logs to debug in case of unprecedented response from the api\n    this.logger('Initiate Data Deployment', result);\n    if (!result?.deploymentId) {\n        throw `${result.status} - ${result.errorMessage ? result.errorMessage : result.error}`;\n    }\n    return result.deploymentId;\n}\n\nfunction pollDataDeploymentStatus(deploymentId) {\n    return new Promise((resolve, reject) => {\n        this.executeCommand(`copado -p \"Polling data deployment status\"`);\n        const pollDeploymentStatus = setInterval(async () => {\n            const result = await this.sendRequest(`/ddapi/data_job/${deploymentId}/status`, request.GET, response.TYPE.JSON);\n            // Adding debug to track progress in logs\n            this.logger(result.step);\n            switch (result.status) {\n                case response.STATUS.FAILED:\n                    clearInterval(pollDeploymentStatus);\n                    reject(result.step);\n                    break;\n                case response.STATUS.COMPLETED:\n                    clearInterval(pollDeploymentStatus);\n                    resolve();\n                    break;\n            }\n        }, pollInterval);\n    });\n}\n\nasync function downloadDataDeploymentResult(deploymentId) {\n    const result = await this.sendRequest(`/ddapi/data_job/${deploymentId}/result`, request.GET, response.TYPE.BUFFER);\n    fs.writeFileSync(RESULT_ZIP_FILE_PATH, result);\n    this.executeCommand(`unzip -d ${DATA_DEPLOYMENT_RESULT_DIR} ${RESULT_ZIP_FILE_PATH}`);\n}\n\nasync function sendRequest(path, method, responseType, payload) {\n    let result;\n    try {\n        const apiResponse = await fetch(host + path, this.getOptions(method, payload));\n        switch (responseType) {\n            case response.TYPE.BUFFER:\n                result = Buffer.from(await apiResponse.arrayBuffer());\n                break;\n            case response.TYPE.JSON:\n                result = await apiResponse.json();\n                break;\n            default:\n                result = await apiResponse.text();\n        }\n    } catch (error) {\n        throw `ERROR: ${method} ${path} : ${error}`;\n    }\n    return result;\n}\n\nfunction getOptions(method, payload) {\n    const options = {\n        method: method,\n        headers: {\n            'Content-Type': 'application/json'\n        }\n    };\n    if (method === request.POST) {\n        options.body = JSON.stringify(payload);\n    }\n    return options;\n}\n\nfunction uploadDataDeploymentInfoOnResult() {\n    const DEPLOYMENT_SUMMARY_JSON = 'deployment_summary.json';\n    this.executeCommand(`copado -p 'Uploading data deployment detail files on the result record'`);\n\n    fs.readdirSync(DATA_DEPLOYMENT_RESULT_DIR, { encoding: 'utf-8' })?.forEach(file => {\n        this.executeCommand(`copado --uploadfile '${DATA_DEPLOYMENT_RESULT_DIR}/${file}'`);\n    });\n    const resultData = this.getResultData(`${DATA_DEPLOYMENT_RESULT_DIR}/${DEPLOYMENT_SUMMARY_JSON}`);\n    this.executeCommand(`copado -p 'Updating Data deployment info' -r '${resultData}'`);\n}\n\nfunction getResultData(filePath) {\n    let result = '';\n    const fileData = fs.readFileSync(filePath, 'utf-8');\n    if (fileData) {\n        const deploymentSummary = JSON.parse(fileData);\n        result = deploymentSummary\n            .map(templateDeploymentResult =>\n                Object.keys(templateDeploymentResult)\n                    .map(key => `${key} : ${templateDeploymentResult[key]}`)\n                    .join('\\n')\n            )\n            .join('\\n------------------------\\n');\n    }\n    result =\n        'To find more info related to the data deployment result, please look at the deployment_summary.json attached to this result record\\n' +\n        result;\n\n    return result.substring(0, 131070); // truncating the string to prevent the length from exceeding Long Text Area(131072) size limit\n}\n\nfunction getErrorCmdString(error) {\n    const suffix = 'Please check the logs for details.';\n    return `{ copado -p 'Error' -e \"${error?.substring(0, 32765)}. ${suffix}\"; exit 3; }`;\n}\n\nfunction getPath(filePath) {\n    return isTest ? `${__dirname}/__tests__/__mockDir__${filePath}` : filePath;\n}\n\nfunction executeCommand(cmd, ioconfig) {\n    const options = {\n        shell: true,\n        maxBuffer: MAXBUFFER\n    };\n    if (ioconfig) {\n        options.stdio = ioconfig;\n    }\n    const response = child_process.spawnSync(cmd, options);\n    const { output, error } = this.log(response);\n    if (response?.status != 0) {\n        if (response?.status == 3) {\n            process.exit(1);\n        }\n        throw error ? error : `Error executing the command: ${cmd} `;\n    }\n    return output;\n}\n\nfunction log(response) {\n    const output = response?.stdout?.toString().trim();\n    const error = response?.stderr?.toString().trim();\n    if (output) {\n        this.logger(output);\n    }\n    if (error) {\n        this.logger(error);\n    }\n    return { output, error };\n}\n\nfunction logger(value) {\n    console.log(value);\n}\n\nmodule.exports.initiateDataDeployment = initiateDataDeployment;\nmodule.exports.pollDataDeploymentStatus = pollDataDeploymentStatus;\nmodule.exports.populateCredentialsValues = populateCredentialsValues;\nmodule.exports.downloadDataDeploymentResult = downloadDataDeploymentResult;\nmodule.exports.sendRequest = sendRequest;\nmodule.exports.getOptions = getOptions;\nmodule.exports.uploadDataDeploymentInfoOnResult = uploadDataDeploymentInfoOnResult;\nmodule.exports.getErrorCmdString = getErrorCmdString;\nmodule.exports.getPath = getPath;\nmodule.exports.executeCommand = executeCommand;\nmodule.exports.log = log;\nmodule.exports.execute = execute;\nmodule.exports.getResultData = getResultData;\nmodule.exports.parseDatatemplate = parseDatatemplate;\nmodule.exports.validateExecutionMode = validateExecutionMode;\nmodule.exports.setPayloadDataLimit = setPayloadDataLimit;\nmodule.exports.logger = logger;\n\n!isTest && this.execute();",
                    "copado__Type__c": "Standard",
                    "copado__Worker_Size__c": "S",
                    "Id": "a0l7Q000000OyrMQAS",
                    "LastReferencedDate": "2023-06-06T04:39:46.000+0000",
                    "LastViewedDate": "2023-06-06T04:39:46.000+0000",
                    "Name": "SFDX Data Deploy"
                },
                {
                    "attributes": {
                      "type": "copado__Function__c",
                      "url": "/services/data/v58.0/sobjects/copado__Function__c/a0k0900000GVU24AAH"
                    },
                    "copado__API_Name__c": "sfdx_git_snapshot",
                    "copado__Image_Name__c": "copado-multicloud-dx:v3",
                    "copado__Options__c": "[ ]",
                    "copado__Parameters__c": "[ {\n  \"required\" : true,\n  \"name\" : \"git_json\",\n  \"defaultValue\" : \"{$Context.Repository.Credential}\"\n}, {\n  \"required\" : true,\n  \"name\" : \"gitName\",\n  \"defaultValue\" : \"{$User.Name}\"\n}, {\n  \"required\" : true,\n  \"name\" : \"gitEmail\",\n  \"defaultValue\" : \"{$User.Email}\"\n}, {\n  \"required\" : true,\n  \"name\" : \"sourceEndpoint\",\n  \"defaultValue\" : \"{$Source.Credential.Endpoint}\"\n}, {\n  \"required\" : true,\n  \"name\" : \"sourceSessionId\",\n  \"defaultValue\" : \"{$Source.Credential.SessionId}\"\n}, {\n  \"required\" : true,\n  \"name\" : \"branch\",\n  \"defaultValue\" : \"{$Job.ExecutionParent.copado__Branch__c}\"\n}, {\n  \"name\" : \"selectedMetadata\",\n  \"defaultValue\" : \"{$Job.ExecutionParent.copado__Scope__c}\"\n}, {\n  \"name\" : \"snapshotInformation\",\n  \"defaultValue\" : \"{$Job.ExecutionParent.copado__Other_Information__c}\"\n}, {\n  \"required\" : true,\n  \"name\" : \"metadataRefreshResult\",\n  \"defaultValue\" : \"{$Job.PrevStep.Result__r.Result_Data__c}\"\n}, {\n  \"name\" : \"overriddenApiVersion\",\n  \"defaultValue\" : \"\"\n}, {\n  \"required\" : true,\n  \"name\" : \"maximumRetryCount\",\n  \"defaultValue\" : \"1\"\n}, {\n  \"required\" : true,\n  \"name\" : \"commitMessage\",\n  \"defaultValue\" : \"{$Context.JobExecution__r.DataJson.message}\"\n}, {\n  \"required\" : true,\n  \"name\" : \"processesUsedForRetrieval\",\n  \"defaultValue\" : \"8\"\n}, {\n  \"name\" : \"environmentVariables\",\n  \"defaultValue\" : \"{$Source.apex.EnvironmentVariables}\"\n}, {\n  \"name\" : \"findAndReplaceFileId\",\n  \"defaultValue\" : \"{$Context.apex.GlobalFindAndReplaceSourceId}\"\n}, {\n  \"name\" : \"maxBuffer\",\n  \"defaultValue\" : \"5242880\"\n}, {\n  \"required\" : true,\n  \"name\" : \"metadataChunkInfo\",\n  \"defaultValue\" : \"{\\\"staticresource\\\": 10, \\\"contentasset\\\": 10}\"\n}, {\n  \"required\" : true,\n  \"name\" : \"defaultMetadataChunkInfo\",\n  \"defaultValue\" : \"5000\"\n} ]",
                    "copado__Script__c": "#!/usr/bin/env node\n'use strict';\n\n/**\n * This function takes a snapshot of the salesforce org and pushes its content in git\n * @param gitName,\n * @param gitEmail,\n * @param sourceEndpoint,\n * @param sourceSessionId,\n * @param branch,\n * @param selectedMetadata,\n * @param snapshotInformation,\n * @param metadataRefreshResult,\n * @param maximumRetryCount,\n * @param processesUsedForRetrieval,\n * @param commitMessage,\n * @param environmentVariables,\n * @param overriddenApiVersion,\n * @param findAndReplaceFileId,\n * @param maxBuffer,\n * @param API_VERSION\n */\n\nconst {\n        isTest,\n        gitName,\n        gitEmail,\n        sourceEndpoint,\n        sourceSessionId,\n        branch,\n        selectedMetadata,\n        snapshotInformation,\n        metadataRefreshResult,\n        maximumRetryCount,\n        processesUsedForRetrieval,\n        commitMessage,\n        environmentVariables,\n        overriddenApiVersion,\n        findAndReplaceFileId,\n        maxBuffer,\n        API_VERSION,\n        metadataChunkInfo,\n        defaultMetadataChunkInfo\n    } = process.env,\n    { spawnSync, spawn, exec } = require('child_process'),\n    { cpus } = require('os'),\n    STDIO = {\n        INHERIT: 'inherit',\n        PIPE: 'pipe',\n        IGNORE: 'ignore'\n    },\n    APP_DIRECTORY = getPath('/app'),\n    TEMP_DIRECTORY = getPath('/tmp'),\n    TARGET_DIRECTORY = `${APP_DIRECTORY}/repository`,\n    { existsSync, writeFileSync, readFileSync } = require('fs'),\n    CREDENTIAL_FILE_NAME = 'MetaData',\n    PROFILE = 'Profile',\n    apiVersion = getApiVersion(overriddenApiVersion, API_VERSION),\n    retryLimit = parseInt(maximumRetryCount) ? parseInt(maximumRetryCount) : 1,\n    maxAllowedProcesses = parseInt(processesUsedForRetrieval) ? parseInt(processesUsedForRetrieval) : 8,\n    additionalInfoForSnapshot = snapshotInformation ? getParsedData(snapshotInformation) : {},\n    MAXBUFFER = parseInt(maxBuffer),\n    nestedMetadataToBeBypassed = [\n        'workflowfieldupdate',\n        'workflowknowledgepublish',\n        'workflowtask',\n        'workflowalert',\n        'workflowsend',\n        'workflowoutboundmessage',\n        'workflowrule',\n        'sharingownerrule',\n        'sharingcriteriarule',\n        'sharingguestrule',\n        'sharingterritoryrule',\n        'customlabel',\n        'assignmentrule',\n        'autoresponserule',\n        'matchingrule',\n        'customfield',\n        'index',\n        'businessprocess',\n        'recordtype',\n        'compactlayout',\n        'weblink',\n        'validationrule',\n        'sharingreason',\n        'listview',\n        'fieldset'\n    ],\n    ignoredMetadata = ['document'],\n    metadataChunkSize = getParsedData(metadataChunkInfo),\n    defaultMetadataChunkSize = parseInt(defaultMetadataChunkInfo) ? parseInt(defaultMetadataChunkInfo) : 5000;\n\n// SCRIPT FUNCTIONS\n\nasync function execute() {\n    try {\n        this.asyncCopadoLogMessage('Downloading metadata details of the source environment');\n        const metadataNamesByType = this.getMetadataNamesByType(metadataRefreshResult, TEMP_DIRECTORY, CREDENTIAL_FILE_NAME);\n        const metadatasSupportedByCli = this.getMetadataSupportedByCli();\n        const selectedMetadatas = this.getSelectedMetadatas(selectedMetadata);\n        const profiles = this.getProfilesForRetrieval(\n            metadataNamesByType,\n            selectedMetadatas,\n            metadatasSupportedByCli,\n            PROFILE,\n            apiVersion,\n            ignoredMetadata,\n            metadataChunkSize,\n            defaultMetadataChunkSize,\n            nestedMetadataToBeBypassed\n        );\n        const metadatas = this.getMetadataItemsForRetrieval(\n            metadataNamesByType,\n            selectedMetadatas,\n            metadatasSupportedByCli,\n            apiVersion,\n            TEMP_DIRECTORY,\n            ignoredMetadata,\n            metadataChunkSize,\n            defaultMetadataChunkSize,\n            nestedMetadataToBeBypassed\n        );\n        if (!profiles.length && !metadatas.length) {\n            this.exitProcess('No metadata available for snapshot');\n        }\n        this.asyncCopadoLogMessage('Setting up working directory');\n        this.setUpWorkingDirectory(TARGET_DIRECTORY);\n        this.switchToWorkingDirectory(TARGET_DIRECTORY);\n        this.asyncCopadoLogMessage('Fetching remote branch');\n        this.fetchRemoteGitBranch(branch);\n        const previousCommitId = this.getCommitId();\n        this.configureGit(gitEmail, gitName);\n        this.configureSFDXCli(apiVersion, sourceEndpoint);\n        const processUsedForRetrieval = this.getMaxAllowedProcesses(maxAllowedProcesses);\n        const { errors } = await this.runMetadataRetrieval(processUsedForRetrieval, metadatas, profiles, TEMP_DIRECTORY);\n        this.runVarReplace(additionalInfoForSnapshot, environmentVariables, TARGET_DIRECTORY);\n        this.runFindAndReplace(additionalInfoForSnapshot, findAndReplaceFileId, branch, TEMP_DIRECTORY, TARGET_DIRECTORY, 'Copado');\n        this.pushChangesToRemoteBranch(branch, commitMessage);\n        const newCommitId = this.getCommitId();\n        if (newCommitId !== previousCommitId) {\n            this.updateResultStatus(errors, newCommitId);\n        } else {\n            this.updateResultStatus(errors, undefined, 'No changes');\n        }\n    } catch (error) {\n        this.executeCommand(this.getErrorCommand(error.toString()), STDIO.INHERIT);\n    }\n}\n\nfunction asyncCopadoLogMessage(msg) {\n    new Promise(resolve => {\n        const childProcess = exec(`copado -p '${msg}'`, { shell: true, stdio: STDIO.INHERIT }, (error, stdout, stderr) => {\n            resolve();\n        });\n    });\n}\n\nfunction getPath(filePath) {\n    return isTest ? `${__dirname}/__tests__/__mockDirectory__${filePath}` : filePath;\n}\n\nfunction getApiVersion(overriddenApiVersion, apiVersion) {\n    const finalApiVersion = overriddenApiVersion || apiVersion;\n    const regExpApiVersion = /\\d\\d\\.0/;\n    if (!regExpApiVersion.test(finalApiVersion)) {\n        this.executeCommand(this.getErrorCommand(`Invalid API Version: ${finalApiVersion}`));\n    }\n    return finalApiVersion;\n}\n\nfunction getSelectedMetadatas(selectedMetadata) {\n    if (!selectedMetadata) {\n        return [];\n    }\n    return selectedMetadata.split(';').map(element => element.toLowerCase());\n}\n\nfunction getParsedData(data) {\n    let result = {};\n    try {\n        result = JSON.parse(data);\n    } catch (error) {\n        logger(`Error occurred while parsing data : ${error}`);\n    }\n    return result;\n}\n\nfunction getMetadataNamesByType(metadataRefreshResult, downloadDirectory, fileName) {\n    const result = new Map();\n    let fileDetails;\n    try {\n        fileDetails = JSON.parse(metadataRefreshResult);\n    } catch (error) {\n        throw `Failure while parsing the metadata refresh result`;\n    }\n    if (!fileDetails.contentVersionId) {\n        throw `Content version id missing from the metadata refresh job step`;\n    }\n    this.executeCommand(`\n        copado --downloadfiles '${fileDetails.contentVersionId}' --downloaddir '${downloadDirectory}' || ${this.getErrorCommand(\n        `Error downloading file ${fileName}`\n    )}\n    `);\n    const metadatas = this.getMetaDataFileContent(downloadDirectory, fileName);\n    metadatas.forEach(metadata => {\n        // In the below condition we want to make sure that we do not retrieve\n        // the vlocity and managed packaged static resources in the snapshot process\n        if (!metadata.vk && !(metadata.t?.toLowerCase() === 'staticresource' && metadata.n?.includes('__'))) {\n            if (result.has(metadata.t)) {\n                result.get(metadata.t)?.push(metadata.n);\n            } else {\n                result.set(metadata.t, [metadata.n]);\n            }\n        }\n    });\n    return result;\n}\n\nfunction getMetaDataFileContent(downloadDirectory, fileName) {\n    const file = `${downloadDirectory}/${fileName}`;\n    if (!existsSync(file)) {\n        throw `Error fetching ${fileName} file`;\n    }\n    return JSON.parse(readFileSync(`${file}`, 'utf-8'));\n}\n\nfunction isValidMetadata(ignoredMetadata, metadata, selectedMetadatas, metadatasSupportedByCli, nestedMetadataToBeBypassed) {\n    const metadataName = metadata?.toLowerCase();\n    return (\n        !ignoredMetadata.includes(metadataName) &&\n        (selectedMetadatas.length\n            ? selectedMetadatas.includes(metadataName)\n            : (metadatasSupportedByCli.includes(metadataName) && !nestedMetadataToBeBypassed.includes(metadataName)))\n    );\n}\n\nfunction getProfilesForRetrieval(\n    metadataNamesByType,\n    selectedMetadatas,\n    metadatasSupportedByCli,\n    profileMetadata,\n    apiVersion,\n    ignoredMetadata,\n    metadataChunkSize,\n    defaultMetadataChunkSize,\n    nestedMetadataToBeBypassed\n) {\n    let result = [];\n    if (\n        metadataNamesByType.has(profileMetadata) &&\n        this.isValidMetadata(ignoredMetadata, profileMetadata, selectedMetadatas, metadatasSupportedByCli, nestedMetadataToBeBypassed)\n    ) {\n        const profileNames = metadataNamesByType.get(profileMetadata);\n        metadataNamesByType.delete(profileMetadata);\n        result = [...result, ...this.getMetadataItemForRetrieval(profileNames, profileMetadata, profileNames.length, apiVersion)];\n    }\n    return result;\n}\n\nfunction getMetadataItemForRetrieval(metadataNames, metadataType, maxAllowedItemsPerType, apiVersion, directory) {\n    const result = [];\n    const metadatas = [];\n    while (metadataNames.length > maxAllowedItemsPerType) {\n        metadatas.push(metadataNames.splice(0, maxAllowedItemsPerType));\n    }\n    metadatas.push(metadataNames);\n    metadatas.forEach(metadata => {\n        result.push({\n            metadataType,\n            metadataNames: metadata,\n            retryCount: 0,\n            path: metadataType.toLowerCase() === 'profile' ? '' : getPackageXMLfilePath(metadata, metadataType, apiVersion, directory)\n        });\n    });\n    return result;\n}\n\nfunction getMetadataItemsForRetrieval(\n    metadataNamesByType,\n    selectedMetadatas,\n    metadatasSupportedByCli,\n    apiVersion,\n    directory,\n    ignoredMetadata,\n    metadataChunkSize,\n    defaultMetadataChunkSize,\n    nestedMetadataToBeBypassed\n) {\n    let result = [];\n    for (const [metadataType, metadataNames] of metadataNamesByType.entries()) {\n        if (this.isValidMetadata(ignoredMetadata, metadataType, selectedMetadatas, metadatasSupportedByCli, nestedMetadataToBeBypassed)) {\n            result = [\n                ...result,\n                ...this.getMetadataItemForRetrieval(\n                    metadataNames,\n                    metadataType,\n                    this.getMetadataChunkSize(metadataType, metadataChunkSize, defaultMetadataChunkSize),\n                    apiVersion,\n                    directory\n                )\n            ];\n        }\n    }\n    return result;\n}\n\nfunction getMetadataChunkSize(metadata, metadataChunkSize, defaultMetadataChunkSize) {\n    const metadataName = metadata?.toLowerCase();\n    return metadataChunkSize[metadataName] ? metadataChunkSize[metadataName] : defaultMetadataChunkSize;\n}\n\nfunction setUpWorkingDirectory(workingDirectory) {\n    this.executeCommand(`\n    \tmkdir -p '${workingDirectory}'\n    `);\n}\n\nfunction switchToWorkingDirectory(workingDirectory) {\n    process.chdir(workingDirectory);\n}\n\nfunction fetchRemoteGitBranch(branch) {\n    this.executeCommand(`\n        copado-git-get --depth '1' '${branch}' || ${this.getErrorCommand(`Error fetching git branch ${branch}`)}\n    `);\n}\n\nfunction configureGit(gitEmail, gitName) {\n    const command = `\n        git config --local user.email \"${gitEmail}\" || ${this.getErrorCommand('Failure in configuring git user email')}\n        git config --local user.name \"${gitName}\" || ${this.getErrorCommand('Failure in configuring git user name')}\n        git config --global diff.renames false || ${this.getErrorCommand('Failure in disabling git rename detection from diff.renames')}\n        git config --global status.renames false || ${this.getErrorCommand('Failure in disabling git rename detection from status.renames')}\n        `;\n    this.executeCommand(`${command}`, STDIO.INHERIT);\n}\n\nfunction configureSFDXCli(sourceApiVersion, sourceEndPoint) {\n    const baseUrl = sourceEndPoint?.substring(0, sourceEndPoint?.indexOf('/', sourceEndPoint?.indexOf('/') + 2));\n    const command = `\n    sfdx config:set instanceUrl=${baseUrl} || ${this.getErrorCommand('Error setting instanceUrl : ' + baseUrl)}\n    sfdx config:set apiVersion=${sourceApiVersion} || ${this.getErrorCommand('Error setting apiVersion : ' + sourceApiVersion)}`;\n    this.executeCommand(command, STDIO.INHERIT);\n}\n\nasync function runMetadataRetrieval(maxAllowedProcesses, metadatas, profiles, directory) {\n    let result, errorMessage, pool;\n    try {\n        pool = new this.SpawnPool(maxAllowedProcesses, metadatas, profiles);\n        await Promise.all(pool.execute());\n    } catch (error) {\n        errorMessage = error?.toString();\n    } finally {\n        result = { errors: pool.getErrors(), sfCommandLogs: pool.getSfCommandLogs() };\n        this.uploadExecutionDetails(result.errors, result.sfCommandLogs, directory);\n        if (errorMessage) {\n            this.executeCommand(this.getErrorCommand(errorMessage), STDIO.INHERIT);\n        }\n    }\n    return result;\n}\n\nfunction getPackageXMLfilePath(metadataNames, metadataType, apiVersion, directory) {\n    const manifest = [];\n    manifest.push('<?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"yes\" ?>\\n');\n    manifest.push('<Package xmlns=\"http://soap.sforce.com/2006/04/metadata\">\\n');\n    manifest.push('\\t<types>\\n');\n    metadataNames.forEach(metadataName => {\n        manifest.push(`\\t\\t<members>${metadataName}</members>\\n`);\n    });\n    manifest.push(`\\t\\t<name>${metadataType}</name>\\n`);\n    manifest.push('\\t</types>\\n');\n    manifest.push(`\\t<version>${apiVersion}</version>\\n`);\n    manifest.push('</Package>\\n');\n    const path = directory + '/' + Math.random() + '.xml';\n    writeFileSync(path, manifest.join(' '));\n    return path;\n}\n\nfunction pushChangesToRemoteBranch(branchName, commitMessage) {\n    this.asyncCopadoLogMessage(`Committing ${commitMessage} in ${branchName}`);\n    logger('Commit process started');\n    const command = `\n    git add . || ${this.getErrorCommand('There was some issue when staging changes')}\n    git commit -m \"${commitMessage}\" || true\n    git push origin \"${branchName}\" --force || ${this.getErrorCommand('Could not push the changes')}\n    `;\n    this.executeCommand(command, STDIO.IGNORE);\n    logger('Commit process ended');\n}\n\nfunction getCommitId() {\n    return this.executeCommand(`git rev-parse HEAD || ${this.getErrorCommand('There was some issue finding the commitid')}`);\n}\n\nfunction runVarReplace(additionalInfoForSnapshot, environmentVariables, targetDirectory) {\n    if (additionalInfoForSnapshot.applyEnvVars && environmentVariables && JSON.parse(environmentVariables)?.length) {\n        this.asyncCopadoLogMessage('Running Var replace');\n        const command = `\n            varreplace '${environmentVariables}' '${targetDirectory}' --valuename=true || ${this.getErrorCommand(\n            'Error replacing environment variables'\n        )}\n\t\t`;\n        this.executeCommand(command, STDIO.INHERIT);\n    }\n}\n\nfunction runFindAndReplace(additionalInfoForSnapshot, findAndReplaceFileId, branch, tempDirectory, targetDirectory, copadoYml) {\n    if (additionalInfoForSnapshot.ymlReplacement && findAndReplaceFileId) {\n        this.asyncCopadoLogMessage('Running YML replace');\n        const PATH_TO_YAML = `${tempDirectory}/${copadoYml}`;\n        const command = `\n        \tcopado --downloadfiles '${findAndReplaceFileId}' --downloaddir \"${tempDirectory}/\" || ${this.getErrorCommand(\n            `Error downloading file ${copadoYml}`\n        )}`;\n        this.executeCommand(command);\n        if (!existsSync(PATH_TO_YAML)) {\n            throw 'Could not find the Copado.yml file';\n        }\n        const findAndReplace = `yamlreplace \"${PATH_TO_YAML}\" \"${targetDirectory}\" -b \"${branch}\" || ${this.getErrorCommand(\n            'Error applying find and replace rules'\n        )}`;\n        this.executeCommand(findAndReplace, STDIO.INHERIT);\n    }\n}\n\nfunction uploadExecutionDetails(errors, sfCommandLogs, tempDirectory) {\n    let command = ``;\n    if (Object.keys(errors).length) {\n        const errorFilePath = `${tempDirectory}/RetrievalError.json`;\n        writeFileSync(errorFilePath, JSON.stringify(errors));\n        command += `copado --uploadfile \"${errorFilePath}\" --name \"Retrieval Error.json\" || true`;\n    }\n\n    if (Object.keys(sfCommandLogs).length) {\n        const sfCommandLogFilePath = `${tempDirectory}/SalesforceRetrieveResult.json`;\n        writeFileSync(sfCommandLogFilePath, JSON.stringify(sfCommandLogs));\n        command += `\n            copado --uploadfile \"${sfCommandLogFilePath}\" --name \"Salesforce Retrieve Result.json\" || true\n        `;\n    }\n\n    this.executeCommand(command, STDIO.INHERIT);\n}\n\nfunction exitProcess(message, commitId, status) {\n    const resultData = { message, commitId, status };\n\n    const command = `copado -p \"${message}\" --result-data '${JSON.stringify(resultData)}'`;\n    this.executeCommand(command);\n    process.exit(0);\n}\n\nfunction updateResultStatus(errors, commitId, status) {\n    let message = '';\n    const hasRetrievalError = errors && Object.keys(errors).length;\n\n    if (hasRetrievalError) {\n        if (commitId) {\n            message =\n                'Snapshot execution successful, but some metadata types could not be retrieved. Please view the Retrieval Error.json for details.';\n        } else {\n            message =\n                'There are no changes to be committed. Some metadata types could not be retrieved. Please view the Retrieval Error.json for details';\n        }\n    } else if (commitId) {\n        message = 'Git snapshot completed successfully';\n    } else {\n        message = 'There are no changes to be committed';\n    }\n\n    this.exitProcess(message, commitId, status);\n}\n\nfunction executeCommand(cmd, ioconfig) {\n    const options = {\n        shell: true,\n        maxBuffer: MAXBUFFER\n    };\n    if (ioconfig) {\n        options.stdio = ioconfig;\n    }\n    const response = spawnSync(cmd, options);\n    const { output, error } = this.log(response);\n    if (response?.status != 0) {\n        if (response?.status == 2) {\n            if (isTest) {\n                throw output;\n            }\n            process.exit(2);\n        }\n        throw error ? error : `Error executing the command: ${cmd}`;\n    }\n    return output;\n}\n\nfunction log(response) {\n    const output = response?.stdout?.toString().trim();\n    const error = response?.stderr?.toString().trim();\n    if (output) {\n        this.logger(output);\n    }\n    if (error) {\n        this.logger(error);\n    }\n    return { output, error };\n}\n\nfunction logger(text) {\n    console.log(text);\n}\n\nfunction getErrorCommand(error) {\n    const suffix = 'Please check the logs for details.';\n    return `{ copado -p 'Error' -e '${error}. ${suffix}'; exit 2; }`;\n}\n\nfunction getMaxAllowedProcesses(neededCpus) {\n    const totalCpus = cpus().length;\n    if (totalCpus === 1) {\n        return 1;\n    }\n    const maxAvailableCpus = totalCpus - 1;\n    if (neededCpus < maxAvailableCpus) {\n        return neededCpus;\n    }\n    logger(`Due to system limitation we will be using ${maxAvailableCpus} child process for metadata retrieval`);\n    return maxAvailableCpus;\n}\n\nclass SpawnPool {\n    maxAllowedProcesses;\n    totalRunningProcesses;\n    metadatas;\n    profiles;\n    errors;\n    sfCommandLogs;\n\n    constructor(maxAllowedProcesses, metadatas, profiles) {\n        this.maxAllowedProcesses = maxAllowedProcesses;\n        this.totalRunningProcesses = 0;\n        this.metadatas = metadatas;\n        this.profiles = profiles;\n        this.errors = {};\n        this.sfCommandLogs = {};\n    }\n\n    execute() {\n        const promises = [];\n        while (this.totalRunningProcesses < this.maxAllowedProcesses && (this.metadatas.length || this.profiles.length)) {\n            this.totalRunningProcesses++;\n            promises.push(\n                new Promise((resolve, reject) => {\n                    if (this.totalRunningProcesses === 1 && this.profiles.length) {\n                        this.executeProcess(this.profiles.shift(), true, resolve, reject);\n                    } else {\n                        this.handleNextExecution(resolve, reject);\n                    }\n                })\n            );\n        }\n        logger(`Total promises : ${promises.length}`);\n        return promises;\n    }\n\n    executeProcess(metadata, isProfileMetadata, resolve, reject) {\n        let command = `\n            copado -p 'Retrieving Metadata : ${metadata.metadataNames.length} ${metadata.metadataType}(s)'\n        `;\n        switch (isProfileMetadata) {\n            case true:\n                command += `\n                    sfdx sfpowerkit:source:profile:retrieve --targetusername \"${sourceSessionId}\" --json\n                `;\n                break;\n            default:\n                command += `\n                    sf project retrieve start --target-org \"${sourceSessionId}\" --manifest \"${metadata.path}\" --wait 60 --json\n                `;\n                break;\n        }\n\n        logger(`Metadata retrieval starting for ${metadata.metadataType} - ${isProfileMetadata ? metadata.metadataNames.toString() : metadata.path}`);\n        const childProcess = spawn(command, [], { shell: true });\n        let stdoutData = '';\n        let stderrData = '';\n        let errorData;\n\n        childProcess.stdout.on('data', data => {\n            stdoutData += data?.toString();\n            childProcess.stdout.resume();\n        });\n\n        childProcess.stderr.on('data', data => {\n            stderrData += data.toString();\n            childProcess.stderr.resume();\n        });\n\n        childProcess.on('error', error => {\n            errorData = error;\n            childProcess.error.resume();\n        });\n\n        childProcess.on('close', code => {\n            const response = { code, stdoutData, stderrData, errorData };\n            if (isProfileMetadata) {\n                this.handleExecutionResultForProfile(response, metadata, resolve, reject);\n            } else {\n                this.handleExecutionResultForMetadata(response, metadata, resolve, reject);\n            }\n            logger(\n                `Metadata retrieval completed for ${metadata.metadataType} - ${isProfileMetadata ? metadata.metadataNames.toString() : metadata.path}`\n            );\n            logger(`Remaining Retrieval for metadata : ${this.metadatas.length}`);\n            if (this.profiles.length) {\n                logger(`Remaining Retrieval for profile : ${this.profiles.length}`);\n            }\n        });\n    }\n\n    handleExecutionResultForMetadata(response, metadata, resolve, reject) {\n        const data = getParsedData(response.stdoutData);\n        const error = this.getErrorsFromExecutionResult(data);\n        this.sfCommandLogs[`${metadata.metadataType} : ${metadata.metadataNames.toString()}`] = data;\n        this.validateUnhandledException(data, reject);\n        if (data?.result?.errorStatusCode === 'LIMIT_EXCEEDED' && metadata.metadataNames?.length > 1) {\n            logger(`LIMIT_EXCEEDED for ${metadata.metadataType}, dividing the metadata in chunks`);\n            this.metadatas = [\n                ...this.metadatas,\n                ...getMetadataItemForRetrieval(\n                    metadata.metadataNames,\n                    metadata.metadataType,\n                    parseInt(metadata.metadataNames.length / 2),\n                    apiVersion,\n                    TEMP_DIRECTORY\n                )\n            ];\n        } else if (data?.result?.success === false || response.code === 1 || response.errorData || error) {\n            if (metadata.retryCount < retryLimit) {\n                logger(`Error occured for ${metadata.metadataType}, retrying retrieval`);\n                this.addToMetadata(metadata);\n            } else {\n                logger(\n                    `Error occured for ${metadata.metadataType}, handling error - ${\n                        data?.result?.errorMessage || data?.message || response.errorData || error\n                    }`\n                );\n                this.handleErrors(metadata, `${data?.result?.errorMessage || data?.message || response.errorData || error}`);\n            }\n        }\n        if (this.metadatas.length) {\n            this.executeProcess(this.metadatas.shift(), false, resolve, reject);\n        } else {\n            this.handleNextExecution(resolve, reject);\n        }\n    }\n\n    handleExecutionResultForProfile(response, metadata, resolve, reject) {\n        const data = getParsedData(response.stdoutData);\n        const error = this.getErrorsFromExecutionResult(data);\n        this.sfCommandLogs[`${metadata.metadataType} : ${metadata.metadataNames.toString()}`] = data;\n        this.validateUnhandledException(data, reject);\n        if ((data.status && data.message) || error) {\n            if (metadata.retryCount < retryLimit) {\n                this.addToProfile(metadata);\n            } else {\n                this.handleErrors(metadata, `${data?.message || error}`);\n            }\n        }\n        if (this.profiles.length) {\n            this.executeProcess(this.profiles.shift(), true, resolve, reject);\n        } else {\n            this.handleNextExecution(resolve, reject);\n        }\n    }\n\n    validateUnhandledException(response, reject) {\n        if (response.status === 1 && response.name === 'UnexpectedForceIgnore') {\n            reject(response.message);\n        }\n    }\n\n    getErrorsFromExecutionResult(response) {\n        const errors = [];\n        response?.result?.files?.forEach(file => {\n            if (file.state === 'Failed' && file.error) {\n                errors.push(file.error);\n            }\n        });\n        return errors.length ? errors.toString() : null;\n    }\n\n    addToMetadata(metadata) {\n        metadata.retryCount += 1;\n        this.metadatas.push(metadata);\n    }\n\n    addToProfile(profile) {\n        profile.retryCount += 1;\n        this.profiles.push(profile);\n    }\n\n    handleErrors(metadata, error) {\n        this.errors[`Error occured while retrieving ${metadata.metadataType} (${metadata.metadataNames.toString()})`] = error;\n    }\n\n    handleNextExecution(resolve, reject) {\n        let currentProcessableMetadata;\n        if (this.metadatas.length) {\n            currentProcessableMetadata = this.metadatas.shift();\n        } else if (this.profiles.length) {\n            currentProcessableMetadata = this.profiles.shift();\n        }\n\n        if (currentProcessableMetadata) {\n            this.executeProcess(currentProcessableMetadata, currentProcessableMetadata.metadataType.toLowerCase() === 'profile', resolve, reject);\n        } else {\n            logger('Thread successfully completed');\n            resolve('Thread successfully completed');\n        }\n    }\n\n    getErrors() {\n        return this.errors;\n    }\n\n    getSfCommandLogs() {\n        return this.sfCommandLogs;\n    }\n}\n\nfunction getMetadataSupportedByCli() {\n    return [\n        'serviceaisetupdefinition',\n        'serviceaisetupfield',\n        'aiapplication',\n        'aiapplicationconfig',\n        'aiusecasedefinition',\n        'mlpredictiondefinition',\n        'mldatadefinition',\n        'installedpackage',\n        'customlabels',\n        'customlabel',\n        'navigationmenu',\n        'staticresource',\n        'scontrol',\n        'experiencebundle',\n        'certificate',\n        'lightningmessagechannel',\n        'auradefinitionbundle',\n        'lightningcomponentbundle',\n        'apexcomponent',\n        'apexpage',\n        'queue',\n        'customdatatype',\n        'casesubjectparticle',\n        'externaldatasource',\n        'externalcredential',\n        'namedcredential',\n        'externalserviceregistration',\n        'role',\n        'territory',\n        'group',\n        'uiplugin',\n        'globalvalueset',\n        'globalpicklist',\n        'standardvalueset',\n        'custompermission',\n        'permissionsetlicensedefinition',\n        'customobject',\n        'customfield',\n        'index',\n        'businessprocess',\n        'recordtype',\n        'compactlayout',\n        'weblink',\n        'validationrule',\n        'sharingreason',\n        'listview',\n        'fieldset',\n        'reporttype',\n        'report',\n        'dashboard',\n        'visualizationplugin',\n        'analyticsnapshot',\n        'customfeedfilter',\n        'layout',\n        'document',\n        'custompageweblink',\n        'letterhead',\n        'emailtemplate',\n        'quickaction',\n        'form',\n        'formsection',\n        'flexipage',\n        'customtab',\n        'customapplicationcomponent',\n        'customapplication',\n        'portal',\n        'embeddedserviceconfig',\n        'embeddedserviceliveagent',\n        'embeddedservicefieldservice',\n        'embeddedservicebranding',\n        'recommendationstrategy',\n        'flow',\n        'flowdefinition',\n        'flowtest',\n        'eventtype',\n        'eventsubscription',\n        'eventdelivery',\n        'workflow',\n        'workflowfieldupdate',\n        'workflowknowledgepublish',\n        'workflowtask',\n        'workflowalert',\n        'workflowsend',\n        'workflowoutboundmessage',\n        'workflowrule',\n        'assignmentrules',\n        'assignmentrule',\n        'autoresponserules',\n        'autoresponserule',\n        'escalationrules',\n        'escalationrule',\n        'posttemplate',\n        'approvalprocess',\n        'homepagecomponent',\n        'homepagelayout',\n        'customobjecttranslation',\n        'customfieldtranslation',\n        'translations',\n        'globalvaluesettranslation',\n        'standardvaluesettranslation',\n        'apexclass',\n        'apextrigger',\n        'apextestsuite',\n        'profile',\n        'permissionset',\n        'permissionsetgroup',\n        'custommetadata',\n        'profilepasswordpolicy',\n        'profilesessionsetting',\n        'datacategorygroup',\n        'remotesitesetting',\n        'csptrustedsite',\n        'matchingrules',\n        'matchingrule',\n        'duplicaterule',\n        'cleandataservice',\n        'servicechannel',\n        'queueroutingconfig',\n        'servicepresencestatus',\n        'presencedeclinereason',\n        'presenceuserconfig',\n        'authprovider',\n        'wavetemplatebundle',\n        'waveapplication',\n        'wavedataset',\n        'eclairgeodata',\n        'wavelens',\n        'wavedashboard',\n        'wavecomponent',\n        'wavexmd',\n        'wavedataflow',\n        'waverecipe',\n        'customsite',\n        'channellayout',\n        'contentasset',\n        'marketingresourcetype',\n        'marketingappextension',\n        'sharingrules',\n        'sharingownerrule',\n        'sharingcriteriarule',\n        'sharingguestrule',\n        'sharingterritoryrule',\n        'sharingset',\n        'community',\n        'chatterextension',\n        'callcenter',\n        'milestonetype',\n        'entitlementprocess',\n        'entitlementtemplate',\n        'customnotificationtype',\n        'connectedapp',\n        'externalclientapplication',\n        'extlclntappoauthconfigurablepolicies',\n        'extlclntappsampleconfigurablepolicies',\n        'extlclntappoauthsettings',\n        'extlclntappsamplesettings',\n        'extlclntappglobaloauthsettings',\n        'appmenu',\n        'delegategroup',\n        'sitedotcom',\n        'network',\n        'networkbranding',\n        'customexperience',\n        'communitythemedefinition',\n        'brandingset',\n        'flowcategory',\n        'lightningbolt',\n        'lightningexperiencetheme',\n        'communitytemplatedefinition',\n        'managedtopics',\n        'managedtopic',\n        'keywordlist',\n        'usercriteria',\n        'moderationrule',\n        'territory2type',\n        'territory2model',\n        'territory2rule',\n        'territory2',\n        'campaigninfluencemodel',\n        'samlssoconfig',\n        'datapipeline',\n        'corswhitelistorigin',\n        'actionlinkgrouptemplate',\n        'licensedefinition',\n        'transactionsecuritypolicy',\n        'accesscontrolpolicy',\n        'skill',\n        'skilltype',\n        'scorecategory',\n        'livechatdeployment',\n        'livechatbutton',\n        'livechatagentconfig',\n        'synonymdictionary',\n        'xorghub',\n        'pathassistant',\n        'leadconvertsettings',\n        'livechatsensitivedatarule',\n        'platformcachepartition',\n        'assistantrecommendationtype',\n        'insighttype',\n        'topicsforobjects',\n        'emailservicesfunction',\n        'integrationhubsettingstype',\n        'integrationhubsettings',\n        'orchestrationcontext',\n        'orchestration',\n        'aiassistanttemplate',\n        'settings',\n        'featureparameterboolean',\n        'featureparameterdate',\n        'featureparameterinteger',\n        'commandaction',\n        'batchcalcjobdefinition',\n        'oauthcustomscope',\n        'platformeventchannel',\n        'customhelpmenusection',\n        'prompt',\n        'mldomain',\n        'bot',\n        'botversion',\n        'bottemplate',\n        'clausecatgconfiguration',\n        'disclosuretype',\n        'disclosuredefinition',\n        'disclosuredefinitionversion',\n        'fueltype',\n        'fueltypesustnuom',\n        'sustainabilityuom',\n        'sustnuomconversion',\n        'botblock',\n        'animationrule',\n        'recordactiondeployment',\n        'embeddedserviceflowconfig',\n        'platformeventchannelmember',\n        'canvasmetadata',\n        'mobileapplicationdetail',\n        'lightningonboardingconfig',\n        'reportfolder',\n        'dashboardfolder',\n        'documentfolder',\n        'emailfolder',\n        'emailtemplatefolder',\n        'inboundnetworkconnection',\n        'outboundnetworkconnection',\n        'inboundcertificate',\n        'mutingpermissionset',\n        'mydomaindiscoverablelogin',\n        'blacklistedconsumer',\n        'userprovisioningconfig',\n        'redirectwhitelisturl',\n        'apexemailnotifications',\n        'iframewhitelisturlsettings',\n        'appointmentschedulingpolicy',\n        'notificationtypeconfig',\n        'managedcontenttype',\n        'paymentgatewayprovider',\n        'embeddedservicemenusettings',\n        'callcoachingmediaprovider',\n        'customindex',\n        'entityimplements',\n        'audience',\n        'cmsconnectsource',\n        'platformeventsubscriberconfig',\n        'userprofilesearchscope',\n        'workskillrouting',\n        'workskillroutingattribute',\n        'timesheettemplate',\n        'accountrelationshipsharerule',\n        'ipaddressrange',\n        'icon',\n        'businessprocessgroup',\n        'businessprocessfeedbackconfiguration',\n        'discoveryaimodel',\n        'discoverygoal',\n        'restrictionrule',\n        'functionreference',\n        'participantrole',\n        'gatewayproviderpaymentmethodtype',\n        'careprovidersearchconfig',\n        'caresystemfieldmapping',\n        'documenttype',\n        'ocrsampledocument',\n        'ocrtemplate',\n        'actionplantemplate',\n        'decisiontable',\n        'decisiontabledatasetlink',\n        'decisionmatrixdefinition',\n        'decisionmatrixdefinitionversion',\n        'expressionsetdefinition',\n        'expressionsetdefinitionversion',\n        'briefcasedefinition',\n        'batchprocessjobdefinition',\n        'webstoretemplate',\n        'dynamictrigger',\n        'objecthierarchyrelationship',\n        'salesagreementsettings',\n        'acctmgrtargetsettings',\n        'accountforecastsettings',\n        'industriesmanufacturingsettings',\n        'fieldservicemobileextension',\n        'datasource',\n        'datasourceobject',\n        'externaldataconnector',\n        'dataconnectors3',\n        'datastreamdefinition',\n        'datapackagekitdefinition',\n        'datasourcebundledefinition',\n        'datapackagekitobject',\n        'datastreamtemplate',\n        'datasrcdatamodelfieldmap',\n        'mktdatatranobject',\n        'mktdatatranfield',\n        'fieldsrctrgtrelationship',\n        'objectsourcetargetmap',\n        'benefitaction',\n        'loyaltyprogramsetup',\n        'channelobjectlinkingrule',\n        'conversationvendorinfo',\n        'conversationvendorfielddef',\n        'schedulingrule',\n        'userauthcertificate',\n        'forecastingtypesource',\n        'forecastingtype',\n        'forecastingsourcedefinition',\n        'assistantversion',\n        'assistantskillsobjectaction',\n        'assistantskillquickaction',\n        'assistantdefinition',\n        'assistantcontextitem',\n        'advacctforecastperiodgroup',\n        'advaccountforecastset',\n        'documentgenerationsetting',\n        'uiobjectrelationconfig',\n        'carerequestconfiguration',\n        'mlrecommendationdefinition',\n        'applicationrecordtypeconfig',\n        'mktcalcinsightobjectdef',\n        'internalorganization',\n        'callcenterroutingmap',\n        'viewdefinition',\n        'slackapp',\n        'fieldrestrictionrule',\n        'svccatalogcategory',\n        'svccatalogfulfillmentflow',\n        'svccatalogitemdef',\n        'omniuicard',\n        'omnidatatransform',\n        'omniscript',\n        'omniintegrationprocedure',\n        'bldgenrgyintensitycnfg',\n        'stnryassetenvsrccnfg',\n        'vehicleassetemssnsrccnfg',\n        'omniinteractionconfig',\n        'uiviewdefinition',\n        'productattributeset',\n        'recordalertcategory',\n        'recordalertdatasource',\n        'activationplatform',\n        'dataconnectoringestapi',\n        'datasourcetenant',\n        'esignatureconfig',\n        'esignatureenvelopeconfig',\n        'internaldataconnector',\n        'mobsecuritycertpinconfig',\n        'mobilesecurityassignment',\n        'mobilesecuritypolicy',\n        'mobilesecuritypolicyset',\n        'applicationsubtypedefinition',\n        'businessprocesstypedefinition',\n        'explainabilityactiondefinition',\n        'explainabilityactionversion',\n        'advacctforecastdimsource',\n        'appointmentassignmentpolicy',\n        'carelimittype',\n        'omniinteractionaccessconfig',\n        'dataweaveresource',\n        'assessmentquestion',\n        'assessmentquestionset',\n        'identityverificationprocdef',\n        'digitalexperiencebundle',\n        'digitalexperience',\n        'digitalexperienceconfig',\n        'forecastingfilter',\n        'forecastingfiltercondition',\n        'schedulingobjective',\n        'relationshipgraphdefinition',\n        'callctragentfavtrfrdest',\n        'marketsegmentdefinition',\n        'mfgprogramtemplate',\n        'streamingappdataconnector',\n        'omnisupervisorconfig',\n        'timelineobjectdefinition',\n        'accountingfieldmapping',\n        'accountingmodelconfig',\n        'actionlauncheritemdef',\n        'actionablelistdefinition',\n        'explainabilitymsgtemplate',\n        'integrationproviderdef',\n        'locationuse',\n        'personaccountownerpoweruser',\n        'pipelineinspmetricconfig',\n        'productspecificationtypedefinition',\n        'experiencepropertytypebundle',\n        'aiscoringmodeldefinition',\n        'aiscoringmodeldefversion',\n        'useraccesspolicy'\n    ];\n}\n\nmodule.exports.asyncCopadoLogMessage = asyncCopadoLogMessage;\nmodule.exports.getPath = getPath;\nmodule.exports.getApiVersion = getApiVersion;\nmodule.exports.getParsedData = getParsedData;\nmodule.exports.execute = execute;\nmodule.exports.getMetadataNamesByType = getMetadataNamesByType;\nmodule.exports.getMetaDataFileContent = getMetaDataFileContent;\nmodule.exports.getMetadataSupportedByCli = getMetadataSupportedByCli;\nmodule.exports.isValidMetadata = isValidMetadata;\nmodule.exports.getProfilesForRetrieval = getProfilesForRetrieval;\nmodule.exports.getMetadataItemForRetrieval = getMetadataItemForRetrieval;\nmodule.exports.getMetadataItemsForRetrieval = getMetadataItemsForRetrieval;\nmodule.exports.setUpWorkingDirectory = setUpWorkingDirectory;\nmodule.exports.switchToWorkingDirectory = switchToWorkingDirectory;\nmodule.exports.fetchRemoteGitBranch = fetchRemoteGitBranch;\nmodule.exports.configureGit = configureGit;\nmodule.exports.configureSFDXCli = configureSFDXCli;\nmodule.exports.runMetadataRetrieval = runMetadataRetrieval;\nmodule.exports.getPackageXMLfilePath = getPackageXMLfilePath;\nmodule.exports.pushChangesToRemoteBranch = pushChangesToRemoteBranch;\nmodule.exports.uploadExecutionDetails = uploadExecutionDetails;\nmodule.exports.runVarReplace = runVarReplace;\nmodule.exports.runFindAndReplace = runFindAndReplace;\nmodule.exports.exitProcess = exitProcess;\nmodule.exports.updateResultStatus = updateResultStatus;\nmodule.exports.logger = logger;\nmodule.exports.log = log;\nmodule.exports.executeCommand = executeCommand;\nmodule.exports.getErrorCommand = getErrorCommand;\nmodule.exports.getMaxAllowedProcesses = getMaxAllowedProcesses;\nmodule.exports.getSelectedMetadatas = getSelectedMetadatas;\nmodule.exports.getMetadataChunkSize = getMetadataChunkSize;\nmodule.exports.getCommitId = getCommitId;\nmodule.exports.SpawnPool = SpawnPool;\n\n!isTest && this.execute();",
                    "copado__Type__c": "Standard",
                    "copado__Worker_Size__c": "M",
                    "Id": "a0k0900000GVU24AAH",
                    "LastReferencedDate": "2023-06-21T18:08:18.000+0000",
                    "LastViewedDate": "2023-06-21T18:08:18.000+0000",
                    "Name": "Git Snapshot"
                },
                {
                    "attributes": {
                        "type": "copado__Function__c",
                        "url": "/services/data/v58.0/sobjects/copado__Function__c/a0k0900000Isk2EAAR"
                    },
                    "copado__API_Name__c": "SFDX_Rollback",
                    "copado__Image_Name__c": "copado-multicloud-dx:v3",
                    "copado__Options__c": "[ ]",
                    "copado__Parameters__c": "[ {\n  \"required\" : true,\n  \"name\" : \"rollbackFileId\",\n  \"defaultValue\" : \"{$Context.JobExecution__r.DataJson.rollbackFileId}\"\n}, {\n  \"required\" : true,\n  \"name\" : \"isValidation\",\n  \"defaultValue\" : \"{$Context.JobExecution__r.DataJson.isValidation}\"\n}, {\n  \"name\" : \"testLevel\",\n  \"defaultValue\" : \"{$Context.JobExecution__r.DataJson.testLevel}\"\n}, {\n  \"required\" : true,\n  \"name\" : \"promotion\",\n  \"defaultValue\" : \"{$Context.JobExecution__r.DataJson.promotion}\"\n}, {\n  \"required\" : true,\n  \"name\" : \"targetBranch\",\n  \"defaultValue\" : \"{$Context.JobExecution__r.DataJson.targetBranch}\"\n}, {\n  \"required\" : true,\n  \"name\" : \"destinationInstanceUrl\",\n  \"defaultValue\" : \"{$Destination.Credential.Endpoint}\"\n}, {\n  \"required\" : true,\n  \"name\" : \"destinationSessionid\",\n  \"defaultValue\" : \"{$Destination.Credential.SessionId}\"\n}, {\n  \"required\" : false,\n  \"name\" : \"gitName\",\n  \"defaultValue\" : \"{$User.Name}\"\n}, {\n  \"required\" : false,\n  \"name\" : \"gitEmail\",\n  \"defaultValue\" : \"{$User.Email}\"\n}, {\n  \"name\" : \"maxBuffer\",\n  \"defaultValue\" : \"5242880\"\n}, {\n  \"name\" : \"waitTime\",\n  \"defaultValue\" : \"220\"\n}, {\n  \"required\" : true,\n  \"name\" : \"git_json\",\n  \"defaultValue\" : \"{$Context.Repository.Credential}\"\n}, {\n  \"required\" : false,\n  \"name\" : \"destinationEnvVariables\",\n  \"defaultValue\" : \"{$Destination.apex.EnvironmentVariables}\"\n}, {\n  \"name\" : \"findAndReplaceFileId\",\n  \"defaultValue\" : \"{$Context.apex.GlobalFindAndReplaceDestinationId}\"\n}, {\n  \"name\" : \"isProductionEnvironment\",\n  \"defaultValue\" : \"{$Context.apex.cmcSf.IdentifyProductionEnvironment}\"\n}, {\n  \"name\" : \"serviceLogLevel\",\n  \"defaultValue\" : \"{$Pipeline.Property.service_log_level}\"\n} ]",
                    "copado__Script__c": "#!/usr/bin/env node\n'use strict';\n\n/**\n * Performs complete or partial rollback of the selected promotion changes\n \n * @param rollbackFileId\n * @param isValidation\n * @param testLevel\n * @param promotion (or rollback branch name)\n * @param targetBranch\n * @param destinationInstanceUrl\n * @param destinationSessionid\n * @param gitName\n * @param gitEmail\n * @param maxBuffer\n * @param waitTime\n * @param destinationEnvVariables\n * @param findAndReplaceFileId\n */\n\n\nconst child_process = require('child_process'),\n    fs = require('fs'),\n    { rollbackFileId, isValidation, testLevel, isProductionEnvironment, promotion, gitEmail, gitName, targetBranch, destinationInstanceUrl, destinationSessionid, waitTime, isTest, findAndReplaceFileId, destinationEnvVariables, overriddenApiVersion, API_VERSION, maxBuffer, serviceLogLevel } = process.env,\n    rollbackBranch = `rollback/${promotion}`,\n    TEMP_DIRECTORY = getPath('/tmp'),\n    APP_DIRECTORY = getPath('/app'),\n    sourceApiVersion = getApiVersion(overriddenApiVersion, API_VERSION),\n    SOURCE_DIRECTORY = `${APP_DIRECTORY}/source`,\n    TARGET_DIRECTORY = `${APP_DIRECTORY}/repository`,\n    ROLLBACK_CHANGES_JSON = 'Copado Rollback changes',\n    SELECTED_ROLLBACK_CHANGES_JSON = 'Selected_RollbackChanges.json',\n    SELECTED_ROLLBACK_CHANGES_FILEPATH = `${TEMP_DIRECTORY}/${SELECTED_ROLLBACK_CHANGES_JSON}`,\n    FILES_TO_INCLUDE = `${TEMP_DIRECTORY}/filesToInclude.json`,\n    ACTIONS = {\n        UPDATE: 'update',\n        UNCHANGED: 'unchanged',\n        CREATE: 'create',\n        DELETE: 'delete',\n        FULL: 'full'\n    },\n    CATEGORY = {\n        SFDX: 'sfdx'\n    },\n    STDIO = {\n        INHERIT: 'inherit'\n    },\n    PACKAGE_XML = 'package.xml',\n    DESTRUCTIVE_CHANGES_XML = 'destructiveChanges.xml',\n    TEST_LEVEL = {\n        RUN_SPECIFIED_TESTS: 'RunSpecifiedTests',\n        NO_TEST_RUN: 'NoTestRun'\n    },\n    CONSTANTS = {\n        COMPONENT_TYPE: 'componentType',\n        FULL_NAME: 'fullName',\n        PROBLEM: 'problem'\n    },\n    DEPLOYMENT_STATUS = {\n        CANCELED: 'Canceled'\n    },\n    ROLLBACK_CATEGORY = {\n        UPSERT: \"UPSERT\",\n        DELETE: \"DELETE\"\n    },\n    MAXBUFFER = parseInt(maxBuffer);\n\n\n// EXECUTION\n\nasync function execute() {\n\n    try {\n        this.setServiceLogLevel(serviceLogLevel);\n        this.fetchBranch(SOURCE_DIRECTORY, rollbackBranch);\n        this.downloadFile(rollbackFileId, TEMP_DIRECTORY, ROLLBACK_CHANGES_JSON);\n        const selectedRollbackChanges = this.getSelectedRollbackChanges(`${TEMP_DIRECTORY}/${ROLLBACK_CHANGES_JSON}`);\n        if (selectedRollbackChanges[ROLLBACK_CATEGORY.UPSERT]?.length) {\n            this.findFilePaths(selectedRollbackChanges, [ROLLBACK_CATEGORY.UPSERT], SELECTED_ROLLBACK_CHANGES_FILEPATH);\n            this.getFilesInScope();\n            this.varReplace(destinationEnvVariables);\n            this.findAndReplace(findAndReplaceFileId, `rollback/${promotion}`);\n            // Perform TRIM operation on the rollback branch\n            this.callMetadataProcessor(SELECTED_ROLLBACK_CHANGES_FILEPATH, 'TRIM', false, SOURCE_DIRECTORY);\n            const parentMetadataFile = this.getParentMetadataFile(SELECTED_ROLLBACK_CHANGES_FILEPATH);\n            if (fs.existsSync(parentMetadataFile)) {\n                this.addParentMetadataToOriginalChangeList(selectedRollbackChanges, this.readFileContent(parentMetadataFile));\n            }\n        }\n\n        await Promise.all([new Promise((resolve, reject) => {\n            this.rollback(selectedRollbackChanges, resolve, reject);\n        })], [new Promise((resolve, reject) => {\n            this.fetchTargetBranch(TARGET_DIRECTORY, targetBranch).then(() => {\n                process.chdir(TARGET_DIRECTORY);\n                this.configureGit(gitEmail, gitName);\n                this.updateSelectedRollBackChangesFile(selectedRollbackChanges, SELECTED_ROLLBACK_CHANGES_FILEPATH, [ROLLBACK_CATEGORY.DELETE]);\n                resolve();\n            }).catch(err => reject(err));\n        })]);\n        if (selectedRollbackChanges[ROLLBACK_CATEGORY.UPSERT]?.length) {\n            process.chdir(SOURCE_DIRECTORY);\n            this.resetChangesInCurrentBranch();\n            process.chdir(TARGET_DIRECTORY);\n        }\n        // Copy files from the rollback branch to the target branch along with nested handling\n        this.callMetadataProcessor(SELECTED_ROLLBACK_CHANGES_FILEPATH, 'ROLLBACK', true, SOURCE_DIRECTORY, TARGET_DIRECTORY);\n        if (isValidation !== 'true') {\n            this.gitCommit(`Copado Rollback for promotion ${promotion}`);\n            this.gitPush(targetBranch);\n        }\n    } catch (err) {\n        this.executeCommand(this.getErrorCmdString(err.toString()));\n        if (!isTest) {\n            process.exit(1);\n        }\n    }\n}\n\n// SCRIPT FUNCTIONS\n\nfunction fetchBranch(directory, branch) {\n\n    fs.mkdirSync(directory, { recursive: true });\n    process.chdir(directory);\n\n    this.asyncCopadoLogMessage(`Fetching ${branch}`);\n    this.executeCommand(`copado-git-get \"${branch}\" --depth 1 || ${this.getErrorCmdString('Error fetching ' + branch)}`\n    );\n}\n\nfunction configureGit(gitEmail, gitName) {\n    const configureGit = `\n        git config --local user.email \"${gitEmail}\" || ${this.getErrorCmdString('Failure in configuring git user email')}\n        git config --local user.name \"${gitName}\" || ${this.getErrorCmdString('Failure in configuring git user name')}\n        git config --global diff.renames false || ${this.getErrorCmdString('Failure in disabling git rename detection from diff.renames')}\n        git config --global merge.renames false || ${this.getErrorCmdString('Failure in disabling git rename detection from merge.renames')}\n        git config --global status.renames false || ${this.getErrorCmdString('Failure in disabling git rename detection from status.renames')}\n    `;\n    this.executeCommand(`${configureGit} `);\n}\n\nfunction enrichChangeList(repository, filePath) {\n    this.executeCommand(`enricher -p ${filePath} --repo ${repository}/ --quick true --loglevel DEBUG || ${this.getErrorCmdString('Error finding file paths for the changes')}`);\n}\n\nfunction getSelectedRollbackChanges(rollbackChangesFilePath) {\n\n    // Initialsing the result object with empty arrays\n    const result = {};\n    Object.values(ROLLBACK_CATEGORY).forEach(category => {\n        result[category] = [];\n    })\n    const selectedChanges = this.readFileContent(rollbackChangesFilePath);\n    selectedChanges.forEach(change => {\n        if (change.s) {\n            // The service understands the action FULL and not the property f..hence setting action to FULL where property f is true\n            if (change.f && change.a.toLowerCase() !== ACTIONS.DELETE) {\n                change.a = ACTIONS.FULL;\n            }\n            if (change.a.toLowerCase() === ACTIONS.DELETE) {\n                result[ROLLBACK_CATEGORY.DELETE].push(change);\n            } else {\n                result[ROLLBACK_CATEGORY.UPSERT].push(change);\n            }\n        }\n    });\n    return result;\n}\n\nfunction executeCommand(cmd) {\n    // const { maxBuffer } = env;\n    const options = {\n        shell: true,\n        maxBuffer: MAXBUFFER\n    };\n    const response = child_process.spawnSync(cmd, options);\n    const { output, error } = this.log(response);\n    if (response?.status != 0) {\n        if (response?.status == 2) {\n            if (isTest) {\n                throw output;\n            }\n            process.exit(2);\n        }\n        throw error ? error : `Error executing the command ${cmd}`;\n    }\n    return output;\n}\n\nfunction getErrorCmdString(error) {\n    const suffix = 'Please check the logs for details.';\n    return `{ copado -p \"Error\" -e \"${error.trim()}; ${suffix}\"; exit 2;\n    }`;\n}\n\nfunction getPath(filePath) {\n    return isTest ? `${__dirname} /__tests__/__mockDir__${filePath} ` : filePath;\n}\n\nfunction getFilePaths(changeFilePath, actions, categories) {\n\n    let changeList = this.readFileContent(changeFilePath);\n    let filePaths = new Set();\n\n    changeList.forEach((change) => {\n        const isValid = (!actions?.length || (actions.length && actions.includes(change.a?.toLowerCase()))) && (!categories?.length || (categories.length && categories.includes(change.c?.toLowerCase())));\n        if (isValid && (change.j && change.j !== '')) {\n            const jsonAdditionalInfo = JSON.parse(change.j);\n            let filesToBeAdded = jsonAdditionalInfo?.filePath?.filter((file) => fs.existsSync(file) && fs.statSync(file).isFile());\n            if (filesToBeAdded) {\n                filePaths = new Set([...filePaths, ...filesToBeAdded]);\n            }\n        }\n    });\n    return [...filePaths];\n}\n\nfunction log(response) {\n    const output = response?.stdout?.toString().trim();\n    const error = response?.stderr?.toString().trim();\n    if (output) {\n        console.log(output);\n    }\n    if (error) {\n        console.log(error);\n    }\n    return { output, error };\n}\n\nfunction downloadFile(fileId, downloadDir, fileName) {\n    return this.executeCommand(`copado --downloadfiles ${fileId} --downloaddir ${downloadDir} || ${this.getErrorCmdString('Error downloading file ' + fileName)} `);\n}\n\nfunction readFileContent(filePath) {\n    if (!fs.existsSync(filePath)) {\n        throw `Could not find file at path: ${filePath} `;\n    }\n    const data = fs.readFileSync(filePath, 'utf-8');\n\n    try {\n        return JSON.parse(data);\n    } catch (err) {\n        throw `Content at ${filePath} is not a valid JSON`;\n    }\n}\n\nfunction getFilesInScope() {\n    const filesInScope = [];\n    if (fs.existsSync(`${TEMP_DIRECTORY}/${SELECTED_ROLLBACK_CHANGES_JSON}`)) {\n        filesInScope.push(...this.getFilePaths(`${TEMP_DIRECTORY}/${SELECTED_ROLLBACK_CHANGES_JSON}`, [ACTIONS.CREATE, ACTIONS.UNCHANGED, ACTIONS.UPDATE, ACTIONS.FULL], [CATEGORY.SFDX]));\n        if (filesInScope?.length) {\n            fs.writeFileSync(FILES_TO_INCLUDE, JSON.stringify(filesInScope));\n        }\n    }\n    return filesInScope;\n}\n\nfunction varReplace(destinationEnvVariables) {\n    if (fs.existsSync(FILES_TO_INCLUDE) && destinationEnvVariables && JSON.parse(destinationEnvVariables)?.length) {\n        this.asyncCopadoLogMessage('Replacing environment variables');\n        const varreplace = `\n            varreplace '${destinationEnvVariables}' '${SOURCE_DIRECTORY}' --include=${FILES_TO_INCLUDE} || ${this.getErrorCmdString(\n            'Error replacing environment variables'\n        )}`;\n        this.executeCommand(varreplace);\n    }\n}\n\nfunction findAndReplace(findAndReplaceFileId, branch) {\n    const COPADO_YML = 'Copado',\n        PATH_TO_YAML = `${TEMP_DIRECTORY}/${COPADO_YML}`;\n    if (findAndReplaceFileId && fs.existsSync(FILES_TO_INCLUDE)) {\n        this.asyncCopadoLogMessage('Applying global find and replace rules');\n        this.downloadFile(findAndReplaceFileId, `${TEMP_DIRECTORY}/`, COPADO_YML);\n        if (fs.existsSync(PATH_TO_YAML)) {\n            const findAndReplace = `yamlreplace \"${PATH_TO_YAML}\" \"${SOURCE_DIRECTORY}\" -b \"${branch}\" --include=${FILES_TO_INCLUDE} || ${this.getErrorCmdString(\n                'Error applying find and replace rules'\n            )}`;\n            this.executeCommand(findAndReplace);\n        } else {\n            throw 'Could not find the Copado.yml file';\n        }\n    }\n}\n\nfunction asyncCopadoLogMessage(msg) {\n    new Promise(resolve => {\n        child_process.exec(`copado -p \"${msg}\"`, { stdio: STDIO.INHERIT }, (err, response, stderr) => {\n            resolve();\n        });\n    });\n}\n\nfunction callMetadataProcessor(changeFile, operationType, copyFiles, sourceDirectory, targetDirectory) {\n    this.asyncCopadoLogMessage('Processing metadata');\n    const processsMetadata = `metadata-processor \"${changeFile}\" ${sourceDirectory ? sourceDirectory : ''} ${targetDirectory ? '--target ' + targetDirectory + ' -denrich' : ''} -o ${operationType} ${copyFiles ? '--copy' : ''} ||  ${this.getErrorCmdString('Error processing metadata')}`;\n    this.executeCommand(processsMetadata);\n    console.log('END Metadata processor');\n}\n\nfunction addParentMetadataToOriginalChangeList(selectedRollbackChanges, parentMetadataList) {\n    if (parentMetadataList?.length) {\n        selectedRollbackChanges[ROLLBACK_CATEGORY.UPSERT].push(...parentMetadataList);\n    }\n}\n\nfunction rollback(selectedRollbackChanges, resolve, reject) {\n    const { addMetadataTypesByName, deleteMetadataTypesByName } = this.getMetadataTypeToNames(selectedRollbackChanges);\n    this.buildManifest(SOURCE_DIRECTORY, addMetadataTypesByName, false);\n    if (deleteMetadataTypesByName.size > 0) {\n        this.buildManifest(SOURCE_DIRECTORY, deleteMetadataTypesByName, true);\n    }\n    this.setInstanceUrl(destinationInstanceUrl);\n    this.asyncCopadoLogMessage('Rolling back changes on the destination environment');\n    child_process.exec(this.getSFDeployCmd(deleteMetadataTypesByName.size > 0, isValidation, testLevel, isProductionEnvironment, waitTime), { cwd: SOURCE_DIRECTORY, maxBuffer: MAXBUFFER }, (err, stdout, stderr) => {\n        if (err) {\n            reject(err);\n        } else {\n            this.handleRollbackResult(JSON.parse(stdout.toString()), isValidation, reject);\n            resolve();\n        }\n    });\n}\n\nfunction getSFDeployCmd(hasDestructiveChanges, isValidation, testLevel, isProductionEnvironment, waitTime) {\n    let sfDeployCommand = `sf project deploy start --json --ignore-conflicts ${waitTime ? '--wait ' + waitTime : ''} --target-org ${destinationSessionid}`;\n\n    if (isValidation == 'true') {\n        sfDeployCommand += ' --dry-run';\n    };\n\n    sfDeployCommand += this.getTestRunParam(testLevel, isProductionEnvironment);\n\n    sfDeployCommand += ` --manifest ${PACKAGE_XML} ${hasDestructiveChanges ? ' --post-destructive-changes ' + DESTRUCTIVE_CHANGES_XML + ' --ignore-warnings' : ''}`;\n    console.log(`Deploy command: ${sfDeployCommand} `);\n    return `${sfDeployCommand} || true`;\n}\n\nfunction getTestRunParam(testLevel, isProductionEnvironment) {\n    const testRun = testLevel?.split(' ')?.join('');\n\n    return (testRun && !(testRun === TEST_LEVEL.NO_TEST_RUN && isProductionEnvironment === 'true')) ? ` -l ${testRun}` : '';\n}\n\nfunction getMetadataTypeToNames(selectedRollbackChanges) {\n    const addMetadataTypesByName = new Map(),\n        deleteMetadataTypesByName = new Map();\n\n    selectedRollbackChanges[ROLLBACK_CATEGORY.DELETE].forEach(change => this.updateMap(deleteMetadataTypesByName, change.t, change.n));\n    selectedRollbackChanges[ROLLBACK_CATEGORY.UPSERT].forEach(change => this.updateMap(addMetadataTypesByName, change.t, change.n));\n    return { addMetadataTypesByName, deleteMetadataTypesByName };\n}\n\nfunction updateMap(typeToNamesMap, key, value) {\n    if (!typeToNamesMap.has(key)) {\n        typeToNamesMap.set(key, []);\n    }\n    typeToNamesMap.get(key).push(value);\n}\n\nfunction buildManifest(directory, metadataByType, isDestructiveManifest) {\n    const manifestFileName = isDestructiveManifest ? `${directory}/${DESTRUCTIVE_CHANGES_XML}` : `${directory}/${PACKAGE_XML}`;\n\n    let manifest = [];\n    manifest.push('<?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"yes\" ?>\\n');\n    manifest.push('<Package xmlns=\"http://soap.sforce.com/2006/04/metadata\">\\n');\n    metadataByType.forEach((value, key) => {\n        manifest.push('\\t<types>\\n');\n        value.forEach((item) => {\n            manifest.push(`\\t\\t<members>${item}</members>\\n`);\n        });\n\n        manifest.push(`\\t\\t<name>${key}</name>\\n`);\n        manifest.push('\\t</types>\\n');\n    });\n\n    manifest.push(`\\t<version>${sourceApiVersion}</version>\\n`);\n    manifest.push('</Package>\\n');\n\n    fs.writeFileSync(manifestFileName, manifest.join(''));\n}\n\n\nfunction handleRollbackResult(rollbackResult, isValidation, reject) {\n\n    this.uploadRollbackResult(rollbackResult);\n\n    let errorResponse = '';\n    const details = rollbackResult?.result?.details,\n        componentFailures = details?.componentFailures,\n        componentSuccesses = details?.componentSuccesses,\n        failures = details?.runTestResult?.failures,\n        codeCoverageWarnings = details?.runTestResult?.codeCoverageWarnings;\n\n    // If any errors or warning, display to progress indicator and fail the job execution\n    if (rollbackResult?.status == 1) {\n        if (rollbackResult?.message) {\n            errorResponse = rollbackResult?.message;\n        } else if (rollbackResult?.result?.errorMessage) {\n            errorResponse = rollbackResult?.result?.errorMessage;\n        } else if (rollbackResult?.result.status == DEPLOYMENT_STATUS.CANCELED) {\n            errorResponse = `The ${isValidation === 'true' ? 'validation' : 'deployment'} was cancelled on the target org.`;\n        }\n    }\n    if (failures) {\n        errorResponse = this.populateErrorResponse(this.getFailedTestsErrorMessage(failures), errorResponse);\n    }\n    if (codeCoverageWarnings) {\n        errorResponse = this.populateErrorResponse(this.getFailedTestsErrorMessage(codeCoverageWarnings), errorResponse);\n    }\n    if (componentFailures) {\n        const errorMetadata = this.filterFailedMedataByProblemType(componentFailures, 'Error');\n        if (errorMetadata.length) {\n            errorResponse = this.populateErrorResponse(this.getFailedComponentsErrorMessage(errorMetadata), errorResponse);\n        }\n    }\n    if (componentSuccesses?.length) {\n        const warningMetadata = this.filterFailedMedataByProblemType(componentSuccesses, 'Warning');\n        if (warningMetadata?.length) {\n            const message = `WARNING deploying Metadata: ${this.getFailedComponentsErrorMessage(warningMetadata)}`;\n            this.executeCommand(`copado -p \"${message.substring(0, 254)}\"`);\n            console.log(message);\n        }\n    }\n    if (errorResponse) {\n        reject(errorResponse.substring(0, 131072));\n    }\n}\n\nfunction filterFailedMedataByProblemType(failedComponents, problemType) {\n    let result = [];\n    if (Array.isArray(failedComponents)) {\n        result = failedComponents.filter((component) => component.problemType == problemType);\n    } else if (failedComponents.problemType == problemType) {\n        result = [failedComponents];\n    }\n    return result;\n}\n\nfunction getFailedComponentsErrorMessage(failedComponents) {\n    let result = '';\n    if (Array.isArray(failedComponents)) {\n        result = failedComponents\n            .map((failure) => failure[CONSTANTS.COMPONENT_TYPE].concat(':', failure[CONSTANTS.FULL_NAME], ':', failure[CONSTANTS.PROBLEM]))\n            .join('\\n');\n    } else {\n        result = failedComponents[CONSTANTS.COMPONENT_TYPE]\n            .concat(':', failedComponents[CONSTANTS.FULL_NAME], ':', failedComponents[CONSTANTS.PROBLEM])\n            .toString();\n    }\n    return result;\n}\n\nfunction getFailedTestsErrorMessage(failedTests) {\n    let result = '';\n    if (Array.isArray(failedTests)) {\n        let failedTestsError = failedTests.map((failedTest) => {\n            let error = '';\n            error = failedTest.name ? (error ? error.concat('-', failedTest.name) : error.concat(failedTest.name)) : error;\n            error = failedTest.methodName ? (error ? error.concat('-', failedTest.methodName) : error.concat(failedTest.methodName)) : error;\n            error = error ? error.concat('-', failedTest.message) : error.concat(failedTest.message);\n            return error;\n        });\n        if (failedTestsError?.length) {\n            result = failedTestsError.join('\\n');\n        }\n    } else {\n        if (typeof failedTests.name != 'object') {\n            result = result.concat(`${failedTests.name}`);\n        }\n        result = failedTests.methodName ? (result ? result.concat('-', failedTests.methodName) : result.concat(failedTests.methodName)) : result;\n        result = result ? result.concat('-', failedTests.message) : result.concat(failedTests.message);\n    }\n    return result;\n}\n\nfunction populateErrorResponse(errorMessage, errorResponse) {\n    const delimeter = '\\n';\n    errorResponse = (errorResponse && errorResponse?.trim().concat(`${delimeter}`, errorMessage.trim())) || errorResponse.concat(errorMessage.trim());\n    return errorResponse;\n}\n\nfunction setInstanceUrl(instanceUrl) {\n    const baseUrl = instanceUrl?.substring(0, instanceUrl?.indexOf('/', instanceUrl?.indexOf('/') + 2));\n    this.executeCommand(`sfdx config:set instanceUrl=${baseUrl} || ${this.getErrorCmdString('Error setting instanceUrl : ' + baseUrl)}`);\n}\n\nfunction getApiVersion(overriddenApiVersion, apiVersion) {\n    const finalApiVersion = overriddenApiVersion || apiVersion;\n    const regExpApiVersion = /\\d\\d\\.0/;\n    if (!regExpApiVersion.test(finalApiVersion)) {\n        this.executeCommand(this.getErrorCmdString(`Invalid API Version: ${finalApiVersion}`));\n    }\n    return finalApiVersion;\n}\n\nfunction gitCommit(commitMessage) {\n    if (!this.hasChange()) {\n        this.executeCommand(`copado -p \"There are no changes to be committed\"`);\n        process.exit(0);\n    }\n    this.asyncCopadoLogMessage(`Committing Changes`);\n    this.executeCommand(`\n    git add . || ${this.getErrorCmdString('Failure in configuring feature.manyFiles true')}\n    git commit -m \"${commitMessage}\" || ${this.getErrorCmdString(\"There was some issue when committing changes\")}\n    `);\n}\n\nfunction gitPush(branchName) {\n    this.asyncCopadoLogMessage(`Pushing all changes to ${branchName}`);\n    this.executeCommand(`git push origin \"${branchName}\"`);\n}\n\nfunction hasChange() {\n    const gitStatus = this.executeCommand(`git status --porcelain`);\n    return gitStatus ? true : false;\n}\n\nfunction resetChangesInCurrentBranch() {\n    this.executeCommand(`git reset --hard || true`);\n}\n\nfunction findFilePaths(selectedChanges, rollbackCategories, outputFilePath) {\n    const changes = this.getChanges(selectedChanges, rollbackCategories);\n    if (changes?.length) {\n        fs.writeFileSync(outputFilePath, JSON.stringify(changes));\n\n        // Enrich change json for selected actions\n        this.enrichChangeList(SOURCE_DIRECTORY, outputFilePath);\n    }\n\n}\n\nfunction getChanges(changes, rollbackCategories) {\n    const result = [];\n    rollbackCategories.forEach(category => {\n        result.push(...(changes[category]));\n    });\n    return result;\n}\n\nfunction updateSelectedRollBackChangesFile(selectedChanges, filePath, rollbackCategories) {\n    let content = [];\n    if (fs.existsSync(filePath)) {\n        content = [...this.readFileContent(filePath)];\n    }\n    content = [...content, ...this.getChanges(selectedChanges, rollbackCategories)];\n    fs.writeFileSync(filePath, JSON.stringify(content));\n}\n\nfunction fetchTargetBranch(targetDirectory, branch) {\n    return new Promise((resolve, reject) => {\n        const fetchBranch = `\n        mkdir -p ${targetDirectory}\n        cd ${TARGET_DIRECTORY}\n        copado-git-get \"${branch}\" --depth 1\n        `\n\n        child_process.exec(fetchBranch, { maxBuffer: MAXBUFFER }, (err, stdout, stderr) => {\n            if (err) {\n                reject(err);\n            } else {\n                resolve();\n            }\n        })\n    });\n}\n\nfunction uploadRollbackResult(rollbackResult) {\n    const resultFilePath = '/tmp/RollbackResult.json';\n    fs.writeFileSync(resultFilePath, JSON.stringify(rollbackResult, null, 2));\n\n    new Promise((resolve, reject) => {\n        child_process.exec(`copado --uploadfile ${resultFilePath}`, {}, (err, stdout, stderr) => {\n            if (err) {\n                reject(err);\n            } else {\n                resolve();\n            }\n        });\n    });\n}\n\nfunction getParentMetadataFile(filePath) {\n    const index = filePath.lastIndexOf('/');\n    const directory = filePath.substring(0, index + 1);\n\n    return directory + 'internal_' + filePath.substring(index + 1);\n}\n\nfunction setServiceLogLevel(logLevel) {\n    if (logLevel) {\n        process.env.SERVICE_LOG_LEVEL = logLevel;\n    }\n}\n\nmodule.exports.fetchBranch = fetchBranch;\nmodule.exports.execute = execute;\nmodule.exports.executeCommand = executeCommand;\nmodule.exports.getErrorCmdString = getErrorCmdString;\nmodule.exports.log = log;\nmodule.exports.configureGit = configureGit;\nmodule.exports.enrichChangeList = enrichChangeList;\nmodule.exports.findFilePaths = findFilePaths;\nmodule.exports.readFileContent = readFileContent\nmodule.exports.downloadFile = downloadFile;\nmodule.exports.getFilePaths = getFilePaths;\nmodule.exports.getFilesInScope = getFilesInScope;\nmodule.exports.varReplace = varReplace;\nmodule.exports.findAndReplace = findAndReplace;\nmodule.exports.asyncCopadoLogMessage = asyncCopadoLogMessage;\nmodule.exports.callMetadataProcessor = callMetadataProcessor;\nmodule.exports.rollback = rollback;\nmodule.exports.getMetadataTypeToNames = getMetadataTypeToNames;\nmodule.exports.updateMap = updateMap;\nmodule.exports.buildManifest = buildManifest;\nmodule.exports.getTestRunParam = getTestRunParam;\nmodule.exports.getSFDeployCmd = getSFDeployCmd;\nmodule.exports.handleRollbackResult = handleRollbackResult;\nmodule.exports.filterFailedMedataByProblemType = filterFailedMedataByProblemType;\nmodule.exports.getFailedTestsErrorMessage = getFailedTestsErrorMessage;\nmodule.exports.getFailedComponentsErrorMessage = getFailedComponentsErrorMessage;\nmodule.exports.populateErrorResponse = populateErrorResponse;\nmodule.exports.setInstanceUrl = setInstanceUrl;\nmodule.exports.gitCommit = gitCommit;\nmodule.exports.gitPush = gitPush;\nmodule.exports.hasChange = hasChange;\nmodule.exports.resetChangesInCurrentBranch = resetChangesInCurrentBranch;\nmodule.exports.getSelectedRollbackChanges = getSelectedRollbackChanges;\nmodule.exports.updateSelectedRollBackChangesFile = updateSelectedRollBackChangesFile;\nmodule.exports.getChanges = getChanges;\nmodule.exports.fetchTargetBranch = fetchTargetBranch;\nmodule.exports.uploadRollbackResult = uploadRollbackResult;\nmodule.exports.addParentMetadataToOriginalChangeList = addParentMetadataToOriginalChangeList;\nmodule.exports.getParentMetadataFile = getParentMetadataFile;\nmodule.exports.setServiceLogLevel = setServiceLogLevel;\n\n\n!isTest && this.execute();",
                    "copado__Type__c": "Standard",
                    "copado__Worker_Size__c": "M",
                    "Id": "a0k0900000Isk2EAAR",
                    "LastReferencedDate": "2023-07-18T13:23:50.000+0000",
                    "LastViewedDate": "2023-07-18T13:23:50.000+0000",
                    "Name": "SFDX Rollback"
                }
            ],
            "ObjectType": "copado__Function__c"
        },
        {
            "Records": [
                {
                    "attributes": {
                        "type": "copado__JobTemplate__c",
                        "url": "/services/data/v55.0/sobjects/copado__JobTemplate__c/a0u7Q000000Xw28QAC"
                    },
                    "copado__ApiName__c": "sfdx_commit_1",
                    "copado__Description__c": "<p>Standard job template to perform git commit in User Stories</p>",
                    "copado__Type__c": "Standard",
                    "copado__Version__c": 2,
                    "Id": "a0u7Q000000Xw28QAC",
                    "LastReferencedDate": "2022-09-15T06:40:09.000+0000",
                    "LastViewedDate": "2022-09-15T06:40:09.000+0000",
                    "Name": "SFDX Commit"
                },
                {
                    "attributes": {
                        "type": "copado__JobTemplate__c",
                        "url": "/services/data/v55.0/sobjects/copado__JobTemplate__c/a0u7Q000000Xw29QAC"
                    },
                    "copado__ApiName__c": "sfdx_deploy_1",
                    "copado__Description__c": "<p>DX Source Deployment</p>",
                    "copado__Type__c": "Standard",
                    "copado__Version__c": 1,
                    "copado__VolumeOptions__c": "[\n    {\n        \"name\": \"volumeSize\",\n        \"value\": \"10\"\n    },\n    {\n        \"name\": \"volumeTTL\",\n        \"value\": \"100\"\n    },\n    {\n        \"name\": \"preserveVolumeAfterExecution\",\n        \"value\": \"true\"\n    },\n    {\n        \"name\": \"volumeEnabled\",\n        \"value\": \"true\"\n    }\n]",
                    "Id": "a0u7Q000000Xw29QAC",
                    "LastReferencedDate": "2022-09-15T06:40:13.000+0000",
                    "LastViewedDate": "2022-09-15T06:40:13.000+0000",
                    "Name": "SFDX Deploy"
                },
                {
                    "attributes": {
                        "type": "copado__JobTemplate__c",
                        "url": "/services/data/v55.0/sobjects/copado__JobTemplate__c/a0u7Q000000Xw2AQAS"
                    },
                    "copado__ApiName__c": "sfdx_promote_1",
                    "copado__Description__c": "<p>DX Source Promote</p>",
                    "copado__Type__c": "Standard",
                    "copado__Version__c": 1,
                    "Id": "a0u7Q000000Xw2AQAS",
                    "LastReferencedDate": "2022-09-15T06:40:13.000+0000",
                    "LastViewedDate": "2022-09-15T06:40:13.000+0000",
                    "Name": "SFDX Promote"
                },
                {
                    "attributes": {
                        "type": "copado__JobTemplate__c",
                        "url": "/services/data/v57.0/sobjects/copado__JobTemplate__c/a0u7Q0000004wGoQAI"
                    },
                    "copado__ApiName__c": "SFDX Package Distribution_1",
                    "copado__Type__c": "Standard",
                    "copado__Version__c": 1,
                    "Id": "a0u7Q0000004wGoQAI",
                    "LastReferencedDate": "2023-04-12T05:16:21.000+0000",
                    "LastViewedDate": "2023-04-12T05:16:21.000+0000",
                    "Name": "SFDX Package Distribution"
                },
                {
                    "attributes": {
                        "type": "copado__JobTemplate__c",
                        "url": "/services/data/v52.0/sobjects/copado__JobTemplate__c/a0t09000002vfccAAA"
                    },
                    "copado__ApiName__c": "SFDX Package Import_1",
                    "copado__Type__c": "Standard",
                    "copado__Version__c": 1,
                    "CreatedDate": "2021-09-17T14:07:46.000+0000",
                    "Id": "a0t09000002vfccAAA",
                    "IsDeleted": false,
                    "LastModifiedDate": "2021-10-04T09:11:43.000+0000",
                    "LastReferencedDate": "2021-10-04T09:11:43.000+0000",
                    "LastViewedDate": "2021-10-04T09:11:43.000+0000",
                    "Name": "SFDX Package Import",
                    "SystemModstamp": "2021-10-04T09:11:43.000+0000"
                },
                {
                    "attributes": {
                        "type": "copado__JobTemplate__c",
                        "url": "/services/data/v56.0/sobjects/copado__JobTemplate__c/a0u7Q0000004wGqQAI"
                    },
                    "copado__ApiName__c": "SFDX Package Version Publish_1",
                    "copado__Type__c": "Standard",
                    "copado__Version__c": 1,
                    "Id": "a0u7Q0000004wGqQAI",
                    "LastReferencedDate": "2023-01-19T12:11:24.000+0000",
                    "LastViewedDate": "2023-01-19T12:11:24.000+0000",
                    "Name": "SFDX Package Version Publish"
                },
                {
                    "attributes": {
                        "type": "copado__JobTemplate__c",
                        "url": "/services/data/v56.0/sobjects/copado__JobTemplate__c/a0u7Q0000004wGrQAI"
                    },
                    "copado__ApiName__c": "SFDX Package Version Update_1",
                    "copado__Type__c": "Standard",
                    "copado__Version__c": 1,
                    "Id": "a0u7Q0000004wGrQAI",
                    "LastReferencedDate": "2022-09-27T13:29:50.000+0000",
                    "LastViewedDate": "2022-09-27T13:29:50.000+0000",
                    "Name": "SFDX Package Version Update"
                },
                {
                    "attributes": {
                        "type": "copado__JobTemplate__c",
                        "url": "/services/data/v56.0/sobjects/copado__JobTemplate__c/a0u7Q0000004wGsQAI"
                    },
                    "copado__ApiName__c": "SFDX Package Version Create_1",
                    "copado__Description__c": "<p>Creates Package Version</p>",
                    "copado__Type__c": "Standard",
                    "copado__Version__c": 1,
                    "Id": "a0u7Q0000004wGsQAI",
                    "LastReferencedDate": "2022-09-16T12:40:16.000+0000",
                    "LastViewedDate": "2022-09-16T12:40:16.000+0000",
                    "Name": "SFDX Package Version Create"
                },
                {
                    "attributes": {
                        "type": "copado__JobTemplate__c",
                        "url": "/services/data/v56.0/sobjects/copado__JobTemplate__c/a0u7Q0000004wGtQAI"
                    },
                    "copado__ApiName__c": "SFDX Package Create_1",
                    "copado__Description__c": "<p>Creates Package</p>",
                    "copado__Type__c": "Standard",
                    "copado__Version__c": 1,
                    "Id": "a0u7Q0000004wGtQAI",
                    "LastReferencedDate": "2023-01-03T11:11:02.000+0000",
                    "LastViewedDate": "2023-01-03T11:11:02.000+0000",
                    "Name": "SFDX Package Create"
                },
                {
                    "attributes": {
                        "type": "copado__JobTemplate__c",
                        "url": "/services/data/v54.0/sobjects/copado__JobTemplate__c/a0u7Q000000XrrkQAC"
                    },
                    "copado__ApiName__c": "SFDX Run Apex Tests_1",
                    "copado__Type__c": "Standard",
                    "copado__Version__c": 1,
                    "Id": "a0u7Q000000XrrkQAC",
                    "LastReferencedDate": "2022-04-21T10:30:02.000+0000",
                    "LastViewedDate": "2022-04-21T10:30:02.000+0000",
                    "Name": "SFDX Run Apex Tests"
                },
                {
                    "attributes": {
                        "type": "copado__JobTemplate__c",
                        "url": "/services/data/v56.0/sobjects/copado__JobTemplate__c/a0u7Q0000004yiqQAA"
                    },
                    "copado__ApiName__c": "SFDX Package Version Git Configure_1",
                    "copado__Description__c": "<p><span style=\"font-size: 14px;\">SFDX Package Version Git Configure</span></p>",
                    "copado__Type__c": "Standard",
                    "copado__Version__c": 1,
                    "Id": "a0u7Q0000004yiqQAA",
                    "LastReferencedDate": "2023-01-22T12:12:15.000+0000",
                    "LastViewedDate": "2023-01-22T12:12:15.000+0000",
                    "Name": "SFDX Package Version Git Configure"
                },
                {
                    "attributes": {
                        "type": "copado__JobTemplate__c",
                        "url": "/services/data/v55.0/sobjects/copado__JobTemplate__c/a0t09000000lkYtAAI"
                    },
                    "copado__ApiName__c": "SFDX Test Records Creation In User Story_1",
                    "copado__Type__c": "Standard",
                    "copado__Version__c": 1,
                    "Id": "a0t09000000lkYtAAI",
                    "LastReferencedDate": "2022-07-11T06:25:51.000+0000",
                    "LastViewedDate": "2022-07-11T06:25:51.000+0000",
                    "Name": "SFDX Test Records Creation In User Story"
                },
                {
                    "attributes": {
                        "type": "copado__JobTemplate__c",
                        "url": "/services/data/v56.0/sobjects/copado__JobTemplate__c/a0t09000000llqoAAA"
                    },
                    "copado__ApiName__c": "SFDX Refresh Metadata_1",
                    "copado__Description__c": "<p><span style=\"font-size: 14px;\">Standard job template to refresh metadata cache of the org</span></p>",
                    "copado__Type__c": "Standard",
                    "copado__Version__c": 1,
                    "Id": "a0t09000000llqoAAA",
                    "LastReferencedDate": "2022-12-08T07:33:18.000+0000",
                    "LastViewedDate": "2022-12-08T07:33:18.000+0000",
                    "Name": "SFDX Refresh Metadata"
                },
                {
                    "attributes": {
                        "type": "copado__JobTemplate__c",
                        "url": "/services/data/v57.0/sobjects/copado__JobTemplate__c/a0u7Q000000ZJ20QAG"
                    },
                    "copado__ApiName__c": "SFDX Git Initialization_1",
                    "copado__Type__c": "Standard",
                    "copado__Version__c": 1,
                    "Id": "a0u7Q000000ZJ20QAG",
                    "LastReferencedDate": "2023-05-12T03:54:51.000+0000",
                    "LastViewedDate": "2023-05-12T03:54:51.000+0000",
                    "Name": "SFDX Git Initialization"
                },
                {
                    "attributes": {
                        "type": "copado__JobTemplate__c",
                        "url": "/services/data/v57.0/sobjects/copado__JobTemplate__c/a0u7Q000004z6sOQAQ"
                    },
                    "copado__ApiName__c": "SFDX Vlocity Commit_1",
                    "copado__Type__c": "Standard",
                    "copado__Version__c": 1,
                    "copado__VolumeOptions__c": "[\r\n  {\r\n    \"name\": \"volumeSize\",\r\n    \"value\": \"10\"\r\n  },\r\n  {\r\n    \"name\": \"volumeTTL\",\r\n    \"value\": \"100\"\r\n  },\r\n  {\r\n    \"name\": \"preserveVolumeAfterExecution\",\r\n    \"value\": \"true\"\r\n  },\r\n  {\r\n    \"name\": \"volumeEnabled\",\r\n    \"value\": \"true\"\r\n  }\r\n]",
                    "Id": "a0u7Q000004z6sOQAQ",
                    "LastReferencedDate": "2023-05-25T06:31:55.000+0000",
                    "LastViewedDate": "2023-05-25T06:31:55.000+0000",
                    "Name": "SFDX Vlocity Commit"
                },
                {
                    "attributes": {
                        "type": "copado__JobTemplate__c",
                        "url": "/services/data/v57.0/sobjects/copado__JobTemplate__c/a0u7Q000000qiAMQAY"
                    },
                    "copado__ApiName__c": "SFDX Vlocity Deploy_1",
                    "copado__Type__c": "Standard",
                    "copado__Version__c": 1,
                    "copado__VolumeOptions__c": "[\r\n{\r\n\"name\": \"volumeSize\",\r\n\"value\": \"10\"\r\n},\r\n{\r\n\"name\": \"volumeTTL\",\r\n\"value\": \"100\"\r\n},\r\n{\r\n\"name\": \"preserveVolumeAfterExecution\",\r\n\"value\": \"true\"\r\n},\r\n{\r\n\"name\": \"volumeEnabled\",\r\n\"value\": \"true\"\r\n}\r\n]",
                    "Id": "a0u7Q000000qiAMQAY",
                    "LastReferencedDate": "2023-05-31T07:54:39.000+0000",
                    "LastViewedDate": "2023-05-31T07:54:39.000+0000",
                    "Name": "SFDX Vlocity Deploy"
                },
                {
                    "attributes": {
                      "type": "copado__JobTemplate__c",
                      "url": "/services/data/v58.0/sobjects/copado__JobTemplate__c/a0t090000086CbPAAU"
                    },
                    "copado__ApiName__c": "SFDX_Git_Snapshot_1",
                    "copado__Type__c": "Standard",
                    "copado__Version__c": 1,
                    "Id": "a0t090000086CbPAAU",
                    "LastReferencedDate": "2023-06-21T18:08:28.000+0000",
                    "LastViewedDate": "2023-06-21T18:08:28.000+0000",
                    "Name": "SFDX Git Snapshot"
                },
                {
                    "attributes": {
                        "type": "copado__JobTemplate__c",
                        "url": "/services/data/v58.0/sobjects/copado__JobTemplate__c/a0t090000086EMQAA2"
                    },
                    "copado__ApiName__c": "SFDX_Rollback_1",
                    "copado__Description__c": "<p>Performs complete or partial rollback of the selected promotion changes</p>",
                    "copado__Type__c": "Standard",
                    "copado__Version__c": 1,
                    "Id": "a0t090000086EMQAA2",
                    "LastReferencedDate": "2023-07-18T11:58:17.000+0000",
                    "LastViewedDate": "2023-07-18T11:58:17.000+0000",
                    "Name": "SFDX Rollback"
                }
            ],
            "ObjectType": "copado__JobTemplate__c"
        },
        {
            "Records": [
                {
                    "attributes": {
                        "type": "copado__JobStep__c",
                        "url": "/services/data/v57.0/sobjects/copado__JobStep__c/a0t7Q000008cMZkQAM"
                    },
                    "copado__ApiName__c": "SFDX Package Distribution_Install package",
                    "copado__ConfigJson__c": "{\"functionName\":\"sfdx_install_package\",\"parameters\":[{\"name\":\"packages\",\"value\":\"{$Context.apex.cmcSf.GetInstallationKeys}\",\"required\":true},{\"name\":\"destinationBaseUrl\",\"value\":\"{$Destination.Credential.Endpoint}\",\"required\":true},{\"name\":\"destinationSession\",\"value\":\"{$Destination.Credential.SessionId}\",\"required\":true},{\"name\":\"retrialTimes\",\"value\":\"{$Property.sfdx_package_install_retrial_time}\",\"required\":false},{\"name\":\"apiVersion\",\"value\":\"{$Context.JobExecution__r.DataJson.apiVersion}\"},{\"name\":\"devhubSession\",\"value\":\"{$Source.Credential.SessionId}\"},{\"name\":\"devhubBaseUrl\",\"value\":\"{$Source.Credential.Endpoint}\"},{\"name\":\"installationSecurityType\",\"value\":\"{$Context.JobExecution__r.DataJson.installSecurityType}\"},{\"name\":\"pollInterval\",\"value\":\"{$Property.sfdx_package_install_poll_time_in_seconds}\"}]}",
                    "copado__CustomType__c": "Function",
                    "copado__JobTemplate__c": "a0u7Q0000004wGoQAI",
                    "copado__Order__c": 2,
                    "copado__Type__c": "Function",
                    "Id": "a0t7Q000008cMZkQAM",
                    "LastReferencedDate": "2023-04-12T05:16:34.000+0000",
                    "LastViewedDate": "2023-04-12T05:16:33.000+0000",
                    "Name": "Install package"
                },
                {
                    "attributes": {
                        "type": "copado__JobStep__c",
                        "url": "/services/data/v57.0/sobjects/copado__JobStep__c/a0t7Q000008cMZlQAM"
                    },
                    "copado__ApiName__c": "SFDX Package Distribution_Get Dependencies",
                    "copado__ConfigJson__c": "{\"functionName\":\"SFDX_Get_Package_Version_Dependencies\",\"parameters\":[{\"name\":\"endpoint\",\"value\":\"{$Source.Credential.Endpoint}\",\"required\":true},{\"name\":\"session\",\"value\":\"{$Source.Credential.SessionId}\",\"required\":true},{\"name\":\"subscriberVersionId\",\"value\":\"{$Context.JobExecution__r.DataJson.subscriberId}\",\"required\":true},{\"name\":\"installationKey\",\"value\":\"{$Context.JobExecution__r.DataJson.installationKey}\",\"required\":false}]}",
                    "copado__CustomType__c": "Function",
                    "copado__JobTemplate__c": "a0u7Q0000004wGoQAI",
                    "copado__Order__c": 1,
                    "copado__Type__c": "Function",
                    "Id": "a0t7Q000008cMZlQAM",
                    "Name": "Get Dependencies"
                },
                {
                    "attributes": {
                        "type": "copado__JobStep__c",
                        "url": "/services/data/v57.0/sobjects/copado__JobStep__c/a0t7Q000000NQaAQAW"
                    },
                    "copado__ApiName__c": "SFDX Commit_Commit",
                    "copado__ConfigJson__c": "{\"functionName\":\"sfdx_commit\",\"parameters\":[{\"name\":\"fileChangesId\",\"value\":\"{$Context.JobExecution__r.DataJson.fileWithSelectedChanges}\",\"required\":true},{\"name\":\"fileName\",\"value\":\"Copado Commit changes\",\"required\":true},{\"name\":\"sourceSessionId\",\"value\":\"{$Source.Credential.SessionId}\",\"required\":true},{\"name\":\"sourceEndPoint\",\"value\":\"{$Source.Credential.Endpoint}\",\"required\":true},{\"name\":\"namespace\",\"value\":\"\"},{\"name\":\"git_json\",\"value\":\"{$Context.Repository.Credential}\",\"required\":true},{\"name\":\"baseBranch\",\"value\":\"{$Context.JobExecution__r.DataJson.baseBranch}\",\"required\":true},{\"name\":\"sourceEnv\",\"value\":\"{$Source.apex.EnvironmentVariables}\",\"required\":true},{\"name\":\"findAndReplaceFileId\",\"value\":\"{$Context.apex.GlobalFindAndReplaceSourceId}\",\"required\":false},{\"name\":\"featureBranch\",\"value\":\"{$Context.JobExecution__r.DataJson.featureBranchName}\",\"required\":true},{\"name\":\"recreateIfExists\",\"value\":\"{$Context.JobExecution__r.DataJson.recreateFeatureBranch}\",\"required\":true},{\"name\":\"commitMessage\",\"value\":\"{$Context.JobExecution__r.DataJson.message}\",\"required\":true},{\"name\":\"gitEmail\",\"value\":\"{$User.Email}\",\"required\":true},{\"name\":\"gitName\",\"value\":\"{$User.Name}\",\"required\":true},{\"name\":\"sourceEnvironmentBranch\",\"value\":\"{$Context.apex.SourceEnvironmentBranch}\",\"required\":true},{\"name\":\"gitDepth\",\"value\":\"{$Pipeline.Property.gitDepth_commit}\"},{\"name\":\"timeout\",\"value\":\"180000\"},{\"name\":\"chunkSize\",\"value\":\"10\"},{\"name\":\"maxBuffer\",\"value\":\"5242880\"},{\"name\":\"overriddenApiVersion\",\"value\":\"\"},{\"name\":\"commitId\",\"value\":\"{$Context.JobExecution__r.DataJson.commitId}\"},{\"name\":\"vlocityFilesPath\",\"value\":\"/app/vlocity/\"},{\"name\":\"disableEarlyCommitCompletion\",\"value\":\"{$Pipeline.Property.disableEarlyCommitCompletion}\"}],\"sharedResource\":\"\"}",
                    "copado__CustomType__c": "Function",
                    "copado__JobTemplate__c": "a0u7Q000000Xw28QAC",
                    "copado__Order__c": 1,
                    "copado__Type__c": "Function",
                    "Id": "a0t7Q000000NQaAQAW",
                    "Name": "Commit"
                },
                {
                    "attributes": {
                        "type": "copado__JobStep__c",
                        "url": "/services/data/v57.0/sobjects/copado__JobStep__c/a0t7Q000000NTrrQAG"
                    },
                    "copado__ApiName__c": "sfdx_commit_1_Create Test Records_2",
                    "copado__ConfigJson__c": "{\"flowName\":\"cmcSf.Test_Record_Automation\",\"parameters\":[{\"name\":\"userStoryId\",\"value\":\"{$Context.JobExecution__r.DataJson.userStoryId}\"},{\"name\":\"recreateFeatureBranch\",\"value\":\"{$Context.JobExecution__r.DataJson.recreateFeatureBranch}\"},{\"name\":\"fileWithSelectedChanges\",\"value\":\"{$Context.JobExecution__r.DataJson.fileWithSelectedChanges}\"},{\"name\":\"commitResult\",\"value\":\"{$Job.PrevStep.ResultDataJson__c}\"}]}",
                    "copado__CustomType__c": "Salesforce Flow",
                    "copado__JobTemplate__c": "a0u7Q000000Xw28QAC",
                    "copado__Order__c": 2,
                    "copado__Type__c": "Flow",
                    "Id": "a0t7Q000000NTrrQAG",
                    "Name": "Create Test Records"
                },
                {
                    "attributes": {
                        "type": "copado__JobStep__c",
                        "url": "/services/data/v57.0/sobjects/copado__JobStep__c/a0t7Q000000NTwWQAW"
                    },
                    "copado__ApiName__c": "sfdx_deploy_sfdx_deploy",
                    "copado__ConfigJson__c": "{\"functionName\":\"sfdx_deploy\",\"parameters\":[{\"name\":\"fileChangesId\",\"value\":\"{$Context.JobExecution__r.DataJson.fileWithSelectedChanges}\",\"required\":true},{\"name\":\"promotion\",\"value\":\"{$Context.JobExecution__r.DataJson.promotionBranchName}\",\"required\":true},{\"name\":\"targetBranch\",\"value\":\"{$Context.JobExecution__r.DataJson.destinationBranchName}\",\"required\":true},{\"name\":\"destinationInstanceUrl\",\"value\":\"{$Destination.Credential.Endpoint}\",\"required\":true},{\"name\":\"destinationSessionid\",\"value\":\"{$Destination.Credential.SessionId}\",\"required\":true},{\"name\":\"git_json\",\"value\":\"{$Context.Repository.Credential}\",\"required\":true},{\"name\":\"destinationEnv\",\"value\":\"{$Destination.apex.EnvironmentVariables}\",\"required\":true},{\"name\":\"findAndReplaceRules\",\"value\":\"{$Context.apex.GlobalFindAndReplaceDestinationId}\"},{\"name\":\"isValidation\",\"value\":\"{$Context.JobExecution__r.DataJson.deploymentDryRun}\",\"required\":true},{\"name\":\"gitName\",\"value\":\"{$User.Name}\"},{\"name\":\"gitEmail\",\"value\":\"{$User.Email}\"},{\"name\":\"testLevel\",\"value\":\"{$Job.ExecutionParent.Promotion__r.cmcSf__Apex_Test_Level__c}\"},{\"name\":\"testOnlyClasses\",\"value\":\"{$Context.apex.cmcSf.GetTestOnlyClasses}\"},{\"name\":\"debugMode\",\"value\":\"{$Job.ExecutionParent.Promotion__r.cmcSf__Debug_Mode__c}\"},{\"name\":\"gitDepth\",\"value\":\"{$Pipeline.Property.gitDepth_deploy}\"},{\"name\":\"validationId\",\"value\":\"{$Job.ExecutionParent.Promotion__r.cmcSf__Validate_Deploy_Request_Id__c}\"},{\"name\":\"testClasses\",\"value\":\"{$Context.apex.cmcSf.GetTestClasses}\"},{\"name\":\"maxBuffer\",\"value\":\"5242880\"},{\"name\":\"waitTime\",\"value\":\"220\"},{\"name\":\"sourceInstanceUrl\",\"value\":\"{$Source.Credential.Endpoint}\"},{\"name\":\"sourceSessionid\",\"value\":\"{$Source.Credential.SessionId}\"},{\"name\":\"mergeProfile\",\"value\":\"false\"},{\"name\":\"overriddenApiVersion\",\"value\":\"\"},{\"name\":\"isProductionEnvironment\",\"value\":\"{$Context.apex.cmcSf.IdentifyProductionEnvironment}\",\"required\":true},{\"name\":\"hasVlocityChanges\",\"value\":\"{$Context.apex.cmcSf.HasVlocityChanges}\"},{\"name\":\"rollBackEnabled\",\"value\":\"{$Context.apex.cmcSf.IsRollBackEnabled}\"}],\"sharedResource\":\"{$Context.JobExecution__r.Pipeline__r.Git_Repository__r.URI__c}/{$Destination.Branch}\"}",
                    "copado__CustomType__c": "Function",
                    "copado__JobTemplate__c": "a0u7Q000000Xw29QAC",
                    "copado__Order__c": 2,
                    "copado__Type__c": "Function",
                    "Id": "a0t7Q000000NTwWQAW",
                    "Name": "Deploy"
                },
                {
                    "attributes": {
                        "type": "copado__JobStep__c",
                        "url": "/services/data/v55.0/sobjects/copado__JobStep__c/a0t7Q000000N7q1QAC"
                    },
                    "copado__ApiName__c": "sfdx_deploy_Encode Deploy changes",
                    "copado__ConfigJson__c": "{\"functionName\":\"sfdx_encode_file_names\",\"parameters\":[{\"name\":\"file_changes_id\",\"value\":\"{$Context.JobExecution__r.DataJson.fileWithSelectedChanges}\"},{\"name\":\"file_name\",\"value\":\"Copado Deploy changes\"}]}",
                    "copado__CustomType__c": "Function",
                    "copado__JobTemplate__c": "a0u7Q000000Xw29QAC",
                    "copado__Order__c": 1,
                    "copado__Type__c": "Function",
                    "Id": "a0t7Q000000N7q1QAC",
                    "Name": "Encode file names"
                },
                {
                    "attributes": {
                        "type": "copado__JobStep__c",
                        "url": "/services/data/v56.0/sobjects/copado__JobStep__c/a0t7Q000000N7q2QAC"
                    },
                    "copado__ApiName__c": "sfdx_promote_sfdx_promote",
                    "copado__ConfigJson__c": "{\"functionName\":\"sfdx_promote\",\"parameters\":[{\"name\":\"userStoryBranches\",\"value\":\"{$Context.JobExecution__r.DataJson.userStoryBranches}\",\"required\":true},{\"name\":\"promotionBranch\",\"value\":\"{$Context.JobExecution__r.DataJson.promotionBranchName}\",\"required\":true},{\"name\":\"targetBranch\",\"value\":\"{$Context.JobExecution__r.DataJson.destinationBranchName}\",\"required\":true},{\"name\":\"tag\",\"value\":\"{$Context.JobExecution__r.Promotion__r.Release__r.Version__c}\",\"required\":false},{\"name\":\"git_json\",\"value\":\"{$Context.Repository.Credential}\",\"required\":true},{\"name\":\"recreatePromotionBranch\",\"value\":\"{$Context.JobExecution__r.Promotion__r.cmcSf__Recreate_Promotion_Branch__c}\",\"required\":false},{\"name\":\"promotionId\",\"value\":\"{$Job.ExecutionParent.Id}\"},{\"name\":\"fileChangesId\",\"value\":\"{$Context.JobExecution__r.DataJson.fileWithSelectedChanges}\"},{\"name\":\"conflictResolutionAttachments\",\"value\":\"{$Context.apex.GetConflictResolutionAttachments}\"},{\"name\":\"gitName\",\"value\":\"{$User.Name}\"},{\"name\":\"gitEmail\",\"value\":\"{$User.Email}\"},{\"name\":\"repositoryId\",\"value\":\"{$Pipeline.Git_Repository__r.Id}\"},{\"name\":\"gitDepth\",\"value\":\"{$Pipeline.Property.gitDepth_promote}\",\"required\":false},{\"name\":\"maxBuffer\",\"value\":\"5242880\"},{\"name\":\"fileName\",\"value\":\"Copado Promotion changes\",\"required\":true},{\"name\":\"overriddenApiVersion\",\"value\":\"\"}],\"sharedResource\":\"{$Context.JobExecution__r.Pipeline__r.Git_Repository__r.URI__c}/{$Destination.Branch}\"}",
                    "copado__CustomType__c": "Function",
                    "copado__JobTemplate__c": "a0u7Q000000Xw2AQAS",
                    "copado__Order__c": 1,
                    "copado__Type__c": "Function",
                    "Id": "a0t7Q000000N7q2QAC",
                    "Name": "Promote"
                },
                {
                    "attributes": {
                        "type": "copado__JobStep__c",
                        "url": "/services/data/v52.0/sobjects/copado__JobStep__c/a0s09000000KT2TAAW"
                    },
                    "copado__ApiName__c": "SFDX Package Import_Retrieve Package Information",
                    "copado__ConfigJson__c": "{\"functionName\":\"Devhub_Package_Info\",\"parameters\":[{\"name\":\"packageNameOrId\",\"value\":\"{$Context.JobExecution__r.DataJson.packageNameOrId}\",\"required\":true},{\"name\":\"session\",\"value\":\"{$Source.Credential.SessionId}\",\"required\":true},{\"name\":\"baseUrl\",\"value\":\"{$Source.Credential.Endpoint}\",\"required\":true},{\"name\":\"jobStepId\",\"value\":\"{$Context.Id}\",\"required\":false}]}",
                    "copado__JobTemplate__c": "a0t09000002vfccAAA",
                    "copado__Order__c": 2,
                    "copado__CustomType__c": "Function",
                    "copado__Type__c": "Function",
                    "CreatedDate": "2021-10-04T09:11:43.000+0000",
                    "Id": "a0s09000000KT2TAAW",
                    "IsDeleted": false,
                    "LastModifiedDate": "2021-10-04T09:59:20.000+0000",
                    "Name": "Retrieve Package Information",
                    "SystemModstamp": "2021-10-04T09:59:20.000+0000"
                },
                {
                    "attributes": {
                        "type": "copado__JobStep__c",
                        "url": "/services/data/v53.0/sobjects/copado__JobStep__c/a0s09000000KT2UAAW"
                    },
                    "copado__ApiName__c": "SFDX Package Import_Upsert Package Information",
                    "copado__ConfigJson__c": "{\"flowName\":\"cmcSf.ImportPackageAndVersions\",\"parameters\":[{\"name\":\"prevResultId\",\"value\":\"{$Job.PrevStep.Result__r.Id}\"},{\"name\":\"pipelineId\",\"value\":\"{$Context.JobExecution__r.DataJson.pipelineId}\"},{\"name\":\"jsonInformation\",\"value\":\"{$Context.JobExecution__r.DataJson.jsonInformation}\"},{\"name\":\"type\",\"value\":\"wait\"}]}",
                    "copado__JobTemplate__c": "a0t09000002vfccAAA",
                    "copado__Order__c": 3,
                    "copado__CustomType__c": "Flow",
                    "copado__Type__c": "Flow",
                    "CreatedDate": "2021-10-04T09:11:43.000+0000",
                    "Id": "a0s09000000KT2UAAW",
                    "IsDeleted": false,
                    "LastModifiedDate": "2021-10-31T21:44:48.000+0000",
                    "Name": "Upsert Package Information",
                    "SystemModstamp": "2021-10-31T21:44:48.000+0000"
                },
                {
                    "attributes": {
                        "type": "copado__JobStep__c",
                        "url": "/services/data/v52.0/sobjects/copado__JobStep__c/a0s09000000KT2WAAW"
                    },
                    "copado__ApiName__c": "SFDX Package Import_Update Source on Job Execution",
                    "copado__ConfigJson__c": "{\"flowName\":\"cmcSf.Update_Source_on_Job_Execution\",\"parameters\":[{\"name\":\"type\",\"value\":\"wait\"},{\"name\":\"jsonInformation\",\"value\":\"{$Context.JobExecution__r.DataJson.jsonInformation}\"}]}",
                    "copado__JobTemplate__c": "a0t09000002vfccAAA",
                    "copado__Order__c": 1,
                    "copado__CustomType__c": "Flow",
                    "copado__Type__c": "Flow",
                    "CreatedDate": "2021-10-04T09:14:13.000+0000",
                    "Id": "a0s09000000KT2WAAW",
                    "IsDeleted": false,
                    "LastModifiedDate": "2021-10-04T10:48:24.000+0000",
                    "Name": "Update Source on Job Execution",
                    "SystemModstamp": "2021-10-04T10:48:24.000+0000"
                },
                {
                    "attributes": {
                        "type": "copado__JobStep__c",
                        "url": "/services/data/v56.0/sobjects/copado__JobStep__c/a0t7Q00000720dNQAQ"
                    },
                    "copado__ApiName__c": "SFDX Package Version Publish_Promote Package to Release",
                    "copado__ConfigJson__c": "{\"functionName\":\"sfdx_package_version_publish\",\"parameters\":[{\"name\":\"versionDetails\",\"value\":\"{$Job.PrevStep.Result__r.Result_Data__c}\",\"required\":true},{\"name\":\"sessionId\",\"value\":\"{$Destination.Credential.SessionId}\",\"required\":true},{\"name\":\"endpoint\",\"value\":\"{$Destination.Credential.Endpoint}\",\"required\":true}]}",
                    "copado__CustomType__c": "Function",
                    "copado__JobTemplate__c": "a0u7Q0000004wGqQAI",
                    "copado__Order__c": 2,
                    "copado__Type__c": "Function",
                    "Id": "a0t7Q00000720dNQAQ",
                    "Name": "Publish Package Version"
                },
                {
                    "attributes": {
                        "type": "copado__JobStep__c",
                        "url": "/services/data/v56.0/sobjects/copado__JobStep__c/a0t7Q00000720dOQAQ"
                    },
                    "copado__ApiName__c": "SFDX Package Version Publish_Update Destination on Job Execution",
                    "copado__ConfigJson__c": "{\"flowName\":\"cmcSf.UpdatePackageVersionRequisite\",\"parameters\":[{\"name\":\"packageVersionId\",\"value\":\"{$Context.JobExecution__r.DataJson.packageVersionId}\"},{\"name\":\"type\",\"value\":\"wait\"}]}",
                    "copado__CustomType__c": "Flow",
                    "copado__JobTemplate__c": "a0u7Q0000004wGqQAI",
                    "copado__Order__c": 1,
                    "copado__Type__c": "Flow",
                    "Id": "a0t7Q00000720dOQAQ",
                    "Name": "Update Package Version Requisite"
                },
                {
                    "attributes": {
                        "type": "copado__JobStep__c",
                        "url": "/services/data/v56.0/sobjects/copado__JobStep__c/a0t7Q000001Re2XQAS"
                    },
                    "copado__ApiName__c": "SFDX Package Version Update_Update Package Version",
                    "copado__ConfigJson__c": "{\"functionName\":\"SFDX_Package_Version_Update\",\"parameters\":[{\"name\":\"devhubSession\",\"value\":\"{$Destination.Credential.SessionId}\",\"required\":true},{\"name\":\"devhubEndpoint\",\"value\":\"{$Destination.Credential.Endpoint}\",\"required\":true},{\"name\":\"packageVersion\",\"value\":\"{$Context.JobExecution__r.DataJson.packageVersion}\",\"required\":false},{\"name\":\"installationKey\",\"value\":\"{$Context.JobExecution__r.DataJson.installationKey}\"},{\"name\":\"apiVersion\",\"value\":\"{$Context.JobExecution__r.DataJson.apiVersion}\"}]}",
                    "copado__CustomType__c": "Function",
                    "copado__JobTemplate__c": "a0u7Q0000004wGrQAI",
                    "copado__Order__c": 1,
                    "copado__Type__c": "Function",
                    "Id": "a0t7Q000001Re2XQAS",
                    "Name": "Update Package Version"
                },
                {
                    "attributes": {
                        "type": "copado__JobStep__c",
                        "url": "/services/data/v56.0/sobjects/copado__JobStep__c/a0t7Q000001Re2YQAS"
                    },
                    "copado__ApiName__c": "SFDX Package Version Update_Update Records",
                    "copado__ConfigJson__c": "{\"flowName\":\"cmcSf.UpdatePackageVersion\",\"parameters\":[{\"name\":\"prevResultId\",\"value\":\"{$Job.PrevStep.Result__c}\"},{\"name\":\"type\",\"value\":\"wait\"},{\"name\":\"installationKey\",\"value\":\"{$Context.JobExecution__r.DataJson.installationKey}\"}]}",
                    "copado__CustomType__c": "Flow",
                    "copado__JobTemplate__c": "a0u7Q0000004wGrQAI",
                    "copado__Order__c": 2,
                    "copado__Type__c": "Flow",
                    "Id": "a0t7Q000001Re2YQAS",
                    "Name": "Update Records"
                },
                {
                    "attributes": {
                        "type": "copado__JobStep__c",
                        "url": "/services/data/v56.0/sobjects/copado__JobStep__c/a0t7Q000001Re2ZQAS"
                    },
                    "copado__ApiName__c": "SFDX Package Version Create_Create SFDX Package Version",
                    "copado__ConfigJson__c": "{\"functionName\":\"SFDX_Package_Version_Create\",\"parameters\":[{\"name\":\"endPoint\",\"value\":\"{$Destination.Credential.Endpoint}\",\"required\":true},{\"name\":\"session\",\"value\":\"{$Destination.Credential.SessionId}\",\"required\":true},{\"name\":\"packageId\",\"value\":\"{$Job.PrevStep.Result__r.Result_Data__c}\",\"required\":false},{\"name\":\"versionName\",\"value\":\"{$Context.JobExecution__r.DataJson.versionName}\"},{\"name\":\"versionNumber\",\"value\":\"{$Context.JobExecution__r.DataJson.versionNumber}\"},{\"name\":\"description\",\"value\":\"{$Context.JobExecution__r.DataJson.description}\"},{\"name\":\"jsonInformation\",\"value\":\"{$Context.JobExecution__r.DataJson.jsonInformation}\",\"required\":false},{\"name\":\"git_json\",\"value\":\"{$Context.Repository.Credential}\",\"required\":true},{\"name\":\"gitName\",\"value\":\"{$User.Name}\"},{\"name\":\"gitEmail\",\"value\":\"{$User.Email}\"},{\"name\":\"pollInterval\",\"value\":\"{$Property.sfdx_package_version_create_poll_time_in_seconds}\"},{\"name\":\"retrialTimes\",\"value\":\"{$Property.sfdx_package_version_create_retrial_number}\"}]}",
                    "copado__CustomType__c": "Function",
                    "copado__JobTemplate__c": "a0u7Q0000004wGsQAI",
                    "copado__Order__c": 2,
                    "copado__Type__c": "Function",
                    "Id": "a0t7Q000001Re2ZQAS",
                    "Name": "Create SFDX Package Version"
                },
                {
                    "attributes": {
                        "type": "copado__JobStep__c",
                        "url": "/services/data/v56.0/sobjects/copado__JobStep__c/a0t7Q000001Re2aQAC"
                    },
                    "copado__ApiName__c": "SFDX Package Version Create_Update Destination on Job Execution",
                    "copado__ConfigJson__c": "{\"flowName\":\"cmcSf.UpdatePackageRequisite\",\"parameters\":[{\"name\":\"packageId\",\"value\":\"{$Context.JobExecution__r.DataJson.packageId}\"},{\"name\":\"type\",\"value\":\"wait\"}]}",
                    "copado__CustomType__c": "Flow",
                    "copado__JobTemplate__c": "a0u7Q0000004wGsQAI",
                    "copado__Order__c": 1,
                    "copado__Type__c": "Flow",
                    "Id": "a0t7Q000001Re2aQAC",
                    "Name": "Update Package Requisite"
                },
                {
                    "attributes": {
                        "type": "copado__JobStep__c",
                        "url": "/services/data/v56.0/sobjects/copado__JobStep__c/a0t7Q000001Re2bQAC"
                    },
                    "copado__ApiName__c": "SFDX Package Version Publish_Insert Package Version Information",
                    "copado__ConfigJson__c": "{\"flowName\":\"cmcSf.CreatePackageVersion\",\"parameters\":[{\"name\":\"packageVersionJson\",\"value\":\"{$Job.PrevStep.Result__r.Result_Data__c}\"},{\"name\":\"jsonInformation\",\"value\":\"{$Job.PrevStep.JobExecution__r.DataJson__c}\"},{\"name\":\"jobExecutionId\",\"value\":\"{$Context.JobExecution__r.Id}\"}]}",
                    "copado__CustomType__c": "Flow",
                    "copado__JobTemplate__c": "a0u7Q0000004wGsQAI",
                    "copado__Order__c": 3,
                    "copado__Type__c": "Flow",
                    "Id": "a0t7Q000001Re2bQAC",
                    "Name": "Insert Package Version Information"
                },
                {
                    "attributes": {
                        "type": "copado__JobStep__c",
                        "url": "/services/data/v56.0/sobjects/copado__JobStep__c/a0t7Q000002nFwNQAU"
                    },
                    "copado__ApiName__c": "SFDX Package Create_Create Package on Destination",
                    "copado__ConfigJson__c": "{\"functionName\":\"SFDXPackageCreate\",\"parameters\":[{\"name\":\"devhubEndpoint\",\"value\":\"{$Destination.Credential.Endpoint}\",\"required\":true},{\"name\":\"devhubSession\",\"value\":\"{$Destination.Credential.SessionId}\",\"required\":true},{\"name\":\"packageName\",\"value\":\"{$Job.ExecutionParent.Name}\",\"required\":false},{\"name\":\"path\",\"value\":\"{$Job.ExecutionParent.cmcSf__PackagePath__c}\"},{\"name\":\"jsonInformation\",\"value\":\"{$Context.JobExecution__r.DataJson.jsonInformation}\"},{\"name\":\"description\",\"value\":\"{$Job.ExecutionParent.copado__Description__c}\"},{\"name\":\"git_json\",\"value\":\"{$Context.Repository.Credential}\",\"required\":true},{\"name\":\"branch\",\"value\":\"{$Job.ExecutionParent.copado__DefaultBranch__c}\"},{\"name\":\"gitName\",\"value\":\"{$User.Name}\"},{\"name\":\"gitEmail\",\"value\":\"{$User.Email}\"}]}",
                    "copado__CustomType__c": "Function",
                    "copado__JobTemplate__c": "a0u7Q0000004wGtQAI",
                    "copado__Order__c": 2,
                    "copado__Type__c": "Function",
                    "Id": "a0t7Q000002nFwNQAU",
                    "Name": "Create Package on Destination"
                },
                {
                    "attributes": {
                        "type": "copado__JobStep__c",
                        "url": "/services/data/v56.0/sobjects/copado__JobStep__c/a0t7Q000002nFwOQAU"
                    },
                    "copado__ApiName__c": "SFDX Package Create_Update Package",
                    "copado__ConfigJson__c": "{\"flowName\":\"cmcSf.UpdatePackage\",\"parameters\":[{\"name\":\"packageRecordId\",\"value\":\"{$Context.JobExecution__r.DataJson.packageId}\"},{\"name\":\"packageInfo\",\"value\":\"{$Job.PrevStep.Result__r.Result_Data__c}\"}]}",
                    "copado__CustomType__c": "Salesforce Flow",
                    "copado__JobTemplate__c": "a0u7Q0000004wGtQAI",
                    "copado__Order__c": 3,
                    "copado__Type__c": "Flow",
                    "Id": "a0t7Q000002nFwOQAU",
                    "Name": "Update Package"
                },
                {
                    "attributes": {
                        "type": "copado__JobStep__c",
                        "url": "/services/data/v56.0/sobjects/copado__JobStep__c/a0t7Q000002nFwPQAU"
                    },
                    "copado__ApiName__c": "SFDX Package Create_Update Destination on Job Ex",
                    "copado__ConfigJson__c": "{\"flowName\":\"cmcSf.UpdateDestinationOnJobExecution\",\"parameters\":[{\"name\":\"packageId\",\"value\":\"{$Context.JobExecution__r.DataJson.packageId}\"}]}",
                    "copado__CustomType__c": "Flow",
                    "copado__JobTemplate__c": "a0u7Q0000004wGtQAI",
                    "copado__Order__c": 1,
                    "copado__Type__c": "Flow",
                    "Id": "a0t7Q000002nFwPQAU",
                    "Name": "Update Destination on Job Execution"
                },
                {
                    "attributes": {
                        "type": "copado__JobStep__c",
                        "url": "/services/data/v54.0/sobjects/copado__JobStep__c/a0t7Q000000Li7RQAS"
                    },
                    "copado__ApiName__c": "SFDX Run Apex Tests_Run Apex Tests",
                    "copado__ConfigJson__c": "{\"functionName\":\"SFDXRunApexTests\",\"parameters\":[{\"name\":\"source_session_id\",\"value\":\"{$Source.Credential.SessionId}\"},{\"name\":\"source_endpoint\",\"value\":\"{$Source.Credential.Endpoint}\"},{\"name\":\"namespace\",\"value\":\"\"},{\"name\":\"source_path\",\"value\":\"force-app\"},{\"name\":\"test_minutes_timeout\",\"value\":\"1440\"},{\"name\":\"test_result_ids\",\"value\":\"{$Context.JobExecution__r.DataJson.resultIds}\"},{\"name\":\"test_classes\",\"value\":\"{$Context.apex.cmcSf.GetTestClasses}\"},{\"name\":\"consolidated_result_id\",\"value\":\"{$Context.JobExecution__r.DataJson.resultId}\"}]}",
                    "copado__CustomType__c": "Function",
                    "copado__JobTemplate__c": "a0u7Q000000XrrkQAC",
                    "copado__Order__c": 3,
                    "copado__Type__c": "Function",
                    "Id": "a0t7Q000000Li7RQAS",
                    "Name": "Run Apex Tests"
                },
                {
                    "attributes": {
                        "type": "copado__JobStep__c",
                        "url": "/services/data/v54.0/sobjects/copado__JobStep__c/a0t7Q000000Li7SQAS"
                    },
                    "copado__ApiName__c": "SFDX Run Apex Tests_Populate Source Environment",
                    "copado__ConfigJson__c": "{\"flowName\":\"cmcSf.SetSourceEnvironmentOnApexTestJobExecution\",\"parameters\":[{\"name\":\"jobExecutionId\",\"value\":\"{$Context.JobExecution__r.Id}\"},{\"name\":\"testIds\",\"value\":\"{$Context.JobExecution__r.DataJson.testIds}\"}]}",
                    "copado__CustomType__c": "Salesforce Flow",
                    "copado__JobTemplate__c": "a0u7Q000000XrrkQAC",
                    "copado__Order__c": 1,
                    "copado__Type__c": "Flow",
                    "Id": "a0t7Q000000Li7SQAS",
                    "Name": "Set Source Environment"
                },
                {
                    "attributes": {
                        "type": "copado__JobStep__c",
                        "url": "/services/data/v54.0/sobjects/copado__JobStep__c/a0t7Q000000Li7TQAS"
                    },
                    "copado__ApiName__c": "SFDX Run Apex Tests_Evaluate Apex Tests Acceptance Criteria",
                    "copado__ConfigJson__c": "{\"flowName\":\"cmcSf.EvaluateApexTestsAcceptanceCriteria\",\"parameters\":[{\"name\":\"acceptanceCriteria\",\"value\":\"{$Context.JobExecution__r.DataJson.acceptanceCriteria}\"},{\"name\":\"resultIds\",\"value\":\"{$Context.JobExecution__r.DataJson.resultIds}\"},{\"name\":\"consolidatedResultId\",\"value\":\"{$Context.JobExecution__r.DataJson.resultId}\"},{\"name\":\"fileWithSelectedChanges\",\"value\":\"{$Context.JobExecution__r.DataJson.fileWithSelectedChanges}\"},{\"name\":\"recreateFeatureBranch\",\"value\":\"{$Context.JobExecution__r.DataJson.recreateFeatureBranch}\"}]}",
                    "copado__CustomType__c": "Salesforce Flow",
                    "copado__JobTemplate__c": "a0u7Q000000XrrkQAC",
                    "copado__Order__c": 4,
                    "copado__Type__c": "Flow",
                    "Id": "a0t7Q000000Li7TQAS",
                    "Name": "Evaluate Apex Tests Acceptance Criteria"
                },
                {
                    "attributes": {
                        "type": "copado__JobStep__c",
                        "url": "/services/data/v56.0/sobjects/copado__JobStep__c/a0t7Q000007JaxEQAS"
                    },
                    "copado__ApiName__c": "SFDX Package Version Git Configure_Git Config",
                    "copado__ConfigJson__c": "{\"functionName\":\"SFDX_Package_Version_Git_Config\",\"parameters\":[{\"name\":\"packageVersion\",\"value\":\"{$Context.JobExecution__r.DataJson.packageVersion}\",\"required\":true},{\"name\":\"git_json\",\"value\":\"{$Context.Repository.Credential}\",\"required\":true},{\"name\":\"dxNamespace\",\"value\":\"{$Context.apex.cmcSf.GetDxNamespace}\"}]}",
                    "copado__CustomType__c": "Function",
                    "copado__JobTemplate__c": "a0u7Q0000004yiqQAA",
                    "copado__Order__c": 1,
                    "copado__Type__c": "Function",
                    "Id": "a0t7Q000007JaxEQAS",
                    "Name": "Git Config"
                },
                {
                    "attributes": {
                        "type": "copado__JobStep__c",
                        "url": "/services/data/v56.0/sobjects/copado__JobStep__c/a0t7Q000007JaxFQAS"
                    },
                    "copado__ApiName__c": "SFDX Package Version Git Configure_1_Update Record",
                    "copado__ConfigJson__c": "{\"flowName\":\"cmcSf.UpdatePackageVersion\",\"parameters\":[{\"name\":\"prevResultId\",\"value\":\"{$Job.PrevStep.Result__c}\"},{\"name\":\"type\",\"value\":\"wait\"}]}",
                    "copado__CustomType__c": "Salesforce Flow",
                    "copado__JobTemplate__c": "a0u7Q0000004yiqQAA",
                    "copado__Order__c": 2,
                    "copado__Type__c": "Flow",
                    "Id": "a0t7Q000007JaxFQAS",
                    "Name": "Update Record"
                },
                {
                    "attributes": {
                        "type": "copado__JobStep__c",
                        "url": "/services/data/v55.0/sobjects/copado__JobStep__c/a0s090000020VnJAAU"
                    },
                    "copado__ApiName__c": "SFDX Test Records Creation In User Story_1_Apex Test Record Automation_1",
                    "copado__ConfigJson__c": "{\"flowName\":\"cmcSf.Apex_Test_Record_Automation\",\"parameters\":[{\"name\":\"userStoryId\",\"value\":\"{$Context.JobExecution__r.DataJson.userStoryId}\"},{\"name\":\"recreateFeatureBranch\",\"value\":\"{$Context.JobExecution__r.DataJson.recreateFeatureBranch}\"}]}",
                    "copado__CustomType__c": "Salesforce Flow",
                    "copado__JobTemplate__c": "a0t09000000lkYtAAI",
                    "copado__Order__c": 1,
                    "copado__Type__c": "Flow",
                    "Id": "a0s090000020VnJAAU",
                    "Name": "Apex Test Record Automation"
                },
                {
                    "attributes": {
                        "type": "copado__JobStep__c",
                        "url": "/services/data/v56.0/sobjects/copado__JobStep__c/a0s090000020XIKAA2"
                    },
                    "copado__ApiName__c": "SFDX Metadata Refresh_1_Metadata Refresh_1",
                    "copado__ConfigJson__c": "{\"functionName\":\"SFDX_Refresh_Metadata\",\"parameters\":[{\"name\":\"SESSION_ID\",\"value\":\"{$Source.Credential.SessionId}\",\"required\":true},{\"name\":\"ENDPOINT\",\"value\":\"{$Source.Credential.Endpoint}\",\"required\":true},{\"name\":\"METADATA_FILE_ID\",\"value\":\"{$Context.JobExecution__r.DataJson.metadataFileId}\",\"required\":false},{\"name\":\"IGNORED_TYPE\",\"value\":\"{$Context.JobExecution__r.DataJson.ignoredType}\"},{\"name\":\"TYPE_FILTER\",\"value\":\"{$Context.JobExecution__r.DataJson.typeFilter}\"},{\"name\":\"MAX_BUFFER\",\"value\":\"5242880\"}]}",
                    "copado__CustomType__c": "Function",
                    "copado__JobTemplate__c": "a0t09000000llqoAAA",
                    "copado__Order__c": 1,
                    "copado__Type__c": "Function",
                    "Id": "a0s090000020XIKAA2",
                    "Name": "Refresh Metadata"
                },
                {
                    "attributes": {
                        "type": "copado__JobStep__c",
                        "url": "/services/data/v57.0/sobjects/copado__JobStep__c/a0t7Q000000NkARQA0"
                    },
                    "copado__ApiName__c": "SFDX Initialize Project_1_Initialize Git with SFDX Project_1",
                    "copado__ConfigJson__c": "{\"functionName\":\"Initialize_Git_With_SFDX_Project\",\"parameters\":[{\"name\":\"branch\",\"value\":\"{$Context.JobExecution__r.DataJson.branch}\",\"required\":false},{\"name\":\"defaultDirectory\",\"value\":\"{$Context.JobExecution__r.DataJson.defaultDirectory}\",\"required\":false},{\"name\":\"template\",\"value\":\"{$Context.JobExecution__r.DataJson.template}\"},{\"name\":\"projectName\",\"value\":\"{$Context.JobExecution__r.DataJson.projectName}\"},{\"name\":\"recreateProject\",\"value\":\"{$Context.JobExecution__r.DataJson.recreateProject}\"},{\"name\":\"maxBuffer\",\"value\":\"5242880\"},{\"name\":\"gitName\",\"value\":\"{$User.Name}\"},{\"name\":\"gitEmail\",\"value\":\"{$User.Email}\"},{\"name\":\"overriddenApiVersion\",\"value\":\"\"},{\"name\":\"git_json\",\"value\":\"{$Context.apex.cmcSf.GetGitJson}\"}],\"sharedResource\":\"{$Context.JobExecution__r.DataJson.gitRepositoryURI}/{$Context.JobExecution__r.DataJson.branch}\"}",
                    "copado__CustomType__c": "Function",
                    "copado__JobTemplate__c": "a0u7Q000000ZJ20QAG",
                    "copado__Order__c": 1,
                    "copado__Type__c": "Function",
                    "Id": "a0t7Q000000NkARQA0",
                    "Name": "Initialize Git with SFDX Project"
                },
                {
                    "attributes": {
                      "type": "copado__JobStep__c",
                      "url": "/services/data/v58.0/sobjects/copado__JobStep__c/a0t7Q00000BzrjqQAB"
                    },
                    "copado__ApiName__c": "SFDX Vlocity Commit_1_Retrieve Vlocity_1",
                    "copado__ConfigJson__c": "{\"functionName\":\"vlocity_retrieve\",\"parameters\":[{\"name\":\"fileChangesId\",\"value\":\"{$Context.JobExecution__r.DataJson.fileWithSelectedChanges}\",\"required\":false},{\"name\":\"sourceSessionId\",\"value\":\"{$Source.Credential.SessionId}\",\"required\":true},{\"name\":\"sourceEndPoint\",\"value\":\"{$Source.Credential.Endpoint}\",\"required\":true},{\"name\":\"sourceDirectory\",\"value\":\"vlocity\",\"required\":true},{\"name\":\"copadoCommitFileName\",\"value\":\"Copado Commit changes\",\"required\":true},{\"name\":\"maxDepth\",\"value\":\"0\"},{\"name\":\"selectedDataPacks\",\"value\":\"\"},{\"name\":\"vlocitySettingsDocumentId\",\"value\":\"{$Context.apex.cmcSf.VlocitySettingsSourceId}\"}]}",
                    "copado__CustomType__c": "Function",
                    "copado__IsSkipped__c": false,
                    "copado__JobTemplate__c": "a0u7Q000004z6sOQAQ",
                    "copado__Order__c": 1,
                    "copado__Type__c": "Function",
                    "Id": "a0t7Q00000CUGTcQAP",
                    "LastReferencedDate": "2023-06-27T18:19:11.000+0000",
                    "LastViewedDate": "2023-06-27T18:19:11.000+0000",
                    "Name": "Vlocity Retrieve"
                  },
                {
                    "attributes": {
                        "type": "copado__JobStep__c",
                        "url": "/services/data/v57.0/sobjects/copado__JobStep__c/a0t7Q00000BzrjrQAB"
                    },
                    "copado__ApiName__c": "SFDX Vlocity Commit_1_SFDX Commit_2",
                    "copado__ConfigJson__c": "{\"functionName\":\"sfdx_commit\",\"parameters\":[{\"name\":\"fileChangesId\",\"value\":\"{$Context.JobExecution__r.DataJson.fileWithSelectedChanges}\",\"required\":true},{\"name\":\"fileName\",\"value\":\"Copado Commit changes\",\"required\":true},{\"name\":\"sourceSessionId\",\"value\":\"{$Source.Credential.SessionId}\",\"required\":true},{\"name\":\"sourceEndPoint\",\"value\":\"{$Source.Credential.Endpoint}\",\"required\":true},{\"name\":\"namespace\",\"value\":\"\"},{\"name\":\"git_json\",\"value\":\"{$Context.Repository.Credential}\",\"required\":true},{\"name\":\"baseBranch\",\"value\":\"{$Context.JobExecution__r.DataJson.baseBranch}\",\"required\":true},{\"name\":\"sourceEnv\",\"value\":\"{$Source.apex.EnvironmentVariables}\",\"required\":true},{\"name\":\"findAndReplaceFileId\",\"value\":\"{$Context.apex.GlobalFindAndReplaceSourceId}\",\"required\":false},{\"name\":\"featureBranch\",\"value\":\"{$Context.JobExecution__r.DataJson.featureBranchName}\",\"required\":true},{\"name\":\"recreateIfExists\",\"value\":\"{$Context.JobExecution__r.DataJson.recreateFeatureBranch}\",\"required\":true},{\"name\":\"commitMessage\",\"value\":\"{$Context.JobExecution__r.DataJson.message}\",\"required\":true},{\"name\":\"gitEmail\",\"value\":\"{$User.Email}\",\"required\":true},{\"name\":\"gitName\",\"value\":\"{$User.Name}\",\"required\":true},{\"name\":\"sourceEnvironmentBranch\",\"value\":\"{$Context.apex.SourceEnvironmentBranch}\",\"required\":true},{\"name\":\"gitDepth\",\"value\":\"{$Pipeline.Property.gitDepth_commit}\"},{\"name\":\"timeout\",\"value\":\"180000\"},{\"name\":\"chunkSize\",\"value\":\"10\"},{\"name\":\"maxBuffer\",\"value\":\"5242880\"},{\"name\":\"overriddenApiVersion\",\"value\":\"\"},{\"name\":\"commitId\",\"value\":\"{$Context.JobExecution__r.DataJson.commitId}\"},{\"name\":\"vlocityFilesPath\",\"value\":\"/app/vlocity/\"},{\"name\":\"disableEarlyCommitCompletion\",\"value\":\"{$Pipeline.Property.disableEarlyCommitCompletion}\"}]}",
                    "copado__CustomType__c": "Function",
                    "copado__IsSkipped__c": false,
                    "copado__JobTemplate__c": "a0u7Q000004z6sOQAQ",
                    "copado__Order__c": 2,
                    "copado__Type__c": "Function",
                    "Id": "a0t7Q00000BzrjrQAB",
                    "LastReferencedDate": "2023-05-25T06:32:10.000+0000",
                    "LastViewedDate": "2023-05-25T06:32:10.000+0000",
                    "Name": "SFDX Commit"
                },
                {
                    "attributes": {
                      "type": "copado__JobStep__c",
                      "url": "/services/data/v58.0/sobjects/copado__JobStep__c/a0t7Q00000CuMs5QAF"
                    },
                    "copado__ApiName__c": "SFDX Vlocity Commit_1_Create_Test_Records_3",
                    "copado__ConfigJson__c": "{\"flowName\":\"cmcSf.Test_Record_Automation\",\"parameters\":[{\"name\":\"userStoryId\",\"value\":\"{$Context.JobExecution__r.DataJson.userStoryId}\"},{\"name\":\"recreateFeatureBranch\",\"value\":\"{$Context.JobExecution__r.DataJson.recreateFeatureBranch}\"},{\"name\":\"fileWithSelectedChanges\",\"value\":\"{$Context.JobExecution__r.DataJson.fileWithSelectedChanges}\"},{\"name\":\"commitResult\",\"value\":\"{$Job.PrevStep.ResultDataJson__c}\"}]}",
                    "copado__CustomType__c": "Salesforce Flow",
                    "copado__IsSkipped__c": false,
                    "copado__JobTemplate__c": "a0u7Q000004z6sOQAQ",
                    "copado__Order__c": 3,
                    "copado__Type__c": "Flow",
                    "Id": "a0t7Q00000CuMs5QAF",
                    "LastReferencedDate": "2023-07-04T17:01:56.000+0000",
                    "LastViewedDate": "2023-07-04T17:01:56.000+0000",
                    "Name": "Create Test Records"
                },
                {
                    "attributes": {
                      "type": "copado__JobStep__c",
                      "url": "/services/data/v58.0/sobjects/copado__JobStep__c/a0t7Q000000vV7LQAU"
                    },
                    "copado__ApiName__c": "SFDX Vlocity Deploy_1_Deploy Vlocity_1",
                    "copado__ConfigJson__c": "{\"functionName\":\"deploy_vlocity\",\"parameters\":[{\"name\":\"promotionBranch\",\"value\":\"{$Context.JobExecution__r.DataJson.promotionBranchName}\"},{\"name\":\"targetBranch\",\"value\":\"{$Context.JobExecution__r.DataJson.destinationBranchName}\"},{\"name\":\"destinationInstanceUrl\",\"value\":\"{$Destination.Credential.Endpoint}\"},{\"name\":\"destinationSessionid\",\"value\":\"{$Destination.Credential.SessionId}\"},{\"name\":\"validationId\",\"value\":\"{$Job.ExecutionParent.Promotion__r.cmcSf__Validate_Deploy_Request_Id__c}\"},{\"name\":\"gitName\",\"value\":\"{$User.Name}\"},{\"name\":\"gitEmail\",\"value\":\"{$User.Email}\"},{\"name\":\"gitDepth\",\"value\":\"100\"},{\"name\":\"maxBuffer\",\"value\":\"5242880\"},{\"name\":\"hasVlocityChanges\",\"value\":\"{$Context.apex.cmcSf.HasVlocityChanges}\"},{\"name\":\"isValidation\",\"value\":\"{$Context.JobExecution__r.DataJson.deploymentDryRun}\"},{\"name\":\"vlocityDirectory\",\"value\":\"vlocity\"},{\"name\":\"git_json\",\"value\":\"{$Context.Repository.Credential}\"},{\"name\":\"repository_id\",\"value\":\"{$Pipeline.Git_Repository__r.Id}\"},{\"name\":\"file_changes_id\",\"value\":\"{$Context.JobExecution__r.DataJson.fileWithSelectedChanges}\"},{\"name\":\"file_name\",\"value\":\"Copado Deploy changes\"},{\"name\":\"attachVlocityLogFile\",\"value\":\"{$Job.ExecutionParent.Promotion__r.cmcSf__Attach_Vlocity_Build_File__c}\"},{\"name\":\"vlocitySettingsDocumentId\",\"value\":\"{$Context.apex.cmcSf.VlocitySettingsDestinationId}\"}]}",
                    "copado__CustomType__c": "Function",
                    "copado__IsSkipped__c": false,
                    "copado__JobTemplate__c": "a0u7Q000000qiAMQAY",
                    "copado__Order__c": 3,
                    "copado__Type__c": "Function",
                    "copado__SkipCondition__c": "{$Context.JobExecution__r.DataJson.deploymentDryRun.matches(\"true\")}",
                    "Id": "a0t7Q000000vV7LQAU",
                    "LastReferencedDate": "2023-06-28T08:47:40.000+0000",
                    "LastViewedDate": "2023-06-28T08:47:40.000+0000",
                    "Name": "Deploy Vlocity"
                },
                {
                    "attributes": {
                        "type": "copado__JobStep__c",
                        "url": "/services/data/v57.0/sobjects/copado__JobStep__c/a0t7Q000000vV7QQAU"
                    },
                    "copado__ApiName__c": "SFDX Vlocity Deploy_1_Encode file names_2",
                    "copado__ConfigJson__c": "{\"functionName\":\"sfdx_encode_file_names\",\"parameters\":[{\"name\":\"file_changes_id\",\"value\":\"{$Context.JobExecution__r.DataJson.fileWithSelectedChanges}\"},{\"name\":\"file_name\",\"value\":\"Copado Deploy changes\"}]}",
                    "copado__CustomType__c": "Function",
                    "copado__IsSkipped__c": false,
                    "copado__JobTemplate__c": "a0u7Q000000qiAMQAY",
                    "copado__Order__c": 1,
                    "copado__Type__c": "Function",
                    "Id": "a0t7Q000000vV7QQAU",
                    "Name": "Encode file names"
                },
                {
                    "attributes": {
                        "type": "copado__JobStep__c",
                        "url": "/services/data/v57.0/sobjects/copado__JobStep__c/a0t7Q000000vV7VQAU"
                    },
                    "copado__ApiName__c": "SFDX Vlocity Deploy_1_Deploy Salesforce_3",
                    "copado__ConfigJson__c": "{\"functionName\":\"sfdx_deploy\",\"parameters\":[{\"name\":\"fileChangesId\",\"value\":\"{$Context.JobExecution__r.DataJson.fileWithSelectedChanges}\",\"required\":true},{\"name\":\"promotion\",\"value\":\"{$Context.JobExecution__r.DataJson.promotionBranchName}\",\"required\":true},{\"name\":\"targetBranch\",\"value\":\"{$Context.JobExecution__r.DataJson.destinationBranchName}\",\"required\":true},{\"name\":\"destinationInstanceUrl\",\"value\":\"{$Destination.Credential.Endpoint}\",\"required\":true},{\"name\":\"destinationSessionid\",\"value\":\"{$Destination.Credential.SessionId}\",\"required\":true},{\"name\":\"git_json\",\"value\":\"{$Context.Repository.Credential}\",\"required\":true},{\"name\":\"destinationEnv\",\"value\":\"{$Destination.apex.EnvironmentVariables}\",\"required\":true},{\"name\":\"findAndReplaceRules\",\"value\":\"{$Context.apex.GlobalFindAndReplaceDestinationId}\"},{\"name\":\"isValidation\",\"value\":\"{$Context.JobExecution__r.DataJson.deploymentDryRun}\",\"required\":true},{\"name\":\"gitName\",\"value\":\"{$User.Name}\"},{\"name\":\"gitEmail\",\"value\":\"{$User.Email}\"},{\"name\":\"testLevel\",\"value\":\"{$Job.ExecutionParent.Promotion__r.cmcSf__Apex_Test_Level__c}\"},{\"name\":\"testOnlyClasses\",\"value\":\"{$Context.apex.cmcSf.GetTestOnlyClasses}\"},{\"name\":\"debugMode\",\"value\":\"{$Job.ExecutionParent.Promotion__r.cmcSf__Debug_Mode__c}\"},{\"name\":\"gitDepth\",\"value\":\"{$Pipeline.Property.gitDepth_deploy}\"},{\"name\":\"validationId\",\"value\":\"{$Job.ExecutionParent.Promotion__r.cmcSf__Validate_Deploy_Request_Id__c}\"},{\"name\":\"testClasses\",\"value\":\"{$Context.apex.cmcSf.GetTestClasses}\"},{\"name\":\"maxBuffer\",\"value\":\"5242880\"},{\"name\":\"waitTime\",\"value\":\"220\"},{\"name\":\"sourceInstanceUrl\",\"value\":\"{$Source.Credential.Endpoint}\"},{\"name\":\"sourceSessionid\",\"value\":\"{$Source.Credential.SessionId}\"},{\"name\":\"mergeProfile\",\"value\":\"false\"},{\"name\":\"overriddenApiVersion\",\"value\":\"\"},{\"name\":\"isProductionEnvironment\",\"value\":\"{$Context.apex.cmcSf.IdentifyProductionEnvironment}\",\"required\":true},{\"name\":\"hasVlocityChanges\",\"value\":\"{$Context.apex.cmcSf.HasVlocityChanges}\"},{\"name\":\"rollBackEnabled\",\"value\":\"{$Context.apex.cmcSf.IsRollBackEnabled}\"}]}",
                    "copado__CustomType__c": "Function",
                    "copado__IsSkipped__c": false,
                    "copado__JobTemplate__c": "a0u7Q000000qiAMQAY",
                    "copado__Order__c": 2,
                    "copado__Type__c": "Function",
                    "Id": "a0t7Q000000vV7VQAU",
                    "Name": "Deploy Salesforce"
                },
                {
                    "attributes": {
                      "type": "copado__JobStep__c",
                      "url": "/services/data/v58.0/sobjects/copado__JobStep__c/a0s09000007WCMyAAO"
                    },
                    "copado__ApiName__c": "SFDX_Git_Snapshot_1_Refresh_Metadata_3",
                    "copado__ConfigJson__c": "{\"flowName\":\"cmcSf.Refresh_Metadata\",\"parameters\":[{\"name\":\"credentialId\",\"value\":\"{$Job.ExecutionParent.copado__Org__c}\"}]}",
                    "copado__CustomType__c": "Salesforce Flow",
                    "copado__IsSkipped__c": false,
                    "copado__JobTemplate__c": "a0t090000086CbPAAU",
                    "copado__Order__c": 3,
                    "copado__Type__c": "Flow",
                    "Id": "a0s09000007WCMyAAO",
                    "Name": "Refresh Metadata"
                },
                {
                    "attributes": {
                      "type": "copado__JobStep__c",
                      "url": "/services/data/v58.0/sobjects/copado__JobStep__c/a0s09000007WCN3AAO"
                    },
                    "copado__ApiName__c": "SFDX_Git_Snapshot_1_Git_Snapshot_4",
                    "copado__ConfigJson__c": "{\"functionName\":\"sfdx_git_snapshot\",\"parameters\":[{\"name\":\"git_json\",\"value\":\"{$Context.Repository.Credential}\",\"required\":true},{\"name\":\"gitName\",\"value\":\"{$User.Name}\",\"required\":true},{\"name\":\"gitEmail\",\"value\":\"{$User.Email}\",\"required\":true},{\"name\":\"sourceEndpoint\",\"value\":\"{$Source.Credential.Endpoint}\",\"required\":true},{\"name\":\"sourceSessionId\",\"value\":\"{$Source.Credential.SessionId}\",\"required\":true},{\"name\":\"branch\",\"value\":\"{$Job.ExecutionParent.copado__Branch__c}\",\"required\":true},{\"name\":\"selectedMetadata\",\"value\":\"{$Job.ExecutionParent.copado__Scope__c}\"},{\"name\":\"snapshotInformation\",\"value\":\"{$Job.ExecutionParent.copado__Other_Information__c}\"},{\"name\":\"metadataRefreshResult\",\"value\":\"{$Job.PrevStep.Result__r.Result_Data__c}\",\"required\":true},{\"name\":\"overriddenApiVersion\",\"value\":\"\"},{\"name\":\"maximumRetryCount\",\"value\":\"1\",\"required\":true},{\"name\":\"commitMessage\",\"value\":\"{$Context.JobExecution__r.DataJson.message}\",\"required\":true},{\"name\":\"processesUsedForRetrieval\",\"value\":\"8\",\"required\":true},{\"name\":\"environmentVariables\",\"value\":\"{$Source.apex.EnvironmentVariables}\"},{\"name\":\"findAndReplaceFileId\",\"value\":\"{$Context.apex.GlobalFindAndReplaceSourceId}\"},{\"name\":\"maxBuffer\",\"value\":\"5242880\"},{\"name\":\"metadataChunkInfo\",\"value\":\"{\\\"staticresource\\\": 10, \\\"contentasset\\\": 10}\",\"required\":true},{\"name\":\"defaultMetadataChunkInfo\",\"value\":\"5000\",\"required\":true}],\"sharedResource\":\"{$Job.ExecutionParent.copado__Git_Repository__r.URI__c}/{$Job.ExecutionParent.copado__Branch__c}\"}",
                    "copado__CustomType__c": "Function",
                    "copado__IsSkipped__c": false,
                    "copado__JobTemplate__c": "a0t090000086CbPAAU",
                    "copado__Order__c": 4,
                    "copado__Type__c": "Function",
                    "Id": "a0s09000007WCN3AAO",
                    "Name": "Git Snapshot"
                },
                {
                    "attributes": {
                        "type": "copado__JobStep__c",
                        "url": "/services/data/v58.0/sobjects/copado__JobStep__c/a0s09000007WE7pAAG"
                    },
                    "copado__ApiName__c": "SFDX_Rollback_1_SFDX_Rollback_1",
                    "copado__ConfigJson__c": "{\"functionName\":\"SFDX_Rollback\",\"parameters\":[{\"name\":\"rollbackFileId\",\"value\":\"{$Context.JobExecution__r.DataJson.rollbackFileId}\",\"required\":true},{\"name\":\"isValidation\",\"value\":\"{$Context.JobExecution__r.DataJson.isValidation}\",\"required\":true},{\"name\":\"testLevel\",\"value\":\"{$Context.JobExecution__r.DataJson.testLevel}\"},{\"name\":\"promotion\",\"value\":\"{$Context.JobExecution__r.DataJson.promotion}\",\"required\":true},{\"name\":\"targetBranch\",\"value\":\"{$Context.JobExecution__r.DataJson.targetBranch}\",\"required\":true},{\"name\":\"destinationInstanceUrl\",\"value\":\"{$Destination.Credential.Endpoint}\",\"required\":true},{\"name\":\"destinationSessionid\",\"value\":\"{$Destination.Credential.SessionId}\",\"required\":true},{\"name\":\"gitName\",\"value\":\"{$User.Name}\",\"required\":false},{\"name\":\"gitEmail\",\"value\":\"{$User.Email}\",\"required\":false},{\"name\":\"maxBuffer\",\"value\":\"5242880\"},{\"name\":\"waitTime\",\"value\":\"220\"},{\"name\":\"git_json\",\"value\":\"{$Context.Repository.Credential}\",\"required\":true},{\"name\":\"destinationEnvVariables\",\"value\":\"{$Destination.apex.EnvironmentVariables}\",\"required\":false},{\"name\":\"findAndReplaceFileId\",\"value\":\"{$Context.apex.GlobalFindAndReplaceDestinationId}\"},{\"name\":\"isProductionEnvironment\",\"value\":\"{$Context.apex.cmcSf.IdentifyProductionEnvironment}\"},{\"name\":\"serviceLogLevel\",\"value\":\"{$Pipeline.Property.service_log_level}\"}]}",
                    "copado__CustomType__c": "Function",
                    "copado__IsSkipped__c": false,
                    "copado__JobTemplate__c": "a0t090000086EMQAA2",
                    "copado__Order__c": 1,
                    "copado__Type__c": "Function",
                    "Id": "a0s09000007WE7pAAG",
                    "Name": "SFDX Rollback"
                }
            ],
            "ObjectType": "copado__JobStep__c"
        }
    ],
    "blobsByUID": {}
}